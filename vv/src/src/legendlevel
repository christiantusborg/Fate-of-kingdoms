ac.c:        drunklevel = ch->pcdata->condition[COND_DRUNK];
ac.c:   if (ch->pcdata->confirm_delete)
ac.c:	    ch->pcdata->confirm_delete = FALSE;
ac.c:    	    sprintf( strsave, "%s%s", PLAYER_DIR, capitalize( ch->name ) );
ac.c:if (ch->level > 10)
ac.c:                   if (!str_cmp( res, ch->name ) )
ac.c:                   fprintf(fp,"%s\n",ch->name);
ac.c:	    if(ch->kingdom > 0) {
ac.c:	    subtract_member(ch->name,ch->kingdom); }
ac.c:    ch->pcdata->confirm_delete = TRUE;
ac.c:    if (!IS_SET(ch->comm,COMM_NOAUCTION))
ac.c:    if (!IS_SET(ch->comm,COMM_NOGOSSIP))
ac.c:    if (!IS_SET(ch->comm,COMM_NOQUESTION))
ac.c:    if (!IS_SET(ch->comm,COMM_NOQUEST))
ac.c:    if (!IS_SET(ch->comm,COMM_NOMUSIC))
ac.c:    if((ch->level <= 10) || IS_IMMORTAL(ch)) {
ac.c:    if (!IS_SET(ch->comm,COMM_NONEWBIE))
ac.c:      if(!IS_SET(ch->comm,COMM_NOWIZ))
ac.c:    if (!IS_SET(ch->comm,COMM_SHOUTSOFF))
ac.c:    if (!IS_SET(ch->comm,COMM_DEAF))
ac.c:    if (!IS_SET(ch->comm,COMM_NOARENA))
ac.c:    if (IS_SET(ch->comm,COMM_QUIET))
ac.c:    if (ch->msp == 1)
ac.c:	if (ch->vt == 1)
ac.c:    if (IS_SET(ch->comm,COMM_AFK))
ac.c:    if (IS_SET(ch->comm,COMM_SNOOP_PROOF))
ac.c:    if (ch->lines != PAGELEN)
ac.c:	if (ch->lines)
ac.c:	    sprintf(buf,"{cYou display {Y%d{c lines of scroll.{x\n\r",ch->lines+2);
ac.c:    if (IS_SET(ch->comm,COMM_NOSHOUT))
ac.c:    if (IS_SET(ch->comm,COMM_NOTELL))
ac.c:    if (IS_SET(ch->comm,COMM_NOCHANNELS))
ac.c:    if (IS_SET(ch->comm,COMM_NOEMOTE))
ac.c:   if (IS_SET(ch->comm,COMM_DEAF))
ac.c:     REMOVE_BIT(ch->comm,COMM_DEAF);
ac.c:     SET_BIT(ch->comm,COMM_DEAF);
ac.c:    if (IS_SET(ch->comm,COMM_QUIET))
ac.c:      REMOVE_BIT(ch->comm,COMM_QUIET);
ac.c:     SET_BIT(ch->comm,COMM_QUIET);
ac.c:    if (IS_SET(ch->comm,COMM_AFK))
ac.c:      REMOVE_BIT(ch->comm,COMM_AFK);
ac.c:     SET_BIT(ch->comm,COMM_AFK);
ac.c:    if (IS_SET(ch->comm,COMM_BUSY))
ac.c:      REMOVE_BIT(ch->comm,COMM_BUSY);
ac.c:     SET_BIT(ch->comm,COMM_BUSY);
ac.c:    page_to_char(buf_string(ch->pcdata->buffer),ch);
ac.c:    clear_buf(ch->pcdata->buffer);
ac.c:      if (IS_SET(ch->comm,(bitname)))
ac.c:        REMOVE_BIT(ch->comm,(bitname));
ac.c:        SET_BIT(ch->comm,(bitname));
ac.c:        if (IS_SET(ch->comm,COMM_QUIET))
ac.c:        if (IS_SET(ch->comm,COMM_NOCHANNELS))
ac.c:               REMOVE_BIT(ch->comm,(bitname));
ac.c:                !IS_SET(vch->comm,COMM_NOGOSSIP) &&
ac.c:                !IS_SET(vch->comm,COMM_QUIET))
ac.c:                !IS_SET(vch->comm,COMM_NOGOSSIP) &&
ac.c:                !IS_SET(vch->comm,COMM_QUIET))
ac.c:                !IS_SET(vch->comm, COMM_NOGOSSIP) &&
ac.c:                !IS_SET(vch->comm,COMM_QUIET))
ac.c:            sprintf( buf, "%s %s %s{x\n\r", type,ch->name, argument );
ac.c:    if ( ch->in_room == NULL )  {
ac.c:if (is_affected(ch,gsn_haste) &&  ch->pcdata->condition[COND_DRUNK] <= 0)
ac.c:	if (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10)
ac.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
ac.c:       for ( mob = ch->in_room->people; mob != NULL; mob = mob_next )
ac.c:  for (room_char = ch->in_room->people; room_char != NULL;
ac.c:    for (char_obj = ch->carrying; char_obj != NULL;
ac.c:    for (char_obj = ch->in_room->contents; char_obj != NULL;
ac.c:    if ( ch->in_room == NULL )  {
ac.c:if (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10)
ac.c: if (is_affected(ch,gsn_haste) && ch->pcdata->condition[COND_DRUNK] <=0)
ac.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
ac.c:    if ( (ch->in_room->sector_type != SECT_CITY)
ac.c:	|| (IS_SET(ch->in_room->room_flags, ROOM_WILDERNESS)) )
ac.c:      	if (IS_SET(ch->comm,COMM_SHOUTSOFF))
ac.c:            REMOVE_BIT(ch->comm,COMM_SHOUTSOFF);
ac.c:            SET_BIT(ch->comm,COMM_SHOUTSOFF);
ac.c:    if ( IS_SET(ch->comm, COMM_NOSHOUT) && !IS_NPC( ch ) )
ac.c:    if ( IS_SET(ch->comm, COMM_DEAF))
ac.c:    if (ch->gold < 10 )
ac.c:    if (ch->level < 25 )
ac.c:    REMOVE_BIT(ch->comm,COMM_SHOUTSOFF);
ac.c:ch->gold -= 10;
ac.c:	     d->character->in_room->area == ch->in_room->area &&
ac.c:	( (ch->in_room->sector_type == SECT_ROAD)
ac.c:	|| (!IS_SET(ch->in_room->room_flags, ROOM_WILDERNESS)) ) &&
ac.c:	     d->character->in_room->area == ch->in_room->area &&
ac.c:	( (ch->in_room->sector_type == SECT_ROAD)
ac.c:	|| (!IS_SET(ch->in_room->room_flags, ROOM_WILDERNESS)) ) &&
ac.c:    if ( IS_SET(ch->comm, COMM_NOTELL) || IS_SET(ch->comm,COMM_DEAF))
ac.c:    if ( IS_SET(ch->comm, COMM_QUIET) )
ac.c:    if (IS_SET(ch->comm,COMM_DEAF))
ac.c:    || ( IS_NPC(victim) && victim->in_room != ch->in_room ) )
ac.c:    if ( !(IS_IMMORTAL(ch) && ch->level > LEVEL_IMMORTAL) && !IS_AWAKE(victim) )
ac.c:if (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10)
ac.c:  if (is_affected(ch,gsn_haste) && ch->pcdata->condition[COND_DRUNK] <= 0)
ac.c:    if ( IS_SET(ch->comm, COMM_NOTELL) )
ac.c:    if ( ( victim = ch->reply ) == NULL )
ac.c:if (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10)
ac.c:  if (is_affected(ch,gsn_haste) && ch->pcdata->condition[COND_DRUNK] <= 0)
ac.c:    if ( IS_SET(ch->comm, COMM_NOSHOUT) && !IS_NPC(ch) )
ac.c:    if (ch->move < ch->max_move * .05)
ac.c://   if (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10)
ac.c:  if (is_affected(ch,gsn_haste) && ch->pcdata->condition[COND_DRUNK] <= 0)
ac.c:ch->move -= ch->max_move * .05;
ac.c:	&&   d->character->in_room->area == ch->in_room->area
ac.c:    if ( IS_SET(ch->comm, COMM_NOSHOUT) && !IS_NPC(ch) )
ac.c:    if (ch->move < ch->max_move * .05)
ac.c:if (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10)
ac.c:  if (is_affected(ch,gsn_haste) && ch->pcdata->condition[COND_DRUNK] <= 0)
ac.c:	ch->move -= ch->max_move * .05;
ac.c:	&&   d->character->in_room->area == ch->in_room->area
ac.c:    if ( !IS_NPC(ch) && IS_SET(ch->comm, COMM_NOEMOTE) )
ac.c:if (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10)
ac.c:  if (is_affected(ch,gsn_haste) && ch->pcdata->condition[COND_DRUNK] <= 0)
ac.c:    if ( !IS_NPC(ch) && IS_SET(ch->comm, COMM_NOEMOTE) )
ac.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
ac.c:	if (vch->desc == NULL || vch == ch)
ac.c:	if ((letter = strstr(argument,vch->name)) == NULL)
ac.c: 	name = vch->name;
ac.c:	    if (*letter == '\'' && matches == strlen(vch->name))
ac.c:	    if (*letter == 's' && matches == strlen(vch->name))
ac.c: 	    if (matches == strlen(vch->name))
ac.c:		if (matches == strlen(vch->name))
ac.c:		    name = vch->name;
ac.c:	    name = vch->name;
ac.c:    level = UMIN( ch->level, sizeof(pose_table) / sizeof(pose_table[0]) - 1 );
ac.c:    act( pose_table[pose].message[2*ch->class+0], ch, NULL, NULL, TO_CHAR );
ac.c:    act( pose_table[pose].message[2*ch->class+1], ch, NULL, NULL, TO_ROOM );
ac.c:    if (ch->level == 1)
ac.c:    if ( ch->position == POS_FIGHTING )
ac.c:    if ( ch->position  < POS_STUNNED  )
ac.c:    if ( ch->qflag == 1 ) 
ac.c:    if ((ch->pking > 0) && !IS_IMMORTAL(ch)) 
ac.c:    if ( ch->last_fight_time != -1 && !IS_IMMORTAL(ch) &&
ac.c:        (current_time - ch->last_fight_time)<FIGHT_DELAY_TIME) 
ac.c:    if (IS_SET(ch->act, PLR_ARENA) && iswar == TRUE)
ac.c:    if (IS_SET(ch->act,PLR_ARENA))
ac.c:	REMOVE_BIT(ch->act, PLR_ARENA);
ac.c:    if (ch->pcdata->confirm_delete)
ac.c:    sprintf( log_buf, "%s has quit.", ch->name );
ac.c:    for (vch=char_list;vch != NULL;vch = vch->next) {
ac.c:      if (is_affected(vch,gsn_doppelganger) && vch->doppel == ch) {
ac.c:      if (vch->guarding == ch)
ac.c:          vch->guarding  = NULL;
ac.c:          ch->guarded_by = NULL;
ac.c:      if (vch->last_fought == ch)
ac.c:        vch->last_fought = NULL;
ac.c:    if (ch->guarded_by != NULL)
ac.c:        ch->guarded_by->guarding = NULL;
ac.c:        ch->guarded_by = NULL;
ac.c:    if (ch->level > 1)
ac.c:    id = ch->id;
ac.c:     if (ch->pcdata->in_progress)
ac.c:     	free_note (ch->pcdata->in_progress);
ac.c:    d = ch->desc;
ac.c:	if (tch && tch->id == id)
ac.c:    if (ch->level<2)	
ac.c:    if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master != NULL )
ac.c:	act( "But you'd rather follow $N!", ch, NULL, ch->master, TO_CHAR );
ac.c:	if ( ch->master == NULL )
ac.c:    REMOVE_BIT(ch->act,PLR_NOFOLLOW);
ac.c:    if ( ch->master != NULL )
ac.c:    if ( ch->master != NULL )
ac.c:    ch->master        = master;
ac.c:    ch->leader        = NULL;
ac.c:    if ( ch->master == NULL )
ac.c:	REMOVE_BIT( ch->affected_by, AFF_CHARM );
ac.c:    if ( can_see( ch->master, ch ) && ch->in_room != NULL)
ac.c:	act( "$n stops following you.",     ch, NULL, ch->master, TO_VICT    );
ac.c:    	act( "You stop following $N.",      ch, NULL, ch->master, TO_CHAR    );
ac.c:    if (ch->master->pet == ch)
ac.c:	ch->master->pet = NULL;
ac.c:    ch->master = NULL;
ac.c:    ch->leader = NULL;
ac.c:    if ((pet = ch->pet) != NULL)
ac.c:    ch->pet = NULL;
ac.c:    if ( ch->master != NULL )
ac.c:    	if (ch->master->pet == ch)
ac.c:    	    ch->master->pet = NULL;
ac.c:    ch->leader = NULL;
ac.c:    for ( fch = char_list; fch != NULL; fch = fch->next )
ac.c:	if ( fch->master == ch )
ac.c:	if ( fch->leader == ch )
ac.c:	    fch->leader = fch;
ac.c:	leader = (ch->leader != NULL) ? ch->leader : ch;
ac.c:	for ( gch = char_list; gch != NULL; gch = gch->next )
ac.c:		    IS_NPC(gch) ? "Mob" : class_table[gch->class].who_name,
ac.c:		    PERCENT(gch->hit,   gch->max_hit),
ac.c:		    PERCENT(gch->mana,  gch->max_mana),
ac.c:		    PERCENT(gch->move,  gch->max_move),
ac.c:		    gch->exp );
ac.c:    if ( ch->master != NULL || ( ch->leader != NULL && ch->leader != ch ) )
ac.c:      if (ch->guarding == victim || victim->guarded_by == ch)
ac.c:          ch->guarding       = NULL;
ac.c:  if ( ch->level - victim->level < -8
ac.c:      ||   ch->level - victim->level > 8 )
ac.c:    if ( ch->gold <  amount_gold || ch->silver < amount_silver)
ac.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
ac.c:    ch->silver	-= amount_silver;
ac.c:    ch->silver	+= share_silver + extra_silver;
ac.c:    ch->gold 	-= amount_gold;
ac.c:    ch->gold 	+= share_gold + extra_gold;
ac.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
ac.c:	    gch->gold += share_gold;
ac.c:	    gch->silver += share_silver;
ac.c:    if ( IS_SET( ch->comm, COMM_NOTELL ) )
ac.c:if (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10)
ac.c:    for ( i = 0, gch = char_list; gch != NULL; gch = gch->next )
ac.c:    if ( ach->leader != NULL ) ach = ach->leader;
ac.c:    if ( bch->leader != NULL ) bch = bch->leader;
ac.c:        if (IS_SET(ch->act,PLR_COLOR))
ac.c:                REMOVE_BIT(ch->act,PLR_COLOR);
ac.c:            SET_BIT(ch->act,PLR_COLOR);
ac.c:    if ( !(ch->kingdom) )
ac.c:     if(ch->sex == SEX_FEMALE)
ac.c:	kingdom_table[ch->kingdom].rank_titlesf[ch->kingdom_rank]);
ac.c:	kingdom_table[ch->kingdom].rank_titles[ch->kingdom_rank]);
ac.c:if (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10)
ac.c:		(vch->kingdom == ch->kingdom) &&
ac.c:		 !IS_SET(vch->comm,COMM_QUIET))
ac.c:    if (IS_SET(ch->comm,COMM_NOCHANNELS))
ac.c:   if(ch->msp == 1 )
ac.c:	ch->msp = 0;
ac.c:	ch->msp = 1;
ac.c:  if( ch->vt == 1 )
ac.c:	ch->vt = 0;
ac.c:	ch->vt = 1;
ac.c:  if (IS_SET(ch->comm, COMM_BLOCKTITLE))
ac.c:    REMOVE_BIT(ch->comm, COMM_BLOCKTITLE);
ac.c:    SET_BIT(ch->comm, COMM_BLOCKTITLE);
ac.c:  if (IS_SET(ch->detection, D_LOCKHOST))
ac.c:    REMOVE_BIT(ch->detection, D_LOCKHOST);
ac.c:    SET_BIT(ch->detection, D_LOCKHOST);
ac.c:	if (!ch->sitelock)
ac.c:        if (IS_SET(ch->detection,D_PREFIX)
ac.c:        &&  IS_SET(ch->detection,D_SUFFIX)
ac.c:        &&  strstr(ch->sitelock,host) != NULL)
ac.c:        if (IS_SET(ch->detection,D_PREFIX)
ac.c:        &&  !str_suffix(ch->sitelock,host))
ac.c:        if (IS_SET(ch->detection,D_SUFFIX)
ac.c:        &&  !str_prefix(ch->sitelock,host))
ac.c:        SET_BIT(ch->detection,D_PREFIX);
ac.c:	else if(IS_SET(ch->detection,D_PREFIX))
ac.c:        REMOVE_BIT(ch->detection,D_PREFIX);
ac.c:        SET_BIT(ch->detection,D_SUFFIX);
ac.c:	else if(IS_SET(ch->detection,D_SUFFIX))
ac.c:        REMOVE_BIT(ch->detection,D_SUFFIX);
ac.c:    free_string(ch->sitelock);
ac.c:    ch->sitelock = str_dup(name);
ac.c:		ch->sitelock);
ac.c:        if (IS_SET(ch->info,INFO_ON))
ac.c:            REMOVE_BIT(ch->info,INFO_ON);
ac.c:            SET_BIT(ch->info,INFO_ON);
ac.c:      SET_BIT(ch->info,INFO_ON);
ac.c:        REMOVE_BIT(ch->info,INFO_ON);
ac.c:        if (!IS_SET(ch->info,INFO_ON))
ac.c:            if (IS_SET(ch->info,info_table[flag].flag))
ac.c:    if (IS_SET(ch->info,info_table[flag].flag))
ac.c:        REMOVE_BIT(ch->info,info_table[flag].flag);
ac.c:    SET_BIT(ch->info,info_table[flag].flag);
ae.c:	&&   (IS_NPC(ch) || IS_SET(ch->act,ACT_AGGRESSIVE) 
ae.c:    if ( ch->fighting != NULL ) 
ae.c:        old_room = ch->in_room;
ae.c:	portal = get_obj_list( ch, argument,  ch->in_room->contents );
ae.c:        if (IS_NPC(ch) && IS_SET(ch->act,ACT_AGGRESSIVE)
ae.c:            fch_next = fch->next_in_room;
ae.c:            if ( fch->master == ch && IS_AFFECTED(fch,AFF_CHARM)
ae.c:            &&   fch->position < POS_STANDING)
ae.c:            if ( fch->master == ch && fch->position == POS_STANDING)
ae.c:                if (IS_SET(ch->in_room->room_flags,ROOM_LAW)
ae.c:                &&  (IS_NPC(fch) && IS_SET(fch->act,ACT_AGGRESSIVE)))
ae.c:	    if (ch->in_room == old_room)
ae.c:   for( ach = char_list; ach != NULL; ach = ach->next )
ae.c:     if( ach->in_room && (ach->in_room->area != ch->in_room->area
ae.c:	|| !can_see( ch, ach ) || !is_name( arg, ach->name )) )
ae.c:    &&   ch->level < skill_table[gsn_hunt].skill_level[ch->class] )
ae.c:  if ( ch->level >= skill_table[gsn_world_find].skill_level[ch->class] )
ae.c:  if( ch->in_room == victim->in_room )
ae.c:    ch->hunting = victim;
ae.c:  if( ch->endur > 2 )
ae.c:    ch->endur -= 3;
ae.c:  direction = find_path( ch->in_room->vnum, victim->in_room->vnum,
ae.c:    	if (ch->in_room->exit[direction]!=NULL) {
ae.c:      while( ( ch->in_room->exit[direction] == NULL )
ae.c:	    || ( ch->in_room->exit[direction]->u1.to_room == NULL) );
ae.c:  	  ch->hunting=NULL;
ae.c:    if( ch->hunting == tmp )
ae.c:  if( !found || !can_see( ch, ch->hunting ) )
ae.c:     if( get_char_area( ch, ch->hunting->name) != NULL )
ae.c:           sprintf( tBuf, "portal %s", ch->hunting->name );
ae.c:	   if (ch->in_room==NULL || ch->hunting==NULL) return;
ae.c:	   if( ch->in_room == ch->hunting->in_room )
ae.c:		  ch, NULL, ch->hunting, TO_NOTVICT );
ae.c:		  ch, NULL, ch->hunting, TO_VICT );
ae.c:		  ch, NULL, ch->hunting, TO_CHAR);
ae.c:	      multi_hit( ch, ch->hunting, TYPE_UNDEFINED );
ae.c:	      ch->hunting = NULL;
ae.c:         ch->hunting = NULL;
ae.c:  dir = find_path( ch->in_room->vnum, ch->hunting->in_room->vnum,
ae.c:    if( get_char_area( ch, ch->hunting->name) != NULL  
ae.c:        && ch-> level > 35 )
ae.c:      sprintf( tBuf, "portal %s", ch->hunting->name );
ae.c:      if (ch->in_room==NULL || ch->hunting==NULL) return;
ae.c:      if( ch->in_room == ch->hunting->in_room )
ae.c:		  ch, NULL, ch->hunting, TO_NOTVICT );
ae.c:		  ch, NULL, ch->hunting, TO_VICT );
ae.c:		  ch, NULL, ch->hunting, TO_CHAR);
ae.c:        multi_hit( ch, ch->hunting, TYPE_UNDEFINED );
ae.c:        ch->hunting = NULL;
ae.c:      act( "$n says 'I have lost $M!'", ch, NULL, ch->hunting, TO_ROOM );
ae.c:      ch->hunting = NULL;
ae.c:  if( ch->in_room->exit[dir] && IS_SET( ch->in_room->exit[dir]->exit_info,EX_CLOSED ) )
ae.c:  if (!ch->in_room->exit[dir]) {
ae.c:		ch->hunting = NULL;
ae.c:  if (ch->in_room==NULL || ch->hunting==NULL) return;
ae.c:  if( ch->in_room == ch->hunting->in_room )
ae.c:	  ch, NULL, ch->hunting, TO_NOTVICT );
ae.c:	  ch, NULL, ch->hunting, TO_VICT );
ae.c:	  ch, NULL, ch->hunting, TO_CHAR);
ae.c:      multi_hit( ch, ch->hunting, TYPE_UNDEFINED );
ae.c:      ch->hunting = NULL;
ae.c:  if( ch == NULL || ch->hunting == NULL || !IS_NPC(ch) ) 
ae.c:    	if ((ROOM_INDEX_DATA*)ch->logon!=ch->in_room)
ae.c:    	char_to_room(ch,(ROOM_INDEX_DATA*)ch->logon);
ae.c:    if( ch->hunting == tmp )
ae.c:  if( !found || !can_see( ch, ch->hunting ) )
ae.c:/*1 */  if( get_char_world( ch, ch->hunting->name) != NULL  
ae.c:            && ch-> level > 35 )
ae.c:           sprintf( tBuf, "portal %s", ch->hunting->name );
ae.c:  here in a core file with ch->hunting==null.. */
ae.c:  if (ch->in_room==NULL || ch->hunting==NULL) return;
ae.c:  if( ch->in_room == ch->hunting->in_room )
ae.c:	  ch, NULL, ch->hunting, TO_NOTVICT );
ae.c:	  ch, NULL, ch->hunting, TO_VICT );
ae.c:	  ch, NULL, ch->hunting, TO_CHAR);
ae.c:      multi_hit( ch, ch->hunting, TYPE_UNDEFINED );
ae.c:      ch->hunting = NULL;
ae.c:          if ( (ROOM_INDEX_DATA*)ch->logon!=ch->in_room) 
ae.c:    	   char_to_room(ch,(ROOM_INDEX_DATA*)ch->logon);
ae.c:         ch->hunting = NULL;
ae.c:  dir = find_path( ch->in_room->vnum, ch->hunting->in_room->vnum,
ae.c:    if( get_char_area( ch, ch->hunting->name) != NULL  
ae.c:        && ch-> level > 35 )
ae.c:      sprintf( tBuf, "portal %s", ch->hunting->name );
ae.c:  here in a core file with ch->hunting==null.. */
ae.c:  if (ch->in_room==NULL || ch->hunting==NULL) return;
ae.c:  if( ch->in_room == ch->hunting->in_room )
ae.c:	  ch, NULL, ch->hunting, TO_NOTVICT );
ae.c:	  ch, NULL, ch->hunting, TO_VICT );
ae.c:	  ch, NULL, ch->hunting, TO_CHAR);
ae.c:      multi_hit( ch, ch->hunting, TYPE_UNDEFINED );
ae.c:      ch->hunting = NULL;
ae.c:    	if ((ROOM_INDEX_DATA*)ch->logon!=ch->in_room)
ae.c:    	  char_to_room(ch,(ROOM_INDEX_DATA*)ch->logon);
ae.c:      act( "$n says 'I have lost $M!'", ch, NULL, ch->hunting, TO_ROOM );
ae.c:      ch->hunting = NULL;
ae.c:    	if (ch->in_room->exit[dir]!=NULL) {
ae.c:      while( ( ch->in_room->exit[dir] == NULL )
ae.c:	    || ( ch->in_room->exit[dir]->u1.to_room == NULL ) );
ae.c:  	  ch->hunting=NULL;
ae.c:  if( ch->in_room->exit[dir] && IS_SET( ch->in_room->exit[dir]->exit_info,EX_CLOSED ) )
ae.c:	if (!ch->in_room->exit[dir]) {
ae.c:  here in a core file with ch->hunting==null.. */
ae.c:  if (ch->in_room==NULL || ch->hunting==NULL) return;
ae.c:  if( ch->in_room == ch->hunting->in_room )
ae.c:	  ch, NULL, ch->hunting, TO_NOTVICT );
ae.c:	  ch, NULL, ch->hunting, TO_VICT );
ae.c:	  ch, NULL, ch->hunting, TO_CHAR);
ae.c:      multi_hit( ch, ch->hunting, TYPE_UNDEFINED );
ae.c:      ch->hunting = NULL;
ai.c:	chexp = ch->exp;
ai.c:      ((ch->level >= victim->practice + 10) || (victim->practice >= ch->level + 10)))
ai.c:    if ( ch->desc == NULL )
ai.c:	    if ( IS_NPC(ch) || IS_SET(ch->comm, COMM_COMBINE) )
ai.c:	if ( IS_NPC(ch) || IS_SET(ch->comm, COMM_COMBINE) )
ai.c:	if ( IS_NPC(ch) || IS_SET(ch->comm, COMM_COMBINE) )
ai.c:    	if (IS_NPC(victim) &&ch->questmob > 0 
ai.c:	&& victim->pIndexData->vnum == ch->questmob)
ai.c:    if ( IS_SET(ch->act,PLR_HOLYLIGHT) && is_affected(victim,gsn_doppelganger))
ai.c:        if (!IS_NPC(victim->doppel) && !IS_SET(ch->comm, COMM_BRIEF))
ai.c:        if (!IS_NPC(victim->doppel) && !IS_SET(ch->comm, COMM_BRIEF))
ai.c:     if ( !IS_NPC(victim) && !IS_SET(ch->comm, COMM_BRIEF) 
ai.c:     &&   victim->position == POS_STANDING && ch->on == NULL )
ai.c:     if ( !IS_NPC(victim) && !IS_SET(ch->comm, COMM_BRIEF) 
ai.c:     &&   victim->position == POS_STANDING && ch->on == NULL )
ai.c:    for ( rch = list; rch != NULL; rch = rch->next_in_room )
ai.c:	if ( get_trust(ch) < rch->invis_level)
ai.c:	else if ( room_is_dark( ch->in_room ,ch)
ai.c:    if (!IS_NPC(ch) && IS_SET(ch->act,PLR_HOLYLIGHT))
ai.c:	capitalize(race_table[ch->race].name),
ai.c:	ch->sex == 0 ? "neuter" : ch->sex == 1 ? "male" : "female",
ai.c:     get_age(ch), IS_NPC(ch) ? "the beast" : ch->pcdata->sign);
ai.c:if (ch->kingdom > 0) /* only if in kingdom */
ai.c:if (ch->kingdom_rank==9) {
ai.c:capitalize(kingdom_table[ch->kingdom].short_name),kingdom_table[ch->kingdom].long_name);
ai.c:	capitalize(kingdom_table[ch->kingdom].short_name),
ai.c:	ch->kingdom_rank+1,
ai.c:        kingdom_table[ch->kingdom].rank_titles[ch->kingdom_rank]);
ai.c:	ch->level,
ai.c: 	IS_NPC(ch) ? "mobile" : capitalize(class_table[ch->class].name),
ai.c:	IS_NPC(ch) ? "Sanaria" : hometown_table[ch->hometown].name
ai.c:     if(ch->legendlevel > 0)
ai.c:		ch->legendlevel);
ai.c:   if (ch->pcdata->pkills == 0)
ai.c:   if (ch->pcdata->pkills > 1)
ai.c:   sprintf(buf,"{mIn your travels, you have managed to slay %d of your enemies.{x\n\r",ch->pcdata->pkills);
ai.c:   if (ch->pcdata->pkills == 1)
ai.c:   ((ch->pcdata->total_death > 1) && (ch->pcdata->total_death < 10))
ai.c:   sprintf(buf,"{mYou bear the scars of %d deaths, a somewhat trifling matter.{x\n\r",ch->pcdata->total_death);
ai.c:   if (ch->pcdata->total_death > 9)
ai.c:   sprintf(buf,"{mYou bear the scars of %d deaths, you might be better off dead.{x\n\r",ch->pcdata->total_death);
ai.c:   if (ch->pcdata->total_death == 1)
ai.c:   if (ch->pcdata->total_death == 0)
ai.c:if (ch->religion > 0) {
ai.c:        IS_NPC(ch) ? "Takeda" : religion_table[ch->religion].leader);
ai.c:if(ch->pcdata->spouse != NULL) {
ai.c:	sprintf(buf, "{mYou are married to %s.{w\n\r",ch->pcdata->spouse);
ai.c:	if (ch->lines == 0)
ai.c:		    ch->lines + 2);
ai.c:        ch->lines = 0;
ai.c:    ch->lines = lines - 2;
ai.c:    if (IS_SET(ch->act,PLR_AUTOASSIST))
ai.c:    if (IS_SET(ch->act,PLR_AUTOEXIT))
ai.c:    if (IS_SET(ch->act,PLR_AUTOGOLD))
ai.c:    if (IS_SET(ch->act,PLR_AUTOLOOT))
ai.c:    if (IS_SET(ch->act,PLR_AUTOSAC))
ai.c:    if (IS_SET(ch->act,PLR_AUTOSPLIT))
ai.c:     if (IS_SET(ch->act,PLR_AUTODAMAGE))
ai.c:    if (IS_SET(ch->act,PLR_COLOR))
ai.c:    if (IS_SET(ch->comm,COMM_COMPACT))
ai.c:    if (IS_SET(ch->comm,COMM_PROMPT))
ai.c:    if (IS_SET(ch->comm,COMM_COMBINE))
ai.c:    if (IS_SET(ch->act,PLR_NOSUMMON))
ai.c:    if (IS_SET(ch->act,PLR_NOFOLLOW))
ai.c:    if (IS_SET(ch->act,PLR_AUTOASSIST))
ai.c:      REMOVE_BIT(ch->act,PLR_AUTOASSIST);
ai.c:      SET_BIT(ch->act,PLR_AUTOASSIST);
ai.c:    if (IS_SET(ch->act,PLR_AUTOEXIT))
ai.c:      REMOVE_BIT(ch->act,PLR_AUTOEXIT);
ai.c:      SET_BIT(ch->act,PLR_AUTOEXIT);
ai.c:    if (IS_SET(ch->act,PLR_AUTOGOLD))
ai.c:      REMOVE_BIT(ch->act,PLR_AUTOGOLD);
ai.c:      SET_BIT(ch->act,PLR_AUTOGOLD);
ai.c:    if (IS_SET(ch->act,PLR_AUTOLOOT))
ai.c:      REMOVE_BIT(ch->act,PLR_AUTOLOOT);
ai.c:      SET_BIT(ch->act,PLR_AUTOLOOT);
ai.c:    if (IS_SET(ch->act,PLR_AUTOSAC))
ai.c:      REMOVE_BIT(ch->act,PLR_AUTOSAC);
ai.c:      SET_BIT(ch->act,PLR_AUTOSAC);
ai.c:    if (IS_SET(ch->act,PLR_AUTOSPLIT))
ai.c:      REMOVE_BIT(ch->act,PLR_AUTOSPLIT);
ai.c:      SET_BIT(ch->act,PLR_AUTOSPLIT);
ai.c:    if (IS_SET(ch->act,PLR_AUTODAMAGE))
ai.c:     REMOVE_BIT(ch->act,PLR_AUTODAMAGE);
ai.c:        SET_BIT(ch->act,PLR_AUTODAMAGE);
ai.c:    if (IS_SET(ch->comm,COMM_BRIEF))
ai.c:      REMOVE_BIT(ch->comm,COMM_BRIEF);
ai.c:      SET_BIT(ch->comm,COMM_BRIEF);
ai.c:    if (IS_SET(ch->comm,COMM_COMPACT))
ai.c:      REMOVE_BIT(ch->comm,COMM_COMPACT);
ai.c:      SET_BIT(ch->comm,COMM_COMPACT);
ai.c:    if (IS_SET(ch->comm,COMM_SHOW_AFFECTS))
ai.c:      REMOVE_BIT(ch->comm,COMM_SHOW_AFFECTS);
ai.c:      SET_BIT(ch->comm,COMM_SHOW_AFFECTS);
ai.c:	if (IS_SET(ch->comm,COMM_PROMPT))
ai.c:      	    REMOVE_BIT(ch->comm,COMM_PROMPT);
ai.c:      	    SET_BIT(ch->comm,COMM_PROMPT);
ai.c:   free_string( ch->prompt );
ai.c:   ch->prompt = str_dup( buf );
ai.c:   sprintf(buf,"Prompt set to %s\n\r",ch->prompt );
ai.c:    if (IS_SET(ch->comm,COMM_COMBINE))
ai.c:      REMOVE_BIT(ch->comm,COMM_COMBINE);
ai.c:      SET_BIT(ch->comm,COMM_COMBINE);
ai.c:    if (IS_SET(ch->act,PLR_NOFOLLOW))
ai.c:      REMOVE_BIT(ch->act,PLR_NOFOLLOW);
ai.c:      SET_BIT(ch->act,PLR_NOFOLLOW);
ai.c:      ch->charmie = 0;
ai.c:      if (IS_SET(ch->imm_flags,IMM_SUMMON))
ai.c:	REMOVE_BIT(ch->imm_flags,IMM_SUMMON);
ai.c:	SET_BIT(ch->imm_flags,IMM_SUMMON);
ai.c:      if (IS_SET(ch->act,PLR_NOSUMMON))
ai.c:        REMOVE_BIT(ch->act,PLR_NOSUMMON);
ai.c:        SET_BIT(ch->act,PLR_NOSUMMON);
ai.c:    if ( ch->desc == NULL )
ai.c:    if ( ch->position < POS_SLEEPING )
ai.c:    if ( ch->position == POS_SLEEPING )
ai.c:    &&   !IS_SET(ch->act, PLR_HOLYLIGHT)
ai.c:    &&   room_is_dark( ch->in_room ,ch) )
ai.c:	show_char_to_char( ch->in_room->people, ch );
ai.c:if (  !IS_SET(ch->in_room->room_flags, ROOM_WILDERNESS)   ) 
ai.c:	send_to_char( ch->in_room->name, ch );
ai.c:	if ( (IS_IMMORTAL(ch) && (IS_NPC(ch) || IS_SET(ch->act,PLR_HOLYLIGHT)))
ai.c:       ||   IS_BUILDER(ch, ch->in_room->area) )
ai.c:	    sprintf(buf," {M[Room %d]{w",ch->in_room->vnum);
ai.c:	|| ( !IS_NPC(ch) && !IS_SET(ch->comm, COMM_BRIEF) ) )
ai.c:	    send_to_char( ch->in_room->description, ch );
ai.c:        if (  !IS_NPC(ch) && IS_SET(ch->act, PLR_AUTOEXIT)       )
ai.c:else if (  IS_SET(ch->in_room->room_flags, ROOM_WILDERNESS)   ) 
ai.c:	show_list_to_char( ch->in_room->contents, ch, FALSE, FALSE );
ai.c:	show_char_to_char( ch->in_room->people,   ch );
ai.c:            if (ch->master)
ai.c:            ch->leader = victim;
ai.c:            af.level = ch->level;
ai.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
ai.c:    for ( obj = ch->in_room->contents; obj != NULL; obj = obj->next_content )
ai.c:    pdesc = get_extra_descr(arg3,ch->in_room->extra_descr);
ai.c:    if ( ( pexit = ch->in_room->exit[door] ) == NULL )
ai.c:   if( (!str_cmp(argument, "vt")) && (ch->vt == 1) )
ai.c:        if( IS_SET(ch->act, PLR_COLOR) )
ai.c:            if ( ( pexit = ch->in_room->exit[door] ) != NULL
ai.c:        &&   !IS_SET(ch->act, PLR_HOLYLIGHT)
ai.c:        &&   room_is_dark( ch->in_room,ch ) )
ai.c:            send_to_char( ch->in_room->name, ch );
ai.c:            sprintf( buf, "{w[{c%d{w]", ch->in_room->vnum );
ai.c:	if ( ( pexit = ch->in_room->exit[door] ) != NULL
ai.c:	    ch->gold,ch->silver);
ai.c:	ch->gold, ch->silver,ch->exp,
ai.c:/*	(ch->level + 1) * exp_per_level(ch,ch->pcdata->points) - ch->exp); */
ai.c:        exp_to_level( ch, ch->pcdata->points ) );
ai.c:else if (!IS_SET(ch->in_room->room_flags, ROOM_BOUNTY))
ai.c:	if (ch->pcdata->owed > 0)
ai.c:	ch->gold += ch->pcdata->owed;
ai.c:	ch->pcdata->owed = 0;
ai.c:    sprintf(buf, " the Mercurial %s", capitalize(class_table[ch->class].name ));
ai.c:    free_string( ch->pcdata->title );ch->pcdata->title = str_dup( buf );}
ai.c:    if (ch->gold < amount )
ai.c:    ch->gold -= amount;
ai.c:    sprintf(buf, " the Contractor %s", capitalize(class_table[ch->class].name ));
ai.c:    free_string( ch->pcdata->title );ch->pcdata->title = str_dup( buf );}
ai.c:  if (ch->max_hit > 0)
ai.c:          percent = ch->hit * 100 / ch->max_hit;
ai.c:  if (ch->max_mana > 0)
ai.c:          percent = ch->mana * 100 / ch->max_mana;
ai.c:  if (ch->max_mana > 0)
ai.c:          percent = ch->move * 100 / ch->max_move;
ai.c:     IS_NPC(ch) ? "" : ch->pcdata->pretitle,
ai.c:	ch->name,
ai.c:     IS_NPC(ch) ? "" : ch->pcdata->title
ai.c:     if ( get_trust( ch ) != ch->level )
ai.c:ch->level,
ai.c:IS_NPC(ch) ? 0 :exp_to_level(ch,ch->pcdata->points), 
ai.c:ch->name,
ai.c:IS_NPC(ch) ? "" : ch->pcdata->title,
ai.c:ch->hit,
ai.c:ch->max_hit,
ai.c:class_table[ch->class].name,
ai.c:ch->mana,
ai.c:ch->max_mana,
ai.c:ch->kingdom == 0 ? "None" : kingdom_table[ch->kingdom].long_name,
ai.c:ch->move,
ai.c:ch->max_move,
ai.c:ch->kingdom == 0 ? "None" : kingdom_table[ch->kingdom].rank_titles[ch->kingdom_rank]);
ai.c:if (ch->level > 10)
ai.c:ch->perm_stat[STAT_STR],get_curr_stat(ch,STAT_STR),ch->train,ch->wimpy,
ai.c:ch->perm_stat[STAT_INT],get_curr_stat(ch,STAT_INT),ch->practice,ch->quest_curr,ch->quest_accum,
ai.c:ch->perm_stat[STAT_WIS],get_curr_stat(ch,STAT_WIS),GET_DAMROLL(ch),ch->legendlevel,
ai.c:ch->perm_stat[STAT_DEX],get_curr_stat(ch,STAT_DEX),GET_HITROLL(ch),
ai.c:ch->perm_stat[STAT_CON],get_curr_stat(ch,STAT_CON)
ai.c:get_stat_alias(ch,STAT_STR),ch->train,ch->wimpy,
ai.c:get_stat_alias(ch,STAT_INT),ch->practice,
ai.c:/*    if (!IS_NPC(ch) && ch->level < LEVEL_HERO)
ai.c:        exp_to_level(ch,ch->pcdata->points));
ai.c:      if (IS_SET(ch->act,PLR_HOLYLIGHT))
ai.c:   if (ch->ethos == 1) send_to_char("     {m-={M( {CLawful  ", ch);
ai.c:    else if (ch->ethos == 2) send_to_char("     {m-={M( {CNeutral ", ch);
ai.c:    else if (ch->ethos == 3) send_to_char("     {m-={M( {CChaotic ", ch);
ai.c:    if (ch->level >= 84)
ai.c:    if ((ch->level <= 83) && (ch->level > 10))
ai.c:    switch ( ch->position )
ai.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK]   > 10 )
ai.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_THIRST] ==  0 )
ai.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_HUNGER]   <=  0 )
ai.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_BLOODLUST]   <=  0 )
ai.c:    if (ch->guarding != NULL)
ai.c:	sprintf(buf1, " {cGuarding %s{m,", ch->guarding->name);
ai.c:    if (ch->guarded_by != NULL)
ai.c:	sprintf(buf2, " {cGuarded by %s{m,", ch->guarded_by->name);
ai.c:	ch->carry_number, can_carry_n(ch),
ai.c:       ch->gold,
ai.c:       ch->silver);
ai.c:if (ch->level > 10)
ai.c:	if (ch->invis_level)
ai.c:        sprintf( buf, "      {MInvisible: {mlevel {b%d{x\n\r",ch->invis_level);
ai.c:	if (ch->incog_level)
ai.c:	  sprintf(buf,"      {MIncognito: {mlevel {b%d{x\n\r", ch->incog_level);
ai.c:    if ( ch->affected != NULL && IS_SET(ch->comm, COMM_SHOW_AFFECTS) )
ai.c:	for ( paf = ch->affected; paf != NULL; paf = paf->next )
ai.c:	    if ( ch->level >= 20 && IS_IMMORTAL(ch) )
ai.c:    if ( ch->affected != NULL )
ai.c:	for ( paf = ch->affected; paf != NULL; paf = paf->next )
ai.c:		if (ch->level >= 20 && 
ai.c:	( ch->class==3 || ch->class==6 || ch->class==7 || ch->class==8 || ch->class==9 || ch->class==14 ||
ai.c:		ch->race == 6 || ch->race==7 || ch->class == CLASS_DRD ||
ai.c:	    if ( ch->level >= 20 && 
ai.c:	( ch->class==3 || ch->class==6 || ch->class==7 || ch->class==8 || ch->class==9 || ch->class==14 ||
ai.c:		ch->race == 6 || ch->race==7 || ch->class==CLASS_DRD ||
ai.c:    if (ch->in_room->affected != NULL )
ai.c:        for ( paf = ch->in_room->affected; paf != NULL; paf = paf->next )
ai.c:                if (ch->level >= 20 )
ai.c:            if ( ch->level >= 20 )
ai.c:	if(ch->msp == 1)
ai.c:	string_append(ch, &ch->pcdata->background);
ai.c:	if (!str_prefix(arg,wch->name))
ai.c:	    class = class_table[wch->class].who_name;
ai.c:	    switch(wch->level)
ai.c:	    if ((wch->kingdom && (ch->kingdom == wch->kingdom || 
ai.c:                               wch->level >= LEVEL_HERO)
ai.c:	//		       wch->kingdom == KINGDOM_SIRIRIUS)
ai.c:	      sprintf(buf2, "{W[%s]{x ",kingdom_table[wch->kingdom].short_name);
ai.c:		wch->name,
ai.c:                wch->race < MAX_PC_RACE ?
ai.c:         pc_race_table[wch->race].name  : "     ",
ai.c:	hometown_table[wch->hometown].name);
ai.c:	if((wch->kingdom > 0) && wch->kingdom_rank >= 6) 
ai.c:		wch->sex == 0 ? "It" : wch->sex == 1 ? "He" : "She",
ai.c:	kingdom_table[wch->kingdom].rank_titles[wch->kingdom_rank],
ai.c:		kingdom_table[wch->kingdom].long_name	);
ai.c:	if((wch->kingdom > 0)  && wch->kingdom_rank < 6)
ai.c:		wch->sex == 0 ? "It" : wch->sex == 1 ? "He" : "She",
ai.c:		kingdom_table[wch->kingdom].long_name	);
ai.c:		wch->sex == 0 ? "It" : wch->sex == 1 ? "He" : "She");
ai.c:        if(wch->pcdata->spouse != NULL)
ai.c:	sprintf(buf, "  {G%s is married to %s.{w\n\r",wch->sex == 0 ? "It" : wch->sex == 1 ? "He" : "She",wch->pcdata->spouse);
ai.c:        sprintf(buf, "  {G%s is unmarried.{w\n\r",wch->sex == 0 ? "It" : wch->sex == 1 ? "He" : "She");
ai.c:                      wch->level >= LEVEL_HERO) {
ai.c:	wch->sex == 0 ? "It" : wch->sex == 1 ? "He" : "She",
ai.c:                  wch->level);
ai.c:		      wch->level,
ai.c:		      wch->race < MAX_PC_RACE ? 
ai.c:		        pc_race_table[wch->race].who_name: "     ",
ai.c:		      ( (ch==wch && ch->exp < PK_MIN) || 
ai.c:		      IS_SET(wch->act,PLR_WANTED) ? "{r(WANTED){x " : "",
ai.c:		      IS_SET(wch->act,PLR_KILLER) ? "{r(KILLER){x " : "",
ai.c:		      IS_SET(wch->act,PLR_THIEF) ? "{r(THIEF){x " : "",
ai.c:		      wch->name, IS_NPC(wch) ? "" : wch->pcdata->title);
ai.c:		      wch->race < MAX_PC_RACE ? 
ai.c:		        pc_race_table[wch->race].who_name: "     ",
ai.c:		      ( (ch==wch && ch->exp < PK_MIN) || 
ai.c:		      IS_SET(wch->act,PLR_WANTED) ? "{r(WANTED){x " : "",
ai.c:		      IS_SET(wch->act,PLR_KILLER) ? "{r(KILLER){x " : "",
ai.c:		      IS_SET(wch->act,PLR_THIEF) ? "{r(THIEF){x " : "",
ai.c:		      wch->name, IS_NPC(wch) ? "" : wch->pcdata->title);
ai.c:	    if (ch->kingdom != KINGDOM_SIRIUS && !IS_IMMORTAL(ch))
ai.c:	    if (ch->kingdom != KINGDOM_ASPER && !IS_IMMORTAL(ch))
ai.c:	    if (ch->kingdom != KINGDOM_HORDE && !IS_IMMORTAL(ch))
ai.c:	    if (ch->kingdom != KINGDOM_KUJIKIRI && !IS_IMMORTAL(ch))
ai.c:	    if (ch->kingdom != KINGDOM_CRESCENT && !IS_IMMORTAL(ch))
ai.c:	    if (ch->kingdom != KINGDOM_GEMMA && !IS_IMMORTAL(ch))
ai.c:	    if (ch->kingdom != KINGDOM_TRISTAN && !IS_IMMORTAL(ch))
ai.c:	if ( wch->level < iLevelLower
ai.c:	||   wch->level > iLevelUpper
ai.c:	|| ( fImmortalOnly  && wch->level < LEVEL_HERO )
ai.c:	|| ( fClassRestrict && !rgfClass[wch->class])
ai.c:	|| ( fRaceRestrict && !rgfRace[wch->race])
ai.c:	    || (fSiriusRestrict && wch->kingdom != KINGDOM_GONDOR)
ai.c:	    || (fCrescentRestrict && wch->kingdom != KINGDOM_MORDUKHAN)
ai.c:	    || (fHordeRestrict && wch->kingdom != KINGDOM_HORDE)
ai.c:	    || (fKujikiriRestrict && wch->kingdom != KINGDOM_ALDON)
ai.c:	    || (fAsperRestrict && wch->kingdom != KINGDOM_ARGUS)
ai.c:	    || (fGemmaRestrict && wch->kingdom != KINGDOM_GEMMA) 
ai.c:	    || (fTristanRestrict && wch->kingdom != KINGDOM_TRISTAN)
ai.c:if ( wch->level >= LEVEL_IMMORTAL )
ai.c:	class = class_table[wch->class].who_name;
ai.c:	switch ( wch->level )
ai.c:	if (((wch->kingdom && (wch->kingdom == ch->kingdom || 
ai.c:                           wch->level <= LEVEL_HERO ||
ai.c:			   wch->kingdom == KINGDOM_GONDOR) &&
ai.c:			   wch->kingdom != KINGDOM_NONE)
ai.c:  sprintf(kingdombuf,"{W[%s]{x ",kingdom_table[wch->kingdom].short_name);
ai.c:if ( wch->level >= LEVEL_IMMORTAL )
ai.c:                   wch->level >= LEVEL_HERO)
ai.c:	    wch->level,
ai.c:	    wch->race < MAX_PC_RACE ? pc_race_table[wch->race].who_name 
ai.c:	    IS_SET(wch->tag_flags,TAG_RED) ? "{R[RED] {x" :
ai.c:            (IS_SET(wch->tag_flags,TAG_BLUE) ? "{B[BLUE] {x" : ""),
ai.c:	    IS_SET(wch->act, PLR_WANTED) ? "{r(WANTED){x " : "",
ai.c:	    IS_SET(wch->act, PLR_KILLER) ? "{r(KILLER){x " : "",
ai.c:	    IS_SET(wch->act, PLR_THIEF)  ? "{r(THIEF){x "  : "",
ai.c:	    IS_NPC(wch) ? "" : wch->pcdata->pretitle,
ai.c:	    wch->name,
ai.c:	    IS_NPC(wch) ? "" : wch->pcdata->title );
ai.c:	    wch->race < MAX_PC_RACE ? pc_race_table[wch->race].who_name 
ai.c:	    IS_SET(wch->tag_flags,TAG_RED) ? "{R[RED] {x" :
ai.c:            (IS_SET(wch->tag_flags,TAG_BLUE) ? "{B[BLUE] {x" : ""),
ai.c:	    IS_SET(wch->act, PLR_WANTED) ? "{r(WANTED){x " : "",
ai.c:	    IS_SET(wch->act, PLR_KILLER) ? "{r(KILLER){x " : "",
ai.c:	    IS_SET(wch->act, PLR_THIEF)  ? "{r(THIEF){x "  : "",
ai.c:	    IS_NPC(wch) ? "" : wch->pcdata->pretitle,
ai.c:	    wch->name,
ai.c:	    IS_NPC(wch) ? "" : wch->pcdata->title );
ai.c:if ( wch->level < LEVEL_IMMORTAL )
ai.c:if (IS_TRUSTED(ch,LEVEL_IMMORTAL) || ch==wch || wch->level >= LEVEL_HERO)
ai.c:	    wch->level,
ai.c:	    wch->race < MAX_PC_RACE ? pc_race_table[wch->race].who_name 
ai.c:	  ( (ch==wch && ch->exp < PK_MIN) || 
ai.c:	    IS_SET(wch->tag_flags,TAG_RED) ? "{R[RED] {x" :
ai.c:            (IS_SET(wch->tag_flags,TAG_BLUE) ? "{B[BLUE] {x" : ""),
ai.c:	    IS_SET(wch->act, PLR_WANTED) ? "{r(WANTED){x " : "",
ai.c:	    IS_SET(wch->act, PLR_KILLER) ? "{r(KILLER){x " : "",
ai.c:	    IS_SET(wch->act, PLR_THIEF)  ? "{r(THIEF){x "  : "",
ai.c:	    IS_NPC(wch) ? "" : wch->pcdata->pretitle,
ai.c:	    wch->name,
ai.c:	    IS_NPC(wch) ? "" : wch->pcdata->title );
ai.c:	    wch->race < MAX_PC_RACE ? pc_race_table[wch->race].who_name 
ai.c:	  ( (ch==wch && ch->exp < PK_MIN) || 
ai.c: 	     IS_SET(wch->tag_flags,TAG_RED) ? "{R[RED] {x" :
ai.c:            (IS_SET(wch->tag_flags,TAG_BLUE) ? "{B[BLUE] {x" : ""),
ai.c:	    IS_SET(wch->act, PLR_WANTED) ? "{r(WANTED){x " : "",
ai.c:	    IS_SET(wch->act, PLR_KILLER) ? "{r(KILLER){x " : "",
ai.c:	    IS_SET(wch->act, PLR_THIEF)  ? "{r(THIEF){x "  : "",
ai.c:	    IS_NPC(wch) ? "" : wch->pcdata->pretitle,
ai.c:	    wch->name,
ai.c:	    IS_NPC(wch) ? "" : wch->pcdata->title );
ai.c:    show_list_to_char( ch->carrying, ch, TRUE, TRUE );
ai.c:	for (obj2 = ch->carrying; obj2 != NULL; obj2 = obj2->next_content)
ai.c:    if (room_is_dark(ch->in_room,NULL) && !IS_SET(ch->act, PLR_HOLYLIGHT)) {
ai.c:if (  !IS_SET(ch->in_room->room_flags, ROOM_WILDERNESS)   ) 
ai.c:		if (victim->in_room->area != ch->in_room->area)
ai.c:		if (victim->in_room->area != ch->in_room->area)
ai.c:		&& !IS_SET(ch->act,PLR_HOLYLIGHT))
ai.c:			"     " : "(PK) "),dch->name,
ai.c:		 dch->in_room->name );
ai.c:	    &&   victim->in_room->area == ch->in_room->area
ai.c:    VNUM=ch->in_room->vnum,
ai.c:		if (victim->in_room->area != ch->in_room->area)
ai.c:		if (victim->in_room->area != ch->in_room->area)
ai.c:		&& !IS_SET(ch->act,PLR_HOLYLIGHT))
ai.c:			"     " : "(PK) "),dch->name,
ai.c:		 dch->in_room->name );
ai.c:	    &&   victim->in_room->area == ch->in_room->area
ai.c:    diff = victim->level - ch->level;
ai.c:    free_string( ch->pcdata->title );
ai.c:    ch->pcdata->title = str_dup( buf );
ai.c:    free_string( ch->pcdata->pretitle );
ai.c:    ch->pcdata->pretitle = str_dup( buf );
ai.c:  sprintf( buf, "{MYou have been granted a title by the gods:\n\r '{W%s %s{M'{x\n\r", victim->name, ch->pcdata->title );
ai.c:string_append(ch, &ch->description);
ai.c:            if (ch->description == NULL || ch->description[0] == '\0')
ai.c:  	    strcpy(buf,ch->description);
ai.c:			free_string(ch->description);
ai.c:			ch->description = str_dup(buf);
ai.c:			send_to_char( ch->description ? ch->description : 
ai.c:	    free_string(ch->description);
ai.c:	    ch->description = str_dup(buf);
ai.c:	    if ( ch->description != NULL )
ai.c:		strcat( buf, ch->description );
ai.c:	free_string( ch->description );
ai.c:	ch->description = str_dup( buf );
ai.c:    send_to_char( ch->description ? ch->description : "(None).\n\r", ch );
ai.c:	PERCENT(ch->hit,  ch->max_hit),
ai.c:	PERCENT(ch->mana, ch->max_mana),
ai.c:	PERCENT(ch->move, ch->max_move));
ai.c:	PERCENT(ch->hit,  ch->max_hit),
ai.c:	PERCENT(ch->mana, ch->max_mana),
ai.c:	PERCENT(ch->move, ch->max_move));
ai.c:            if ( ch->level < skill_table[sn].skill_level[ch->class] ||
ai.c:(skill_table[sn].kingdom != ch->kingdom && skill_table[sn].kingdom != KINGDOM_NONE)
ai.c:                skill_table[sn].name, ch->pcdata->learned[sn] );
ai.c:            ch->practice );
ai.c:        if ( ch->practice <= 0 )
ai.c:        &&   (ch->level < skill_table[sn].skill_level[ch->class] ||
ai.c:(skill_table[sn].kingdom != ch->kingdom && skill_table[sn].kingdom != KINGDOM_NONE) ) ) )
ai.c: for ( mob = ch->in_room->people; mob != NULL; mob = mob->next_in_room )
ai.c:                  if (ch->kingdom == mob->kingdom)      break;
ai.c:        adept = IS_NPC(ch) ? 100 : class_table[ch->class].skill_adept;
ai.c:        if ( ch->pcdata->learned[sn] >= adept )
ai.c:            if (!ch->pcdata->learned[sn]) ch->pcdata->learned[sn] = 1;
ai.c:            ch->practice--;
ai.c:			temp = skill_table[sn].rating[ch->class];
ai.c:            ch->pcdata->learned[sn] +=
ai.c:            if ( ch->pcdata->learned[sn] < adept )
ai.c:                ch->pcdata->learned[sn] = adept;
ai.c:	wimpy = ch->max_hit / 5;
ai.c:        if ( ch->level < 40 )  {
ai.c:          wimpy = (ch->max_hit*wimpy)/100;
ai.c:    if ( wimpy > ch->max_hit/2 )
ai.c:    ch->wimpy	= wimpy;
ai.c:    if ( strcmp( crypt( arg1, ch->pcdata->pwd ), ch->pcdata->pwd ) )
ai.c:    pwdnew = crypt( arg2, ch->name );
ai.c:    free_string( ch->pcdata->pwd );
ai.c:    ch->pcdata->pwd = str_dup( pwdnew );
ai.c:  range = 1 + (ch->level)/10;
ai.c:  in_room = ch->in_room;
ai.c:  if (ch->move < (50 + ch->level))
ai.c:  ch->move -= 10;
ai.c:  ch->move = UMAX(ch->move, 0);
ai.c:  if (victim->level >= ch->level + 10 || victim->level >= ch->level * 2)
ai.c:	do_murder(victim,ch->name);
ai.c:	do_murder(victim,ch->name);
ai.c:  if ( ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
ai.c:  if ( ch->carry_weight + get_obj_weight( obj ) > can_carry_w( ch ) )
ai.c:  ch->move -= (50 + ch->level);
ai.c:  ch->move = UMAX(ch->move, 0);
ai.c:  ch->hit -= 3 * (ch->level / 2);
ai.c:  ch->hit = UMAX(ch->hit, 0);
ai.c:  if (!IS_SET(ch->in_room->room_flags, ROOM_REGISTRY))
ai.c:  amount = (ch->level * ch->level * 10) + 1000;
ai.c:  if (ch->gold < amount)
ai.c:      if (ch->hometown == 0)
ai.c:      ch->gold -= amount;
ai.c:      ch->hometown = 0;
ai.c:      if (ch->hometown == 1)
ai.c:      ch->gold -= amount;
ai.c:      ch->hometown = 1;
ai.c:      if (ch->hometown == 2)
ai.c:      ch->gold -= amount;
ai.c:      ch->hometown = 2;
ai.c:      if (ch->hometown == 3)
ai.c:      ch->gold -= amount;
ai.c:      ch->hometown = 3;
ai.c:      if (ch->hometown == 4)
ai.c:      ch->gold -= amount;
ai.c:      ch->hometown = 4;
ai.c:      ch->level < skill_table[gsn_detect_hidden].skill_level[ch->class] )
ai.c:    af.level     = ch->level;
ai.c:    af.duration  = ch->level;
ai.c:      ch->level < skill_table[gsn_bear_call].skill_level[ch->class] )
ai.c:  for (gch = char_list; gch != NULL; gch = gch->next)
ai.c:      if (IS_NPC(gch) && IS_AFFECTED(gch,AFF_CHARM) && gch->master == ch &&
ai.c:	  gch->pIndexData->vnum == MOB_VNUM_BEAR)
ai.c:  if ( ch->in_room != NULL && IS_SET(ch->in_room->room_flags, ROOM_NO_MOB) )
ai.c:  if ( IS_SET(ch->in_room->room_flags, ROOM_SAFE)      ||
ai.c:       IS_SET(ch->in_room->room_flags, ROOM_PRIVATE)   ||
ai.c:       IS_SET(ch->in_room->room_flags, ROOM_SOLITARY)  ||
ai.c:       (ch->in_room->exit[0] == NULL &&
ai.c:          ch->in_room->exit[1] == NULL &&
ai.c:          ch->in_room->exit[2] == NULL &&
ai.c:          ch->in_room->exit[3] == NULL &&
ai.c:          ch->in_room->exit[4] == NULL &&
ai.c:          ch->in_room->exit[5] == NULL) ||
ai.c:         ( ch->in_room->sector_type != SECT_FIELD &&
ai.c:           ch->in_room->sector_type != SECT_FOREST &&
ai.c:           ch->in_room->sector_type != SECT_MOUNTAIN &&
ai.c:           ch->in_room->sector_type != SECT_HILLS ) )
ai.c:  if ( ch->mana < 125 )
ai.c:  ch->mana -= 125;
ai.c:      bear->perm_stat[i] = UMIN(25,2 * ch->perm_stat[i]);
ai.c:  bear->max_hit = ((IS_NPC(ch)? ch->max_hit : ch->pcdata->perm_hit)/2);
ai.c:  bear->max_mana = IS_NPC(ch)? ch->max_mana : ch->pcdata->perm_mana;
ai.c:  bear->alignment = ch->alignment;
ai.c:  bear->level = (UMIN(70,1 * ch->level-2)-5);
ai.c:  bear->sex = ch->sex;
ai.c:  if(ch->level >= 60) {
ai.c:  char_to_room(bear2,ch->in_room);
ai.c:  char_to_room(bear,ch->in_room);
ai.c:  char_to_room(bear,ch->in_room);
ai.c:  af.level              = ch->level; 
ai.c:      ch->level < skill_table[gsn_acute_vision].skill_level[ch->class] )
ai.c:    af.level     = ch->level;
ai.c:    af.duration  = ch->level;
ai.c:      ch->level < skill_table[gsn_dark_vision].skill_level[ch->class] )
ai.c:    af.level     = ch->level;
ai.c:    af.duration  = ch->level / 3;
ai.c: if ( IS_SET( ch->quest, QUEST_WEAPONSMITH ) )  
ai.c: if ( IS_SET( ch->quest, QUEST_GOLEM ) )  
ai.c: if(!IS_SET(ch->quest,QUEST_WEAPONSMITH) && !IS_SET(ch->quest,QUEST_GOLEM))
ai.c:         ch->pcdata->email);
ai.c:    ch->pcdata->email = strdup(arg2);
ai.c:          ch->pcdata->email);
ai.c:       ch->pcdata->real_name);
ai.c:    ch->pcdata->real_name = strdup(arg2);
ai.c:       ch->pcdata->real_name);
ai.c:    if(ch->level < MAX_LEVEL)
alias.c:    if (ch->prefix[0] != '\0' && str_prefix("prefix",argument))
alias.c:	if (strlen(ch->prefix) + strlen(argument) > MAX_INPUT_LENGTH)
alias.c:	    sprintf(prefix,"%s %s",ch->prefix,argument);
alias.c:    if (IS_NPC(ch) || ch->pcdata->alias[0] == NULL
alias.c:	if (ch->pcdata->alias[alias] == NULL)
alias.c:	if (!str_prefix(ch->pcdata->alias[alias],argument))
alias.c:	    if (!strcmp(ch->pcdata->alias[alias],name))
alias.c:		strcat(buf,ch->pcdata->alias_sub[alias]);
alias.c:    if (ch->desc == NULL)
alias.c:	rch = ch->desc->original ? ch->desc->original : ch;
alias.c:	if (rch->pcdata->alias[0] == NULL)
alias.c:	    if (rch->pcdata->alias[pos] == NULL
alias.c:	    ||	rch->pcdata->alias_sub[pos] == NULL)
alias.c:	    sprintf(buf,"    %s:  %s\n\r",rch->pcdata->alias[pos],
alias.c:		    rch->pcdata->alias_sub[pos]);
alias.c:	    if (rch->pcdata->alias[pos] == NULL
alias.c:	    ||	rch->pcdata->alias_sub[pos] == NULL)
alias.c:	    if (!str_cmp(arg,rch->pcdata->alias[pos]))
alias.c:		sprintf(buf,"%s aliases to '%s'.\n\r",rch->pcdata->alias[pos],
alias.c:			rch->pcdata->alias_sub[pos]);
alias.c:	if (rch->pcdata->alias[pos] == NULL)
alias.c:	if (!str_cmp(arg,rch->pcdata->alias[pos])) /* redefine an alias */
alias.c:	    free_string(rch->pcdata->alias_sub[pos]);
alias.c:	    rch->pcdata->alias_sub[pos] = str_dup(argument);
alias.c:     rch->pcdata->alias[pos]		= str_dup(arg);
alias.c:     rch->pcdata->alias_sub[pos]	= str_dup(argument);
alias.c:    if (ch->desc == NULL)
alias.c:	rch = ch->desc->original ? ch->desc->original : ch;
alias.c:	if (rch->pcdata->alias[pos] == NULL)
alias.c:	    rch->pcdata->alias[pos-1]		= rch->pcdata->alias[pos];
alias.c:	    rch->pcdata->alias_sub[pos-1]	= rch->pcdata->alias_sub[pos];
alias.c:	    rch->pcdata->alias[pos]		= NULL;
alias.c:	    rch->pcdata->alias_sub[pos]		= NULL;
alias.c:	if(!strcmp(arg,rch->pcdata->alias[pos]))
alias.c:	    free_string(rch->pcdata->alias[pos]);
alias.c:	    free_string(rch->pcdata->alias_sub[pos]);
alias.c:	    rch->pcdata->alias[pos] = NULL;
alias.c:	    rch->pcdata->alias_sub[pos] = NULL;
am.c:  if ( IS_SET(ch->tag_flags, TAG_FROZEN)
am.c:    &&   IS_SET(ch->tag_flags, TAG_PLAYING))
am.c:	REMOVE_BIT(ch->affected_by, AFF_HIDE);
am.c:	REMOVE_BIT(ch->affected_by, AFF_FADE);
am.c:	REMOVE_BIT(ch->affected_by, AFF_CAMOUFLAGE);
am.c:    in_room = ch->in_room;
am.c:    &&   ch->master != NULL
am.c:    &&   in_room == ch->master->in_room )
am.c:	ch->riding = FALSE;
am.c:	ch->mount = NULL;
am.c:		    if ( iClass != ch->class )  {
am.c:                    if (ch->last_fight_time != -1 &&
am.c:                      current_time - ch->last_fight_time < FIGHT_DELAY_TIME)
am.c:	    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
am.c:	  if ( !MOUNTED(ch) && ch->move < move )
am.c:	if ((ch->in_room->sector_type == SECT_FOREST) ||
am.c:	    (ch->in_room->sector_type == SECT_JUNGLE)) {
am.c:	if ((ch->in_room->sector_type == SECT_HILLS) ||
am.c:	    (ch->in_room->sector_type == SECT_MOUNTAIN) ||
am.c:	    (ch->in_room->sector_type == SECT_SNOW_MOUNTAIN) ||
am.c:	    (ch->in_room->sector_type == SECT_CAVERN) ||
am.c:	    (ch->in_room->sector_type == SECT_ROCK_MOUNTAIN)) {
am.c:        if ( ch->in_room->sector_type == SECT_DESERT ||
am.c:             IS_WATER(ch->in_room) )
am.c:        if (!MOUNTED(ch))       ch->move -= move;
am.c:    &&   ch->invis_level < LEVEL_HERO)
am.c:        if (!IS_NPC(ch) && ch->in_room->sector_type != SECT_INSIDE &&
am.c:            ch->in_room->sector_type != SECT_CITY &&
am.c:            number_percent() < ch->pcdata->learned[gsn_quiet_movement])
am.c:    if (!IS_NPC(ch) && ch->in_room)
am.c:      room_record(ch->name,in_room, door);
am.c:    &&   ch->invis_level < LEVEL_HERO)
am.c:    pArea = ch->in_room->area;
am.c:    if(ch->msp == 1)
am.c:         ch->riding = TRUE;
am.c:        fch_next = fch->next_in_room;
am.c:      fch_next = fch->next_in_room;
am.c:      for (obj = fch->carrying;room_has_pc && obj != NULL;
am.c:      if (room_has_pc && IS_SET(fch->progtypes,MPROG_GREET))
am.c:        (fch->pIndexData->moprogs->greet_prog) (fch,ch);
am.c:    for (obj = ch->carrying;room_has_pc && obj!=NULL;obj=obj->next_content)
am.c:	fch_next = fch->next_in_room;
am.c:	if ( fch->master == ch && IS_AFFECTED(fch,AFF_CHARM) 
am.c:	&&   fch->position < POS_STANDING)
am.c:	if ( fch->master == ch && fch->position == POS_STANDING 
am.c:	    if (IS_SET(ch->in_room->room_flags,ROOM_LAW)
am.c:	    &&  (IS_NPC(fch) && IS_SET(fch->act,ACT_AGGRESSIVE)))
am.c:    for (obj = ch->in_room->contents;room_has_pc && obj != NULL;
am.c:    if ( /* room_has_pc && */ IS_SET(ch->progtypes,MPROG_ENTRY))
am.c:      (ch->pIndexData->moprogs->entry_prog) (ch);
am.c:	    if ( ( pexit = ch->in_room->exit[door] ) != NULL
am.c:    if ( ( pexit = ch->in_room->exit[door] ) == NULL )
am.c:	pexit = ch->in_room->exit[door];
am.c:	&&   pexit_rev->u1.to_room == ch->in_room )
am.c:	    for ( rch = to_room->people; rch != NULL; rch = rch->next_in_room )
am.c:	pexit	= ch->in_room->exit[door];
am.c:	&&   pexit_rev->u1.to_room == ch->in_room )
am.c:	    for ( rch = to_room->people; rch != NULL; rch = rch->next_in_room )
am.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
am.c:    for ( obj = ch->in_room->contents; obj != NULL; obj = obj->next_content )
am.c:	pexit	= ch->in_room->exit[door];
am.c:	&&   pexit_rev->u1.to_room == ch->in_room )
am.c:	    for ( rch = to_room->people; rch != NULL; rch = rch->next_in_room )
am.c:	pexit = ch->in_room->exit[door];
am.c:	&&   pexit_rev->u1.to_room == ch->in_room )
am.c:	    for ( rch = to_room->people; rch != NULL; rch = rch->next_in_room )
am.c:    for ( gch = ch->in_room->people; gch; gch = gch->next_in_room )
am.c:	if ( IS_NPC(gch) && IS_AWAKE(gch) && ch->level + 5 < gch->level )
am.c:	pexit = ch->in_room->exit[door];
am.c:	&&   pexit_rev->u1.to_room == ch->in_room )
am.c:	if (ch->position == POS_FIGHTING)
am.c:	obj = get_obj_list(ch,argument,ch->in_room->contents);
am.c:	if (ch->on != obj && count_users(obj) >= obj->value[0])
am.c:    switch ( ch->position )
am.c:	    ch->on = NULL;
am.c:  if(ch->msp == 1)
am.c:	ch->position = POS_STANDING;
am.c:	    ch->on = NULL;
am.c:	ch->position = POS_STANDING;
am.c:    if (ch->position == POS_FIGHTING)
am.c:	obj = get_obj_list(ch,argument,ch->in_room->contents);
am.c:    else obj = ch->on;
am.c:        if (obj != NULL && ch->on != obj && count_users(obj) >= obj->value[0])
am.c:	ch->on = obj;
am.c:    switch ( ch->position )
am.c:	ch->position = POS_RESTING;
am.c:	ch->position = POS_RESTING;
am.c:	ch->position = POS_RESTING;
am.c:    if (ch->position == POS_FIGHTING)
am.c:	obj = get_obj_list(ch,argument,ch->in_room->contents);
am.c:    else obj = ch->on;
am.c:	if (obj != NULL && ch->on != obj && count_users(obj) >= obj->value[0])
am.c:	ch->on = obj;
am.c:    switch (ch->position)
am.c:	    ch->position = POS_SITTING;
am.c:	    ch->position = POS_SITTING;
am.c:    	    ch->position = POS_SITTING;
am.c:    switch ( ch->position )
am.c:	if (argument[0] == '\0' && ch->on == NULL)
am.c:          if(ch->msp == 1)
am.c:	    ch->position = POS_SLEEPING;
am.c:		obj = ch->on;
am.c:	    	obj = get_obj_list( ch, argument,  ch->in_room->contents );
am.c:	    if (ch->on != obj && count_users(obj) >= obj->value[0])
am.c:	    ch->on = obj;
am.c:  if(ch->msp == 1)
am.c:  if(ch->msp == 1)
am.c:  if(ch->msp == 1)
am.c:	    ch->position = POS_SLEEPING;
am.c:	af.level     = ch->level; 
am.c:	af.duration  = ch->level;
am.c:  if (!(room_is_dark (ch->in_room,NULL)))
am.c:	ch->level < skill_table[gsn_fade].skill_level[ch->class] )
am.c:	REMOVE_BIT(ch->affected_by, AFF_HIDE);
am.c:	REMOVE_BIT(ch->affected_by, AFF_FADE);
am.c:    if ( IS_NPC(ch) || number_percent( ) < ch->pcdata->learned[gsn_fade] )
am.c:	SET_BIT(ch->affected_by, AFF_FADE);
am.c:    &&   ch->level < skill_table[gsn_hide].skill_level[ch->class] )
am.c:    forest += ch->in_room->sector_type == SECT_FOREST?60:0;
am.c:    forest += ch->in_room->sector_type == SECT_FIELD?60:0;
am.c:	SET_BIT(ch->affected_by, AFF_HIDE);
am.c:	REMOVE_BIT(ch->affected_by, AFF_HIDE);
am.c:         ch->level < skill_table[gsn_camouflage].skill_level[ch->class] )
am.c:    if (ch->in_room->sector_type != SECT_FOREST &&
am.c:	ch->in_room->sector_type != SECT_HILLS  &&
am.c:	ch->in_room->sector_type != SECT_MOUNTAIN)
am.c:	REMOVE_BIT(ch->affected_by, AFF_CAMOUFLAGE);
am.c:	number_percent( ) < ch->pcdata->learned[gsn_camouflage] )
am.c:	SET_BIT(ch->affected_by, AFF_CAMOUFLAGE);
am.c:    if (IS_SET(ch->affected_by, AFF_FADE))
am.c:	REMOVE_BIT(ch->affected_by, AFF_FADE);
am.c:	if (IS_SET(ch->affected_by, AFF_HIDE))
am.c:	REMOVE_BIT(ch->affected_by, AFF_HIDE);
am.c:    if (IS_SET(ch->affected_by, AFF_CAMOUFLAGE))
am.c:	REMOVE_BIT(ch->affected_by,AFF_CAMOUFLAGE);
am.c:    if (IS_SET(ch->affected_by, AFF_INVISIBLE))
am.c:	REMOVE_BIT(ch->affected_by, AFF_INVISIBLE);
am.c:    if (IS_SET(ch->affected_by, AFF_SNEAK) 
am.c:	&& !IS_NPC(ch) && !IS_SET(race_table[ch->race].aff,AFF_SNEAK) )
am.c:	REMOVE_BIT(ch->affected_by, AFF_SNEAK);
am.c:      point = hometown_table[ch->hometown].recall[0];
am.c:      point = hometown_table[ch->hometown].recall[2];
am.c:      point = hometown_table[ch->hometown].recall[1];
am.c:    if (IS_NPC(ch) && !IS_SET(ch->act,ACT_PET))
am.c:    if (ch->level >= 11)
am.c:    if (ch->desc != NULL && current_time - ch->last_fight_time
am.c:    if (ch->desc == NULL && !IS_NPC(ch))
am.c:    if ( ch->in_room == location )
am.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
am.c:    if ( ( victim = ch->fighting ) != NULL )
am.c:	    skill = 40 + ch->level;
am.c:	    skill = ch->pcdata->learned[gsn_recall];
am.c:    ch->move /= 2;
am.c:    if (ch->pet != NULL)
am.c: 	char_from_room( ch->pet );
am.c:	char_to_room( ch->pet, location );
am.c:	do_look(ch->pet,"auto");
am.c:    for ( mob = ch->in_room->people; mob; mob = mob->next_in_room )
am.c:	sprintf( buf, "You have %d training sessions.\n\r", ch->train );
am.c:	if ( class_table[ch->class].attr_prime == STAT_STR )
am.c:	if ( class_table[ch->class].attr_prime == STAT_INT )
am.c:	if ( class_table[ch->class].attr_prime == STAT_WIS )
am.c:	if ( class_table[ch->class].attr_prime == STAT_DEX )
am.c:	if ( class_table[ch->class].attr_prime == STAT_CON )
am.c:	if ( ch->perm_stat[STAT_STR] < get_max_train(ch,STAT_STR)) 
am.c:	if ( ch->perm_stat[STAT_INT] < get_max_train(ch,STAT_INT))  
am.c:	if ( ch->perm_stat[STAT_WIS] < get_max_train(ch,STAT_WIS)) 
am.c:	if ( ch->perm_stat[STAT_DEX] < get_max_train(ch,STAT_DEX))  
am.c:	if ( ch->perm_stat[STAT_CON] < get_max_train(ch,STAT_CON))  
am.c:		ch->sex == SEX_MALE   ? "big stud" :
am.c:		ch->sex == SEX_FEMALE ? "hot babe" :
am.c:    	if ( cost > ch->train )
am.c:	ch->train -= cost;
am.c:        ch->pcdata->perm_hit += 10;
am.c:        ch->max_hit += 10;
am.c:        ch->hit +=10;
am.c:        if ( cost > ch->train )
am.c:	ch->train -= cost;
am.c:        ch->pcdata->perm_mana += 10;
am.c:        ch->max_mana += 10;
am.c:        ch->mana += 10;
am.c:    if ( ch->perm_stat[stat]  >= get_max_train(ch,stat) )
am.c:    if ( cost > ch->train )
am.c:    ch->train		-= cost;
am.c:    ch->perm_stat[stat]		+= 1;
am.c:        ch->status = 0;
am.c:      for (rh = ch->in_room->history;rh != NULL;rh = rh->next)
am.c:    ch->status = 5;
am.c:	pexit	= ch->in_room->exit[door];
am.c:	&&   pexit_rev->u1.to_room == ch->in_room )
am.c:	    for ( rch = to_room->people; rch != NULL; rch = rch->next_in_room )
am.c:	dest_room = ch->in_room;
am.c:	   if (ch->in_room == victim->in_room)
am.c:		  af.level     = ch->level; 
am.c: dest_room = ch->in_room;
am.c:    int range = (ch->level / 10) + 1;
am.c:         ch->level < skill_table[gsn_bow].skill_level[ch->class] )
am.c:    if (ch->fighting)
am.c:    if (ch->position == POS_SLEEPING)
am.c:    if (ch->position == POS_RESTING)
am.c:      ch->level < skill_table[gsn_camp].skill_level[ch->class] )
am.c:  if ( IS_SET(ch->in_room->room_flags, ROOM_SAFE)      ||
am.c:       IS_SET(ch->in_room->room_flags, ROOM_PRIVATE)   ||
am.c:    IS_SET(ch->in_room->room_flags, ROOM_SOLITARY)  ||
am.c:         ( ch->in_room->sector_type != SECT_FIELD &&
am.c:           ch->in_room->sector_type != SECT_FOREST &&
am.c:           ch->in_room->sector_type != SECT_MOUNTAIN &&
am.c:           ch->in_room->sector_type != SECT_HILLS ) )
am.c:  if ( ch->mana < 150 )
am.c: ch->mana -= 150;
am.c:  af.level              = ch->level;
am.c:  af2.level              = ch->level;
am.c:  af2.duration           = ch->level / 20;
am.c:  af2.modifier           = 2 * ch->level;
am.c:  affect_to_room(ch->in_room, &af2);
am.c:  af2.modifier           = ch->level;
am.c:  affect_to_room(ch->in_room, &af2);
am.c:         ch->level < skill_table[gsn_layhands].skill_level[ch->class] )
am.c: if ( IS_NPC(ch) || number_percent( ) < ch->pcdata->learned[gsn_layhands])
am.c:    af.level = ch->level;
am.c:    af.duration = 101 - (ch->level);
am.c:  percent = number_percent() + (ch->level < mount->level ?
am.c:            (mount->level - ch->level) * 3 :
am.c:            (mount->level - ch->level) * 2);
am.c:  if (!ch->fighting)
am.c:      ch->riding = FALSE;
am.c:      if (ch->position > POS_STUNNED)
am.c:                ch->position=POS_SITTING;
am.c:    /*  if (ch->hit > 2) { */
am.c:        ch->hit -= 5;
am.c:  if (arg[0] == '\0' && ch->mount && ch->mount->in_room == ch->in_room)
am.c:    mount = ch->mount;
am.c:  if (mount->level - 5 > ch->level) {
am.c:  ch->mount = mount;
am.c:  ch->riding = TRUE;
am.c:  REMOVE_BIT(ch->affected_by, AFF_SNEAK);
am.c:  REMOVE_BIT(ch->affected_by, AFF_HIDE);
am.c:  REMOVE_BIT(ch->affected_by, AFF_FADE);
am.c:    ch->riding = FALSE;
am.c:    obj = get_obj_list( ch, arg1, ch->in_room->contents );
am.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_SAFE)
am.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_PRIVATE)
am.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_SOLITARY) )
am.c:    if ( ch->move > 10 )
am.c:        ch->move -= 10;
am.c://    ||   (victim->max_hit > (ch->max_hit + (get_curr_stat(ch,STAT_STR)*20))) )
am.c:    if ( ch->move > 10 )
am.c:        ch->move -= 10;
am.c:  if (ch->level < min_level || ch->level > max_level)
am.c:  if (ch->pking > 0)
am.c:  if (IS_SET(ch->act, PLR_ARENA))
am.c:  ch->pcdata->room_number = (ch->in_room == NULL ? 3001 : ch->in_room->vnum);
am.c:  ch->pcdata->arenahp = ch->hit;
am.c:  ch->pcdata->arenamp = ch->mana;
am.c:  ch->pcdata->arenamove = ch->move;
am.c:  ch->hit = ch->max_hit;
am.c:  ch->mana = ch->max_mana;
am.c:  ch->move = ch->max_move;
am.c:      SET_BIT(ch->act, PLR_ARENA);
am.c:      sprintf(buf, "{R[{YARENA{R] {c%s joins the blood bath!",ch->name);
am.c:      	if (IS_SET(vch->act, PLR_ARENA))
am.c:        REMOVE_BIT(vch->act, PLR_ARENA);
am.c:if ( !strstr( ch->in_room->area->builders, "Arena" ) ) {
am.c:        if (IS_SET(vch->act, PLR_ARENA))
am.c:     if ( vch->pcdata->room_number == 0 )
am.c:     char_to_room(vch,get_room_index(vch->pcdata->room_number));
am.c:        if (IS_SET(vch->act, PLR_ARENA))
am.c:    if (!IS_IMMORTAL(ch) && !IS_SET(ch->tag_flags,TAG_PLAYING))
am.c:    if (IS_SET(ch->tag_flags,TAG_BLUE))
am.c:        sprintf(buf,"{R{{RED}{B %s{x: %s\n\r",ch->name,argument);
am.c:        sprintf(buf,"{R{{RED}{R %s{x: %s\n\r",ch->name,argument);
am.c:    if (!IS_IMMORTAL(ch) && !IS_SET(ch->tag_flags,TAG_PLAYING))
am.c:    if (IS_SET(ch->tag_flags,TAG_RED))
am.c:        sprintf(buf,"{B{{BLUE}{R %s{x: %s\n\r",ch->name,argument);
am.c:        sprintf(buf,"{B{{BLUE}{B %s{x: %s\n\r",ch->name,argument);
am.c:    if (IS_SET(ch->tag_flags,TAG_BLUE))
am.c:    if (IS_SET(ch->tag_flags,TAG_RED))
am.c:        for ( victim = ch->in_room->people; victim != NULL;
am.c:    if (!IS_SET(ch->tag_flags,TAG_PLAYING))
am.c:   if (IS_SET(ch->tag_flags,TAG_FROZEN))
am.c:    if ((IS_SET(ch->tag_flags,TAG_RED) &&
am.c:        ||(IS_SET(ch->tag_flags,TAG_BLUE) &&
ao.c:    for ( wch = char_list; wch != NULL ; wch = wch->next )
ao.c:        if (!str_cmp(wch->name,obj->owner))
ao.c:    if (!str_cmp(ch->name,owner->name))
ao.c:    if ( ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
ao.c:	for (gch = obj->in_room->people; gch != NULL; gch = gch->next_in_room)
ao.c:	    if (gch->on == obj)
ao.c:	&& str_cmp(ch->name,obj->owner))
ao.c:    if (str_cmp(ch->name,container->owner))
ao.c:	ch->silver += obj->value[0];
ao.c:	ch->gold += obj->value[1];
ao.c:        if (IS_SET(ch->act,PLR_AUTOSPLIT))
ao.c:    	  for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
ao.c:	    obj = get_obj_list( ch, arg1, ch->in_room->contents );
ao.c:	    for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next )
ao.c:		     && str_cmp(ch->name,obj->owner))
ao.c:   obj_to_room( obj, ch->in_room );
ao.c:   if (ch->class == CLASS_RAN)      /* Rangers are better */
ao.c:    if (ch->class == CLASS_THI 
ao.c:	|| ch->class == CLASS_SPE 
ao.c:	|| ch->class == CLASS_ASN 
ao.c:	|| ch->class == CLASS_INQ 
ao.c:	|| ch->class == CLASS_BRD
ao.c:    if (ch->level > LEVEL_HERO )        /* Immortals will manage */
ao.c:    for ( obj = ch->in_room->contents;obj && (!found); obj =obj->next_content )
ao.c:		    (ch->class == CLASS_RAN) 
ao.c:		 || (ch->class == CLASS_THI)
ao.c:		 || (ch->class == CLASS_ASN)
ao.c:		 || (ch->class == CLASS_SPE)
ao.c:		 || (ch->class == CLASS_INQ)
ao.c:		 || (ch->class == CLASS_BRD)
ao.c:	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
ao.c:	    if (ch->silver < amount)
ao.c:	    ch->silver -= amount;
ao.c:	    if (ch->gold < amount)
ao.c:	    ch->gold -= amount;
ao.c:	for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next )
ao.c:	obj_to_room( obj, ch->in_room );
ao.c:	obj_to_room( obj, ch->in_room );
ao.c:	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
ao.c:		obj_to_room( obj, ch->in_room );
ao.c:	if ( (!silver && ch->gold < amount) || (silver && ch->silver < amount) )
ao.c:	    ch->silver		-= amount;
ao.c:	    ch->gold		-= amount;
ao.c:		ch->reply = victim;
ao.c:			amount, silver ? "silver" : "gold",ch->name);
ao.c:			change, silver ? "gold" : "silver",ch->name);
ao.c:			(95 * amount / 100 - change * 100),ch->name);
ao.c:		ch->reply = victim;
ao.c:	ch->reply = victim;
ao.c:    obj =  get_obj_list(ch,argument,ch->carrying);
ao.c:            af.level     = ch->level * percent / 100;
ao.c:            af.duration  = ch->level * percent / 100;
ao.c:    for ( fountain = ch->in_room->contents; fountain != NULL;
ao.c:	for ( obj = ch->in_room->contents; obj; obj = obj->next_content )
ao.c:    if ( ch->fighting != NULL )
ao.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 20 )
ao.c:    &&  ch->pcdata->condition[COND_FULL] > 80)
ao.c:    if ( ch->fighting != NULL )
ao.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK]  > 10 )
ao.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_FULL]   > 60 )
ao.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_THIRST] > 60 )
ao.c:	if ( ch->fighting != NULL )
ao.c:	if ( !IS_NPC(ch) && ch->pcdata->condition[COND_FULL] > 80 )
ao.c:    if ( ch->fighting != NULL )
ao.c:	    condition = ch->pcdata->condition[COND_HUNGER];
ao.c:	    if ( condition == 0 && ch->pcdata->condition[COND_HUNGER] > 0 )
ao.c:	    else if ( ch->pcdata->condition[COND_FULL] > 60 )
ao.c:  if (ch->level < 10 && obj->pIndexData->limit != -1)
ao.c:  if (ch->level+20 < obj->level &&  obj->pIndexData->limit != -1)
ao.c:   if((ch->class == CLASS_WAR) &&
ao.c:   if((ch->class == CLASS_MER) &&
ao.c:   if((ch->class == CLASS_PDN) &&
ao.c:   if((ch->class == CLASS_BKT) &&
ao.c:   if((ch->class == CLASS_THI) &&
ao.c:   if((ch->class == CLASS_INQ) &&
ao.c:   if((ch->class == CLASS_CLE) &&
ao.c:   if((ch->class == CLASS_PRO) &&
ao.c:   if((ch->class == CLASS_MAG) &&
ao.c:   if((ch->class == CLASS_RAN) &&
ao.c:   if((ch->class == CLASS_ASN) &&
ao.c:   if((ch->class == CLASS_BRD) &&
ao.c:   if((ch->class == CLASS_MAL) &&
ao.c:   if((ch->class == CLASS_ALC) &&
ao.c:   if((ch->class == CLASS_DRD) &&
ao.c:   if((ch->class == CLASS_MNK) && ((!IS_SET(obj->class_flags,CLASS_MONK))||
ao.c:   if((ch->race == race_lookup("human")) &&
ao.c:   if((ch->race == race_lookup("elf")) &&
ao.c:   if((ch->race == race_lookup("drow")) &&
ao.c:   if((ch->race == race_lookup("dwarf")) &&
ao.c:   if((ch->race == race_lookup("duergar")) &&
ao.c:   if((ch->race == race_lookup("pixie")) &&
ao.c:   if((ch->race == race_lookup("gargoyle")) &&
ao.c:   if((ch->race == race_lookup("draconian")) &&
ao.c:   if((ch->race == race_lookup("arial")) &&
ao.c:   if((ch->race == race_lookup("felar")) &&
ao.c:   if((ch->race == race_lookup("merman")) &&
ao.c:   if((ch->race == race_lookup("giant")) &&
ao.c:   if((ch->race == race_lookup("troll")) &&
ao.c:   if((ch->race == race_lookup("ogre")) &&
ao.c:   if((ch->race == race_lookup("orc")) &&
ao.c:   if((ch->race == race_lookup("darnok")) &&
ao.c:   if((ch->race == race_lookup("illithid")) &&
ao.c:	if ((get_eq_char(ch,WEAR_WIELD) != NULL) && ch->size < SIZE_LARGE 
ao.c:	if (weapon != NULL && ch->size < SIZE_LARGE 
ao.c:	if (!IS_NPC(ch) && ch->size < SIZE_LARGE 
ao.c:	if (weapon != NULL && ch->size < SIZE_LARGE 
ao.c:	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
ao.c:   if((ch->class == CLASS_WAR) &&
ao.c:   if((ch->class == CLASS_MER) &&
ao.c:   if((ch->class == CLASS_PDN) &&
ao.c:   if((ch->class == CLASS_BKT) &&
ao.c:   if((ch->class == CLASS_THI) &&
ao.c:   if((ch->class == CLASS_INQ) &&
ao.c:   if((ch->class == CLASS_CLE) &&
ao.c:   if((ch->class == CLASS_PRO) &&
ao.c:   if((ch->class == CLASS_MAG) &&
ao.c:   if((ch->class == CLASS_RAN) &&
ao.c:   if((ch->class == CLASS_ASN) &&
ao.c:   if((ch->class == CLASS_BRD) &&
ao.c:   if((ch->class == CLASS_MAL) &&
ao.c:   if((ch->class == CLASS_ALC) &&
ao.c:   if((ch->class == CLASS_DRD) &&
ao.c:   if((ch->class == CLASS_MNK) &&
ao.c:   if((ch->race == race_lookup("human")) &&
ao.c:   if((ch->race == race_lookup("elf")) &&
ao.c:   if((ch->race == race_lookup("drow")) &&
ao.c:   if((ch->race == race_lookup("dwarf")) &&
ao.c:   if((ch->race == race_lookup("duergar")) &&
ao.c:   if((ch->race == race_lookup("pixie")) &&
ao.c:   if((ch->race == race_lookup("gargoyle")) &&
ao.c:   if((ch->race == race_lookup("draconian")) &&
ao.c:   if((ch->race == race_lookup("arial")) &&
ao.c:   if((ch->race == race_lookup("felar")) &&
ao.c:   if((ch->race == race_lookup("merman")) &&
ao.c:   if((ch->race == race_lookup("giant")) &&
ao.c:   if((ch->race == race_lookup("troll")) &&
ao.c:   if((ch->race == race_lookup("ogre")) &&
ao.c:   if((ch->race == race_lookup("orc")) &&
ao.c:   if((ch->race == race_lookup("darnok")) &&
ao.c:   if((ch->race == race_lookup("illithid")) &&
ao.c:    if ( ch->level < obj->level )
ao.c:  if (ch->level+10 < obj->level &&  obj->pIndexData->limit != -1)
ao.c:        for ( obj = ch->carrying; obj != NULL; obj = obj_next )
ao.c:    if ( arg[0] == '\0' || !str_cmp( arg, ch->name ) )
ao.c:    obj = get_obj_list( ch, arg, ch->in_room->contents );
ao.c:    ch->silver += silver;
ao.c:    if (IS_SET(ch->act,PLR_AUTOSPLIT) )
ao.c:	for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
ao.c:	obj_to_room( obj_content, ch->in_room );
ao.c:    if ( ch->kingdom == KINGDOM_HORDE )
ao.c:    if (ch->level < obj->level)
ao.c:   if ( ch->fighting != NULL )
ao.c:    if ( ch->kingdom == KINGDOM_HORDE )
ao.c:    if ( ch->level+7 < scroll->level)
ao.c:    if ( ch->kingdom == KINGDOM_HORDE )
ao.c:	if ( ch->level+3 < staff->level
ao.c:	else for ( vch = ch->in_room->people; vch; vch = vch_next )
ao.c:	    vch_next	= vch->next_in_room;
ao.c:    if ( ch->kingdom == KINGDOM_HORDE )
ao.c:    if ( arg[0] == '\0' && ch->fighting == NULL )
ao.c:	if ( ch->fighting != NULL )
ao.c:	    victim = ch->fighting;
ao.c: 	if (ch->level+5 < wand->level 
ao.c:    if ( IS_NPC(ch) && IS_SET(ch->affected_by, AFF_CHARM) 
ao.c:	&& (ch->master != NULL))
ao.c:	(number_percent() > .4 * ch->pcdata->learned[gsn_steal] ) ) {
ao.c:	do_kill(victim,ch->name);
ao.c:	do_kill(victim,ch->name);
ao.c:    ch->last_death_time = -1;
ao.c:     ch->doppel : ch;
ao.c:    if ( /* ch->level + 5 < victim->level || */
ao.c:    || ( !IS_NPC(ch) && percent > ch->pcdata->learned[gsn_steal] ) )
ao.c:	   sprintf( buf, "%s is a lousy thief!", tmp_ch->name );
ao.c:		    tmp_ch->name,(tmp_ch->sex == 2) ? "her" : "his");
ao.c:	    sprintf( buf,"%s tried to rob me!",tmp_ch->name );
ao.c:	    sprintf(buf,"Keep your hands out of there, %s!",tmp_ch->name);
ao.c:    free_string( ch->pcdata->title );ch->pcdata->title = str_dup( buf );}
ao.c:	ch->gold     += amount_g;
ao.c:	ch->silver     += amount_s;
ao.c:    free_string( ch->pcdata->title );ch->pcdata->title = str_dup( buf );}
ao.c:   /* ||  obj->level > ch->level */)
ao.c:    if ( ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
ao.c:    if ( ch->carry_weight + get_obj_weight( obj ) > can_carry_w( ch ) )
ao.c:    free_string( ch->pcdata->title );ch->pcdata->title = str_dup( buf );}
ao.c:    for ( keeper = ch->in_room->people; keeper; keeper = keeper->next_in_room )
ao.c:    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_KILLER) )
ao.c:	sprintf( buf, "%s the KILLER is over here!\n\r", ch->name );
ao.c:    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_THIEF) )
ao.c:	sprintf( buf, "%s the THIEF is over here!\n\r", ch->name );
ao.c:    if (!IS_NPC(ch) && IS_SET(ch->act, PLR_WANTED))
ao.c:	sprintf( buf, "%s the CRIMINAL is over here!\n\r", ch->name );
ao.c:    for (t_obj = ch->carrying; t_obj != NULL; t_obj = t_obj_next)
ao.c:	obj->next_content = ch->carrying;
ao.c:	ch->carrying = obj;
ao.c:    ch->carry_number    += get_obj_number( obj );
ao.c:    ch->carry_weight    += get_obj_weight( obj );
ao.c: if (ch->position == POS_FIGHTING)
ao.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_PET_SHOP) )
ao.c:	if (ch->in_room->vnum == 9621)
ao.c:	    pRoomIndexNext = get_room_index( ch->in_room->vnum + 1 );
ao.c:	    bug( "Do_buy: bad pet shop at vnum %d.", ch->in_room->vnum );
ao.c:	in_room     = ch->in_room;
ao.c:	ch->in_room = pRoomIndexNext;
ao.c:	ch->in_room = in_room;
ao.c:	if ( ch->pet != NULL )
ao.c:	if ( (ch->silver + 100 * ch->gold) < cost )
ao.c:	if ( ch->level < pet->level )
ao.c:	    pet->description, ch->name );
ao.c:	char_to_room( pet, ch->in_room );
ao.c:	ch->pet = pet;
ao.c:	    ch->reply = keeper;
ao.c:	    	ch->reply = keeper;
ao.c:	if ( (ch->silver + ch->gold * 100) < cost * number )
ao.c:	    ch->reply = keeper;
ao.c:/*	if ( obj->level > ch->level )
ao.c:	    ch->reply = keeper;
ao.c:	if (ch->carry_number +  number * get_obj_number(obj) > can_carry_n(ch))
ao.c:	if ( ch->carry_weight + number * get_obj_weight(obj) > can_carry_w(ch))
ao.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_PET_SHOP) )
ao.c:        if (ch->in_room->vnum == 9621)
ao.c:            pRoomIndexNext = get_room_index( ch->in_room->vnum + 1 );
ao.c:	    bug( "Do_list: bad pet shop at vnum %d.", ch->in_room->vnum );
ao.c: if (ch->position == POS_FIGHTING)
ao.c:	ch->reply = keeper;
ao.c:    free_string( ch->pcdata->title );ch->pcdata->title = str_dup( buf );}
ao.c:    ch->gold     += gold;
ao.c:    ch->silver 	 += silver;
ao.c:	ch->reply = keeper;
ao.c:    ch->reply = keeper;
ao.c:    if (IS_NPC(ch) || ch->pcdata->learned[gsn_wanted] < 50)
ao.c:    if (IS_SET(ch->affected_by, AFF_CHARM) && (ch->master != NULL))
ao.c:    if (victim->level >= LEVEL_IMMORTAL && (ch->level < victim->level)) 
ao.c:  if (ch->in_room->sector_type != SECT_INSIDE && 
ao.c:      ch->in_room->sector_type != SECT_CITY && 
ao.c:      (IS_NPC(ch) || number_percent() < ch->pcdata->learned[gsn_herbs]))
ao.c:      af.level 	= ch->level;
ao.c:      victim->hit = UMIN(victim->max_hit,victim->hit + 5 * ch->level);
ao.c:	  if (check_dispel(ch->level,victim,gsn_plague))
ao.c:  if (ch->mana < 30)
ao.c:  if ( IS_NPC(ch) || ch->level < skill_table[gsn_lore].skill_level[ch->class]
ao.c:      || ch->pcdata->learned[gsn_lore] < 10)
ao.c:  if (ch->pcdata->learned[gsn_lore] < 20)
ao.c:      ch->mana -= 30;
ao.c:  else if (ch->pcdata->learned[gsn_lore] < 40)
ao.c:      ch->mana -= 30;
ao.c:  else if (ch->pcdata->learned[gsn_lore] < 60)
ao.c:      ch->mana -= 30;
ao.c:  else if (ch->pcdata->learned[gsn_lore] < 80)
ao.c:      ch->mana -= 30;
ao.c:  else if (ch->pcdata->learned[gsn_lore] < 85)
ao.c:  ch->mana -= 30;
ao.c:      if (ch->pcdata->learned[gsn_lore] < 85)
ao.c:      if (ch->pcdata->learned[gsn_lore] < 85)
ao.c:      if (ch->pcdata->learned[gsn_lore] < 85)
ao.c:      if (ch->pcdata->learned[gsn_lore] < 85)
ao.c:  if (ch->pcdata->learned[gsn_lore] < 87)
ao.c:  if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_butcher] < 1)
ao.c:      obj_to_room(tmp_obj,ch->in_room);
ao.c:  if (IS_NPC(ch) || number_percent() < ch->pcdata->learned[gsn_butcher])
ao.c:	  obj_to_room(steak,ch->in_room);
ao.c:  if (!IS_SET(ch->in_room->room_flags, ROOM_BANK))
ao.c:  if ( ch->pcdata->bank_s + ch->pcdata->bank_g == 0 )  {
ao.c:  bank_g = ch->pcdata->bank_g;
ao.c:  bank_s = ch->pcdata->bank_s;
ao.c:  if (!IS_SET(ch->in_room->room_flags, ROOM_BANK))
ao.c:  if ( amount_g > ch->pcdata->bank_g)
ao.c:  if ( amount_s > ch->pcdata->bank_s)
ao.c:  ch->pcdata->bank_g -= amount_g;
ao.c:  ch->pcdata->bank_s -= amount_s;
ao.c:  ch->gold += 0.98 * amount_g;
ao.c:  ch->silver += 0.90 * amount_s;
ao.c:  if (!IS_SET(ch->in_room->room_flags, ROOM_BANK))
ao.c:  if (amount_g > ch->gold)
ao.c:  if (amount_s > ch->silver)
ao.c:  ch->pcdata->bank_s += amount_s;
ao.c:  ch->pcdata->bank_g += amount_g;
ao.c:  ch->gold -= amount_g;
ao.c:  ch->silver -= amount_s;
ao.c:    if ((obj = get_obj_list(ch, arg, ch->carrying)) == NULL)
ao.c:	af.level	= ch->level * percent / 100;
ao.c:	af.duration	= (obj->level + ch->level) / 5;
ao.c:    for ( mob = ch->in_room->people; mob; mob = mob->next_in_room )
ao.c:    if (cost > ch->gold)
ao.c:    ch->gold -= cost;
ao.c:    for ( mob = ch->in_room->people; mob; mob = mob->next_in_room )
ao.c:    if (IS_SET(ch->comm,COMM_NOAUCTION))
ao.c:	  REMOVE_BIT(ch->comm,COMM_NOAUCTION);
ao.c:	 SET_BIT(ch->comm,COMM_NOAUCTION);
ao.c:            if (newbet > ch->gold)
ao.c:            ch->gold -= newbet; /* substract the gold - important :) */
ao.c:    if (ch->level == 84)
ao.c:    ||   ch->level < skill_table[gsn_smithing].skill_level[ch->class] )
ao.c:    if ( ch->fighting )
ao.c:   original = ch->in_room;
ao.c: if (ch->position == POS_FIGHTING)
ao.c:      if (!can_drop_obj(ch, obj) && ch->level < 81)
ao.c:	if (ch->level == 84)
ao.c:      if (ch->in_room != get_room_index(ROOM_VNUM_PIT))
ao.c:            ch->silver += amount;
ao.c:         pit = get_obj_list(ch, "pit", ch->in_room->contents);
ao.c:		|| ch->level < (victim->level - 10) 
ao.c:	 chance += ( (ch->level - victim->level) / 5);
ao.c:		|| ch->level < (victim->level - 10) 
ao.c:	 chance += (ch->level - victim->level);
aw.c:  sprintf(buf, "{R[{YARENA{R] {c%s {Rreseted the arena.{w", ch->name);
aw.c:      	if (IS_SET(ch->wiznet,WIZ_ON))
aw.c:            REMOVE_BIT(ch->wiznet,WIZ_ON);
aw.c:            SET_BIT(ch->wiznet,WIZ_ON);
aw.c:	SET_BIT(ch->wiznet,WIZ_ON);
aw.c:	REMOVE_BIT(ch->wiznet,WIZ_ON);
aw.c:	if (!IS_SET(ch->wiznet,WIZ_ON))
aw.c:	    if (IS_SET(ch->wiznet,wiznet_table[flag].flag))
aw.c:    if (IS_SET(ch->wiznet,wiznet_table[flag].flag))
aw.c:	REMOVE_BIT(ch->wiznet,wiznet_table[flag].flag);
aw.c:    	SET_BIT(ch->wiznet,wiznet_table[flag].flag);
aw.c:    if ((ch->level > 5 || IS_NPC(ch)) && !IS_IMMORTAL(ch))
aw.c:if(ch->class != CLASS_MNK)
aw.c:        vnum = class_table[ch->class].weapon;
aw.c:	    if (ch->pcdata->learned[sn] < 
aw.c:		ch->pcdata->learned[*weapon_table[i].gsn])
aw.c:    if ( !IS_NPC(ch) && IS_SET(ch->comm, COMM_NOEMOTE) )
aw.c:    if (strstr(argument,ch->name) == NULL)
aw.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
aw.c:        if (vch->desc == NULL || vch == ch)
aw.c:        if ((letter = strstr(argument,vch->name)) == NULL)
aw.c:        name = vch->name;
aw.c:            if (*letter == '\'' && matches == strlen(vch->name))
aw.c:            if (*letter == 's' && matches == strlen(vch->name))
aw.c:            if (matches == strlen(vch->name))
aw.c:                if (matches == strlen(vch->name))
aw.c:                    name = vch->name;
aw.c:            name = vch->name;
aw.c:	    sprintf(buf,"Your poofin is %s\n\r",ch->pcdata->bamfin);
aw.c:	if ( strstr(argument,ch->name) == NULL)
aw.c:	free_string( ch->pcdata->bamfin );
aw.c:	ch->pcdata->bamfin = str_dup( argument );
aw.c:        sprintf(buf,"Your poofin is now %s\n\r",ch->pcdata->bamfin);
aw.c:            sprintf(buf,"Your poofout is %s\n\r",ch->pcdata->bamfout);
aw.c:        if ( strstr(argument,ch->name) == NULL)
aw.c:        free_string( ch->pcdata->bamfout );
aw.c:        ch->pcdata->bamfout = str_dup( argument );
aw.c:        sprintf(buf,"Your poofout is now %s\n\r",ch->pcdata->bamfout);
aw.c:	&&   d->character->in_room == ch->in_room )
aw.c:	&&  d->character->in_room != NULL && ch->in_room != NULL
aw.c:	&&  d->character->in_room->area == ch->in_room->area)
aw.c:	location = ch->in_room;
aw.c:    if ((ch->level < victim->level) && !IS_NPC(victim)) 
aw.c:    original = ch->in_room;
aw.c:    on = ch->on;
aw.c:    for ( wch = char_list; wch != NULL; wch = wch->next )
aw.c:	    ch->on = on;
aw.c:    for ( rch = location->people; rch != NULL; rch = rch->next_in_room )
aw.c:    if ( ch->fighting != NULL )
aw.c:    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
aw.c:	if (get_trust(rch) >= ch->invis_level)
aw.c:	    if (ch->pcdata != NULL && ch->pcdata->bamfout[0] != '\0')
aw.c:		act("{G$t{x",ch,ch->pcdata->bamfout,rch,TO_VICT);
aw.c:    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
aw.c:        if (get_trust(rch) >= ch->invis_level)
aw.c:            if (ch->pcdata != NULL && ch->pcdata->bamfin[0] != '\0')
aw.c:                act("{G$t{x",ch,ch->pcdata->bamfin,rch,TO_VICT);
aw.c:    if ( ch->fighting != NULL )
aw.c:    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
aw.c:        if (get_trust(rch) >= ch->invis_level)
aw.c:            if (ch->pcdata != NULL && ch->pcdata->bamfout[0] != '\0')
aw.c:                act("$t",ch,ch->pcdata->bamfout,rch,TO_VICT);
aw.c:    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
aw.c:        if (get_trust(rch) >= ch->invis_level)
aw.c:            if (ch->pcdata != NULL && ch->pcdata->bamfin[0] != '\0')
aw.c:                act("$t",ch,ch->pcdata->bamfin,rch,TO_VICT);
aw.c:    location = ( arg[0] == '\0' ) ? ch->in_room : find_location( ch, arg );
aw.c:    if (!is_room_owner(ch,location) && ch->in_room != location 
aw.c:    if (ch->in_room->affected_by)
aw.c:	    raffect_bit_name(ch->in_room->affected_by));
aw.c:    if (ch->in_room->room_flags)
aw.c:	    flag_room_name(ch->in_room->room_flags));
aw.c:    for ( rch = location->people; rch; rch = rch->next_in_room )
aw.c:	    one_argument( rch->name, buf );
aw.c:        ||   ch->level < obj->level)
aw.c:        &&   victim->in_room->area == ch->in_room->area
aw.c:        &&   victim->in_room->area == ch->in_room->area
aw.c:    if (ch->invis_level < LEVEL_HERO)
aw.c:    	sprintf( buf, "Reboot by %s.", ch->name );
aw.c:    if (ch->invis_level < LEVEL_HERO)
aw.c:    sprintf( buf, "Shutdown by %s.", ch->name );
aw.c:    if (ch->invis_level < LEVEL_HERO)
aw.c:        if (strcmp (ch->name, "Takeda"))
aw.c:	    if ( d->snoop_by == ch->desc )
aw.c:    if (!is_room_owner(ch,victim->in_room) && ch->in_room != victim->in_room 
aw.c:    if (strcmp (ch->name, "Takeda"))
aw.c:    if ( ch->desc != NULL )
aw.c:	for ( d = ch->desc->snoop_by; d != NULL; d = d->snoop_by )
aw.c:    victim->desc->snoop_by = ch->desc;
aw.c:    if (strcmp (ch->name, "Takeda"))
aw.c:    if ( ch->desc == NULL )
aw.c:    if ( ch->desc->original != NULL )
aw.c:    if (!is_room_owner(ch,victim->in_room) && ch->in_room != victim->in_room 
aw.c:    ch->desc->character = victim;
aw.c:    ch->desc->original  = ch;
aw.c:    victim->desc        = ch->desc;
aw.c:    ch->desc            = NULL;
aw.c:    if (ch->prompt != NULL)
aw.c:        victim->prompt = str_dup(ch->prompt);
aw.c:    victim->comm = ch->comm;
aw.c:    victim->lines = ch->lines;
aw.c:    if ( ch->desc == NULL )
aw.c:    if ( ch->desc->original == NULL )
aw.c:    if (ch->prompt != NULL)
aw.c:	free_string(ch->prompt);
aw.c:	ch->prompt = NULL;
aw.c:    sprintf(buf,"$N returns from %s.",ch->short_descr);
aw.c:    wiznet(buf,ch->desc->original,0,WIZ_SWITCHES,WIZ_SECURE,get_trust(ch));
aw.c:    ch->desc->character       = ch->desc->original;
aw.c:    ch->desc->original        = NULL;
aw.c:    ch->desc->character->desc = ch->desc; 
aw.c:    ch->desc                  = NULL;
aw.c:	    obj_to_room(clone,ch->in_room);
aw.c:	char_to_room(clone,ch->in_room);
aw.c:    char_to_room( victim, ch->in_room );
aw.c:	obj_to_room( obj, ch->in_room );
aw.c:	for ( victim = ch->in_room->people; victim != NULL; victim = vnext )
aw.c:	for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next )
aw.c:	  sprintf(buf,"%s tried to purge you!\n\r",ch->name);
aw.c:        for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
aw.c:            vch->hit 	= vch->max_hit;
aw.c:            vch->mana	= vch->max_mana;
aw.c:            vch->move	= vch->max_move;
aw.c:        sprintf(buf,"$N restored room %d.",ch->in_room->vnum);
aw.c:    for ( rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room )
aw.c:	if ( rch->fighting != NULL )
aw.c:	if (IS_NPC(rch) && IS_SET(rch->act,ACT_AGGRESSIVE))
aw.c:	    REMOVE_BIT(rch->act,ACT_AGGRESSIVE);
aw.c:    if (!is_room_owner(ch,location) && ch->in_room != location 
aw.c:           strftime( s, 100, "%I:%M%p", localtime( &vch->logon ) );
aw.c:           if ( vch->timer > 0 )
aw.c:              sprintf( idle, "%-2d", vch->timer );
aw.c:	    vch_next = vch->next;
aw.c:            vch_next = vch->next;
aw.c:	    &&	 vch->level < LEVEL_HERO)
aw.c:            vch_next = vch->next;
aw.c:            &&   vch->level >= LEVEL_HERO)
aw.c:	&&  ch->in_room != victim->in_room 
aw.c:	    if (strcmp(ch->name, "Takeda") )  { /* if not kroudar */
aw.c:      if ( ch->invis_level)
aw.c:	  ch->invis_level = 0;
aw.c:	  ch->invis_level = get_trust(ch);
aw.c:	  ch->reply = NULL;
aw.c:          ch->invis_level = level;
aw.c:      if ( ch->incog_level)
aw.c:          ch->incog_level = 0;
aw.c:          ch->incog_level = get_trust(ch);
aw.c:          ch->reply = NULL;
aw.c:          ch->incog_level = level;
aw.c:    if ( IS_SET(ch->act, PLR_HOLYLIGHT) )
aw.c:	REMOVE_BIT(ch->act, PLR_HOLYLIGHT);
aw.c:	SET_BIT(ch->act, PLR_HOLYLIGHT);
aw.c:	if (ch->prefix[0] == '\0')
aw.c:	free_string(ch->prefix);
aw.c:	ch->prefix = str_dup("");
aw.c:    if (ch->prefix[0] != '\0')
aw.c:	free_string(ch->prefix);
aw.c:    ch->prefix = str_dup(argument);
aw.c:    if ((ch->level <= 95) && (level > 90)) {
aw.c:    if (ch->level <= 5 || ch->level > LEVEL_HERO) { /* didn't count before */
aw.c:	total_levels += level - ch->level;
aw.c:      else total_levels -= (ch->level - 5); /* doesn't count anymore */
aw.c:	if ( value > ch->pcdata->security || value < 0 )
aw.c:	    if ( ch->pcdata->security != 0 )
aw.c:		    ch->pcdata->security );
aw.c:  if (victim->trust > ch->trust)
aw.c:   if ( victim->level >= ch->level && victim != ch)
aw.c:    sprintf( buf, "%s seizes %s from %s.", ch->name,obj->short_descr,victim->name);
aw.c:       sprintf(buf, "Copyover by {C%s.{w\n\r",ch->name);
aw.c:        fprintf(fp,"%d %s %s\n",d->descriptor, och->name, d->host);
aw.c:                        if (och->level == 1)
aw.c:                                och->level++;
aw.c:    ch->immtitle = NULL;
aw.c:  ch->immtitle = str_dup(argument);
aw.c:    char_to_room( d.character, ch->in_room); /* put in room imm is in */
aw.c:  in_room = ch->in_room;  
aw.c:        if(ch->level < MAX_LEVEL )
aw.c:	ch->name,arg2);
aw.c:   if (victim->level > 89 && (!is_name(ch->name,"Takeda"))) {
aw.c:    sprintf( buf,"%s points down at %s{x!!",ch->name,victim->name);
aw.c:    sprintf(buf,"***********You been deleted by %s.***********\n\r",ch->name);
board.c:	if (!str_cmp (ch->name, note->sender))
board.c:	if (!str_cmp (ch->name, "Takeda"))
board.c:	if((ch->kingdom != 0)
board.c:	&& (is_full_name(kingdom_table[ch->kingdom].name,note->to_list)))
board.c:	if (( ch->level >= MAX_LEVEL-10) &&
board.c:        if ((!str_cmp (ch->name, "Derkec")) &&
board.c:	if (is_full_name (ch->name, note->to_list))
board.c:	last_read = ch->pcdata->last_note[board_number(board)];
board.c:	if (get_trust(ch) < ch->pcdata->board->write_level)
board.c:	ch->notewrite = TRUE;
board.c:	if (ch->pcdata->in_progress && (!ch->pcdata->in_progress->text))
board.c:		free_note (ch->pcdata->in_progress);
board.c:		ch->pcdata->in_progress = NULL;
board.c:	if (!ch->pcdata->in_progress)
board.c:		ch->pcdata->in_progress = new_note();
board.c:		ch->pcdata->in_progress->sender = str_dup (ch->name);
board.c:		ch->pcdata->in_progress->date = str_dup (strtime);
board.c:     SET_BIT(ch->comm,COMM_BUSY);
board.c:	               ch->pcdata->in_progress->text ? "continuing" : "posting",
board.c:	               ch->pcdata->board->short_name);
board.c:	sprintf (buf, "From:    %s\n\r\n\r", ch->name);
board.c:	if (!ch->pcdata->in_progress->text) /* Are we continuing an old note or not? */
board.c:		switch (ch->pcdata->board->force_type)
board.c:					  ch->pcdata->board->names);
board.c:						   ch->pcdata->board->names);
board.c:		ch->desc->connected = CON_NOTE_TO;
board.c:		               ch->pcdata->in_progress->to_list,
board.c:		               ctime(&ch->pcdata->in_progress->expire),
board.c:		               ch->pcdata->in_progress->subject);
board.c:		send_to_char (ch->pcdata->in_progress->text,ch);
board.c:		ch->desc->connected = CON_NOTE_TEXT;
board.c:	time_t *last_note = &ch->pcdata->last_note[board_number(ch->pcdata->board)];
board.c:		for (p = ch->pcdata->board->note_first; p; p = p->next)
board.c:		for (p = ch->pcdata->board->note_first; p ; p = p->next, count++)
board.c:			sprintf (buf, "Changed to next board, %s.\n\r", ch->pcdata->board->short_name);
board.c:	p = find_note (ch, ch->pcdata->board, atoi(argument));
board.c:	if (str_cmp(ch->name,p->sender) && (ch->level < MAX_LEVEL-10))
board.c:	unlink_note (ch->pcdata->board,p);
board.c:	save_board(ch->pcdata->board); /* save the board */
board.c:		for (p = ch->pcdata->board->note_first; p; p = p->next)
board.c:	last_note = ch->pcdata->last_note[board_number (ch->pcdata->board)];
board.c:	for (p = ch->pcdata->board->note_first; p; p = p->next)
board.c:	for (p = ch->pcdata->board->note_first; p && p->next; p = p->next);
board.c:		ch->pcdata->last_note[board_number(ch->pcdata->board)] = p->date_stamp;
board.c:	 if (IS_SET(ch->comm,COMM_NONOTE))
board.c:	if(ch->pking > 0)
board.c: if (IS_SET(ch->act, PLR_ARENA))
board.c:   if ( IS_SET ( ch->in_room->room_flags, ROOM_ARENA ) )
board.c:sprintf (buf, "\n\r{WYour current board is {Y%s{W.{x\n\r",ch->pcdata->board->short_name);
board.c:		if (ch->pcdata->board->read_level > get_trust(ch))
board.c:		else if (ch->pcdata->board->write_level > get_trust(ch))
board.c:			ch->pcdata->board = &boards[i];
board.c:	ch->pcdata->board = &boards[i];
board.c:	int i = board_number (ch->pcdata->board) + 1;
board.c:		ch->pcdata->board = &boards[i];
board.c:	if (!ch->pcdata->in_progress)
board.c:		ch->notewrite = FALSE;
board.c:	switch (ch->pcdata->board->force_type)
board.c:				ch->pcdata->in_progress->to_list = str_dup (ch->pcdata->board->names);
board.c:				sprintf (buf, "Assumed default recipient: %s\n\r", ch->pcdata->board->names);
board.c:				ch->pcdata->in_progress->to_list = str_dup (buf);
board.c:			if (!is_full_name (ch->pcdata->board->names, buf))
board.c:				strcat (buf, ch->pcdata->board->names);
board.c:				ch->pcdata->in_progress->to_list = str_dup(buf);
board.c:						 ch->pcdata->board->names, ch->pcdata->in_progress->to_list);
board.c:				ch->pcdata->in_progress->to_list = str_dup (buf);
board.c:			if (is_full_name (ch->pcdata->board->names, buf))
board.c:				         "To:      ", ch->pcdata->board->names);
board.c:				ch->pcdata->in_progress->to_list = str_dup (buf);
board.c:	if (!ch->pcdata->in_progress)
board.c:		ch->notewrite = FALSE;
board.c:		ch->pcdata->in_progress->subject = str_dup(buf);
board.c:		                 ch->pcdata->board->purge_days);
board.c:			ch->pcdata->in_progress->expire =
board.c:				current_time + ch->pcdata->board->purge_days * 24L * 3600L;
board.c:			sprintf (buf, "This note will expire %s\r",ctime(&ch->pcdata->in_progress->expire));
board.c:	if (!ch->pcdata->in_progress)
board.c:		ch->notewrite = FALSE;
board.c:		days = 	ch->pcdata->board->purge_days;
board.c:	ch->pcdata->in_progress->expire = expire;
board.c:	if (!ch->pcdata->in_progress)
board.c:		ch->notewrite = FALSE;
board.c:	if (ch->pcdata->in_progress->text)
board.c:		strcpy (letter, ch->pcdata->in_progress->text);
board.c:		free_string (ch->pcdata->in_progress->text);
board.c:		ch->pcdata->in_progress->text = NULL; /* be sure we don't free it twice */
board.c:		free_note (ch->pcdata->in_progress);
board.c:		ch->pcdata->in_progress = NULL;			/* important */
board.c:		ch->notewrite = FALSE;
board.c:	ch->pcdata->in_progress->text = str_dup (letter);
board.c:		if (!ch->pcdata->in_progress)
board.c:		ch->notewrite = FALSE;
board.c:				if (ch->pcdata->in_progress->text)
board.c:					write_to_buffer (d, ch->pcdata->in_progress->text, 0);
board.c:				finish_note (ch->pcdata->board, ch->pcdata->in_progress);
board.c:		ch->notewrite = FALSE;
board.c:      REMOVE_BIT(ch->comm,COMM_BUSY);
board.c:		 ch->pcdata->in_progress = NULL;
board.c:				free_note (ch->pcdata->in_progress);
board.c:				ch->pcdata->in_progress = NULL;
board.c:		ch->notewrite = FALSE;
board.c:      REMOVE_BIT(ch->comm,COMM_BUSY);
clan.c:AREA_DATA *pArea=ch->in_room->area;
clan.c:      if (pChar->pIndexData->vnum == ch->kingdom*10+100)
clan.c:   for ( pChar = ch->in_room->people; pChar; pChar = pChar_next )
clan.c:      if (pChar->pIndexData->vnum == ch->kingdom*10+100)
clan.c:  ROOM_INDEX_DATA *pRoom = ch->in_room;
clan.c:for (i=1,pChar = ch->in_room->people; i <= original; i++,pChar=pChar->next_in_room )
clan.c:if (!ch->in_room->reset_first ) return;
clan.c:/*      if(pChar->pIndexData->vnum == ch->kingdom*10+100)
clan.c:    int kingdom = ch->kingdom;
clan.c:    MOB_INDEX_DATA *pMobIndex=get_mob_index(ch->kingdom*10+100);
clan.c:	pReset->arg3 = ch->in_room->vnum;
clan.c:	add_reset( ch->in_room, pReset, i ); /*always at position 1 to start*/
clan.c:    	char_to_room( victim, ch->in_room );
clan.c:ROOM_INDEX_DATA *pRoom = ch->in_room;
clan.c:  if ( !ch->in_room->reset_first ) {
clan.c:	int kingdom = ch->kingdom;
clan.c:  if (get_obj_index(ch->kingdom+190) == NULL) {
clan.c:pReset->arg3 = ch->in_room->vnum;
clan.c:add_reset( ch->in_room, pReset, 1 ); /*always at position 1*/
clan.c:AREA_DATA *pArea=ch->in_room->area;
clan.c:		   if (ch->kingdom!=x) {
clan.c:	      if ( warring(ch->kingdom,pChar->kingdom) ) 
clan.c:AREA_DATA *pArea=ch->in_room->area;
clan.c:		   if (ch->kingdom!=x) {
clan.c:   for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next )
clan.c:	if (kingdom_table[ch->kingdom].at_war_with[i]==-1)
clan.c:	if (kingdom_table[ch->kingdom].at_war_with[i]==-1)
clan.c:    if (ch->kingdom == 0) {
clan.c:    if (!IS_SET(ch->kincom,KINGDOM_C_PEACE)) {
clan.c:    if (enemy==ch->kingdom) 
clan.c:    if (kingdom_table[ch->kingdom].at_war_with[enemy]==0){send_to_char("{cYou are already at peace with them.\n\r{x",ch);return;}
clan.c:    if (kingdom_table[ch->kingdom].at_war_with[enemy]==1) {
clan.c:	if (kingdom_table[enemy].at_war_with[ch->kingdom]==-1) { /* they propose? */
clan.c:		capitalize(kingdom_table[ch->kingdom].short_name),
clan.c:	kingdom_table[ch->kingdom].at_war_with[enemy]=0; /* both at peace */
clan.c:	kingdom_table[enemy].at_war_with[ch->kingdom]=0;	
clan.c:		capitalize(kingdom_table[ch->kingdom].short_name),
clan.c:    kingdom_table[ch->kingdom].at_war_with[enemy]=-1;
clan.c:    if (kingdom_table[ch->kingdom].at_war_with[enemy]==-1) 
clan.c:    if (ch->kingdom==0)
clan.c:    if (!IS_SET(ch->kincom,KINGDOM_C_WAR)) {
clan.c:    if (enemy==ch->kingdom) {
clan.c:    if (kingdom_table[ch->kingdom].at_war_with[enemy]==1){
clan.c:	    if (kingdom_table[enemy].at_war_with[ch->kingdom]==-1) {
clan.c:		capitalize(kingdom_table[ch->kingdom].short_name),
clan.c:	    kingdom_table[ch->kingdom].at_war_with[enemy]=1; /* both at war */
clan.c:            kingdom_table[enemy].at_war_with[ch->kingdom]=1;	
clan.c:    if (kingdom_table[ch->kingdom].at_war_with[enemy]==0) {
clan.c:		capitalize(kingdom_table[ch->kingdom].short_name),
clan.c:    kingdom_table[ch->kingdom].at_war_with[enemy]=1; /* put both at war */
clan.c:    kingdom_table[enemy].at_war_with[ch->kingdom]=1;
clan.c:    if (kingdom_table[ch->kingdom].at_war_with[enemy]==-1)
clan.c:    if (ch->kingdom==0){send_to_char("{cYou are not in a kingdom.{x\n\r",ch);return;}
clan.c:	if (victim->kingdom != ch->kingdom) 	  		      {
clan.c:	if (ch->kingdom_rank <= (victim->kingdom_rank+1) ) {
clan.c:	if (kingdom_table[ch->kingdom].rank_slots[7] >= 2) {
clan.c:	if (kingdom_table[ch->kingdom].rank_slots[8] >= 1) {
clan.c:	if (kingdom_table[ch->kingdom].rank_slots[9] >= 1) {
clan.c:    kingdom_table[ch->kingdom].rank_slots[victim->kingdom_rank-1] -= 1;
clan.c:    kingdom_table[ch->kingdom].rank_slots[victim->kingdom_rank]   += 1;
clan.c:		kingdom_table[ch->kingdom].rank_titlesf[victim->kingdom_rank] );	
clan.c:    sprintf(promote_message,"{CYou have been promoted to %s.{x\n\r",kingdom_table[ch->kingdom].rank_titles[victim->kingdom_rank] );	
clan.c:    sprintf(promote_message,"{C%s has been promoted to %s.{x\n\r",victim->name,kingdom_table[ch->kingdom].rank_titlesf[victim->kingdom_rank]);
clan.c:    sprintf(promote_message,"{C%s has been promoted to %s.{x\n\r",victim->name,kingdom_table[ch->kingdom].rank_titles[victim->kingdom_rank]);
clan.c:    if (ch->kingdom==0){send_to_char("{cYou are not in a kingdom.{x\n\r",ch);return;}
clan.c:    if (!IS_SET(ch->kincom,KINGDOM_C_DEMOTE)) {
clan.c:	if (victim->kingdom != ch->kingdom) 	  		      {
clan.c:	if (ch->kingdom_rank <= victim->kingdom_rank) {
clan.c:	if (kingdom_table[ch->kingdom].rank_slots[7] >= 2)  {
clan.c:	if (kingdom_table[ch->kingdom].rank_slots[8] >= 1)  {
clan.c:    kingdom_table[ch->kingdom].rank_slots[victim->kingdom_rank]   -= 1;
clan.c:    kingdom_table[ch->kingdom].rank_slots[victim->kingdom_rank-1] += 1;
clan.c:    sprintf(demote_message,"{CYou have been demoted to %s.{x\n\r",kingdom_table[ch->kingdom].rank_titlesf[victim->kingdom_rank-1]);	
clan.c:    sprintf(demote_message,"{CYou have been demoted to %s.{x\n\r",kingdom_table[ch->kingdom].rank_titles[victim->kingdom_rank-1]);	
clan.c:    sprintf(demote_message,"{C%s has been demoted to %s.{x\n\r",victim->name,kingdom_table[ch->kingdom].rank_titlesf[victim->kingdom_rank-1]);
clan.c:    sprintf(demote_message,"{C%s has been demoted to %s.{x\n\r",victim->name,kingdom_table[ch->kingdom].rank_titles[victim->kingdom_rank-1]);
clan.c:    if (ch->kingdom==0) {
clan.c:    if (!IS_SET(ch->kincom,KINGDOM_C_ADD)) {
clan.c:	number_of_members += kingdom_table[ch->kingdom].rank_slots[i];
clan.c:	kingdom_table[ch->kingdom].long_name );	
clan.c:    sprintf(induct_message,"{C%s has been inducted into %s.{x\n\r",victim->name,kingdom_table[ch->kingdom].long_name);
clan.c:    kingdom_table[ch->kingdom].rank_slots[victim->kingdom_rank-1] += 1;
clan.c:    victim->kingdom = ch->kingdom;
clan.c:    add_member(victim->name,ch->kingdom);
clan.c:    if (ch->kingdom==0) { 
clan.c:    if (!IS_SET(ch->kincom,KINGDOM_C_BAN)) {
clan.c:	if (victim->kingdom != ch->kingdom) 	  		      {
clan.c:	if (ch->kingdom_rank <= victim->kingdom_rank) {
clan.c:	kingdom_table[ch->kingdom].long_name );	
clan.c:	victim->name,kingdom_table[ch->kingdom].long_name);
clan.c:    kingdom_table[ch->kingdom].rank_slots[victim->kingdom_rank-1] -= 1;
clan.c:   subtract_member(victim->name,ch->kingdom);
clan.c:    if (ch->kingdom==0) {
clan.c:    if (ch->kingdom_rank >= 9) {
clan.c:	kingdom_table[ch->kingdom].long_name );	
clan.c:      if ( (ch->kingdom) && (skill_table[sn].kingdom == ch->kingdom))
clan.c:	ch->pcdata->learned[sn] = 0;
clan.c:	       ch->kingdom != skill_table[sn].kingdom )
clan.c:	ch->pcdata->learned[sn] = 0;
clan.c:    subtract_member(ch->name,ch->kingdom);
clan.c:    kingdom_table[ch->kingdom].rank_slots[ch->kingdom_rank-1] -= 1;
clan.c:    ch->kingdom_rank = 0;
clan.c:    ch->kingdom = 0; 
clan.c:    free_string( ch->pcdata->pretitle );
clan.c:    ch->pcdata->pretitle = str_dup("");
clan.c:    if (ch->kingdom==0) {
clan.c:    if (ch->kingdom==0) {
clan.c:    sprintf(buf,"%s areas",kingdom_table[ch->kingdom].name);
clan.c:	if(is_full_name(pArea->owner,kingdom_table[ch->kingdom].short_name)) {
clan.c:    if (ch->kingdom==0) {
clan.c:    sprintf(buf,"%s members",kingdom_table[ch->kingdom].name);
clan.c:	   if (is_full_name(kingdom_table[ch->kingdom].members[i],"NONE"))
clan.c:	sprintf(name,"  {B%-24s",kingdom_table[ch->kingdom].members[i]);
clan.c:    if (ch->kingdom==0){
clan.c:    if (!IS_SET(ch->in_room->room_flags, ROOM_BANK))
clan.c:    bank = kingdom_table[ch->kingdom].gold;
clan.c:    if (ch->kingdom==0){ 
clan.c:    if (!IS_SET(ch->in_room->room_flags, ROOM_BANK))
clan.c:    if (amount > ch->gold){send_to_char("{cThat's more than you've got.{x\n\r",ch);return;}
clan.c:    kingdom_table[ch->kingdom].gold += amount;
clan.c:    ch->gold -= amount;
clan.c:    if (ch->kingdom==0) {
clan.c:    if (!IS_SET(ch->kincom,KINGDOM_C_WITHDRAW)) {
clan.c:    if (!IS_SET(ch->in_room->room_flags, ROOM_BANK)) {
clan.c:    if ( amount > kingdom_table[ch->kingdom].gold) {
clan.c:    kingdom_table[ch->kingdom].gold -= amount;
clan.c:    ch->gold += amount;
clan.c:    AREA_DATA *pArea=ch->in_room->area;
clan.c:    pArea=ch->in_room->area;
clan.c:    if(!IS_SET(ch->kincom,KINGDOM_C_DE)) {
clan.c:    if (ch->kingdom==0) {
clan.c:    if (!(warring(ch->kingdom,enemy))) { 
clan.c:    for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next ) {
clan.c:	ch->in_room->area->name);
clan.c:    free_string(ch->in_room->area->owner);
clan.c:    ch->in_room->area->owner = strdup( "NONE" );
clan.c:    save_area(ch->in_room->area);
clan.c:    AREA_DATA *pArea=ch->in_room->area;
clan.c:    if (ch->kingdom==0) {
clan.c:    if(!IS_SET(ch->kincom,KINGDOM_C_CON)) {
clan.c:    obj       = create_object( get_obj_index(ch->kingdom+190), 60 );
clan.c:    obj_to_room(obj,ch->in_room);
clan.c: 	ch->in_room->area->name,
clan.c:	capitalize(kingdom_table[ch->kingdom].short_name));
clan.c:    free_string(ch->in_room->area->owner);
clan.c:    ch->in_room->area->owner = strdup(kingdom_table[ch->kingdom].short_name);
clan.c:    save_area(ch->in_room->area);
clan.c:    AREA_DATA *pArea=ch->in_room->area;
clan.c:    if (ch->kingdom==0){send_to_char("{cYou are not in a kingdom.{x\n\r",ch);return;}
clan.c:	if(!IS_SET(ch->kincom,KINGDOM_C_GUARD)) {
clan.c:    if (!is_full_name(pArea->owner,kingdom_table[ch->kingdom].short_name))
clan.c:    if ( kingdom_table[ch->kingdom].gold < (5000*(number-original)) )
clan.c:max_room = URANGE(3,ch->in_room->area->worth/10,10);
clan.c:max_area = (ch->in_room->area->worth/5+5);
clan.c:    kingdom_table[ch->kingdom].gold -= (5000*(number-original));
clan.c:    if (ch->kingdom==0) {
clan.c:    if (ch->kingdom_rank <= 8) {
clan.c:    if (ch->kingdom != victim->kingdom) {
comm.c:	sprintf( log_buf, "Closing link to %s.", ch->name );
comm.c:	    ch->desc = NULL;
comm.c:        if ((victim = ch->fighting) != NULL && can_see(ch,victim))
comm.c:                     !IS_SET(ch->act,PLR_HOLYLIGHT)) ?
comm.c:	if (!IS_SET(ch->comm, COMM_COMPACT) )
comm.c:        if ( IS_SET(ch->comm, COMM_PROMPT) )
comm.c:	    ch->hit,ch->mana,ch->move );
comm.c:	if (IS_SET(ch->comm,COMM_TELNET_GA))
comm.c:    str = ch->prompt;
comm.c:	    ch->hit,ch->mana,ch->move,ch->prefix);
comm.c:   if (IS_SET(ch->comm,COMM_BUSY))
comm.c:   if (IS_SET(ch->comm,COMM_AFK))
comm.c:		if ((pexit = ch->in_room->exit[door]) != NULL
comm.c:      if (ch->max_hit > 0)
comm.c:          percent = ch->hit * 100 / ch->max_hit;
comm.c:      if (ch->max_mana > 0)
comm.c:          percent = ch->mana * 100 / ch->max_mana;
comm.c:      if (ch->max_move > 0)
comm.c:          percent = ch->move * 100 / ch->max_move;
comm.c:                ch->level>=40?ch->hit:PERCENT(ch->hit,ch->max_hit),
comm.c:		ch->level>=40?"":"%" );
comm.c:            sprintf( buf2, "%d", ch->max_hit );
comm.c:	    if ( ch->level >= 40 )
comm.c:              sprintf( buf2, "%d", ch->mana );
comm.c:	      sprintf( buf2, "%d%%", PERCENT(ch->mana, ch->max_mana ));
comm.c:            sprintf( buf2, "%d", ch->max_mana );
comm.c:	    if ( ch->level >= 40 )
comm.c:              sprintf( buf2, "%d", ch->move );
comm.c:	      sprintf( buf2, "%d%%", PERCENT( ch->move, ch->max_move) );
comm.c:            sprintf( buf2, "%d", ch->max_move );
comm.c:        exp_to_level(ch,ch->pcdata->points) );
comm.c:            sprintf( buf2, "%d", ch->exp );
comm.c:	    (ch->level + 1) * exp_per_level(ch,ch->pcdata->points) - ch->exp);
comm.c:            sprintf( buf2, "%ld", ch->gold);
comm.c:	    sprintf( buf2, "%ld", ch->silver);
comm.c:            if( ch->level > 9 )
comm.c:               sprintf( buf2, "%d", ch->alignment );
comm.c:            if( ch->in_room != NULL )
comm.c:		((!IS_NPC(ch) && IS_SET(ch->act,PLR_HOLYLIGHT)) ||
comm.c:		 (!IS_AFFECTED(ch,AFF_BLIND) && !room_is_dark( ch->in_room ,ch)))
comm.c:		? ch->in_room->name : "darkness");
comm.c:            if( IS_IMMORTAL( ch ) && ch->in_room != NULL )
comm.c:               sprintf( buf2, "%d", ch->in_room->vnum );
comm.c:            if( IS_IMMORTAL( ch ) && ch->in_room != NULL )
comm.c:               sprintf( buf2, "%s", ch->in_room->area->name );
comm.c:   write_to_buffer( ch->desc, buffer, 0 );
comm.c:  /* write_to_buffer( ch->desc, buf, point - buf ); */
comm.c:   if (ch->prefix[0] != '\0')
comm.c:        write_to_buffer(ch->desc,ch->prefix,0);
comm.c:	if ( IS_SET(ch->act, PLR_DENY) )
comm.c:	if ( IS_SET(ch->detection, D_LOCKHOST) )    
comm.c:           && !str_cmp(dt->character->name,ch->name))
comm.c:	if ( strcmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd )
comm.c:		      ch->name,d->host);
comm.c:	if ( strcmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd ) )
comm.c:	    sprintf(buf, "Wrong password by %s@%s", ch->name, d->host);
comm.c:	    if (ch->endur == 2)
comm.c:		 ch->endur++;
comm.c:	if ( ch->pcdata->pwd[0] == (int) NULL)
comm.c:	if ( check_reconnect( d, ch->name, TRUE ) )
comm.c:	if ( check_playing( d, ch->name ) )
comm.c:	for (obj = ch->carrying,obj_count = 0; obj != NULL;
comm.c:	strcpy(buf,ch->name);
comm.c:	for (obj = ch->carrying,obj_count2 = 0; obj != NULL;
comm.c:	sprintf( log_buf, "%s@%s has connected.", ch->name, d->host);
comm.c:	wiznet(log_buf,ch,NULL,WIZ_LOGINS,0,ch->level);
comm.c:if( ch->version < CURRENT_VERSION)
comm.c:     ch->version = CURRENT_VERSION;
comm.c:	  sprintf(log_buf, "%s@%s tried to use the clone cheat.", ch->name,
comm.c:	  for (obj = ch->carrying; obj != NULL; obj = inobj) {
comm.c:	    ch->perm_stat[obj_count]--;
comm.c:		if (str_cmp(ch->name,d_old->character->name))
comm.c:	    if (check_reconnect(d,ch->name,TRUE))
comm.c:		ch->name, (char *) echo_off_str );
comm.c:	pwdnew = crypt( argument, ch->name );
comm.c:	free_string( ch->pcdata->pwd );
comm.c:	ch->pcdata->pwd	= str_dup( pwdnew );
comm.c:	if ( strcmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd ) )
comm.c:        ch->race = race;
comm.c:	    ch->mod_stat[i] += pc_race_table[race].stats[i];
comm.c:	ch->max_hit += pc_race_table[race].hp_bonus;
comm.c:	ch->hit = ch->max_hit;
comm.c:	ch->max_mana += pc_race_table[race].mana_bonus;
comm.c:	ch->mana = ch->max_mana;
comm.c:	ch->practice = pc_race_table[race].prac_bonus;
comm.c:	ch->affected_by = ch->affected_by|race_table[race].aff;
comm.c:	ch->affected_by2= ch->affected_by2|race_table[race].aff2;
comm.c:	ch->detection   = ch->detection|race_table[race].detect;
comm.c:	ch->imm_flags	= ch->imm_flags|race_table[race].imm;
comm.c:	ch->res_flags	= ch->res_flags|race_table[race].res;
comm.c:	ch->vuln_flags	= ch->vuln_flags|race_table[race].vuln;
comm.c:	ch->form	= race_table[race].form;
comm.c:	ch->parts	= race_table[race].parts;
comm.c:	    ch->pcdata->learned[skill_lookup(pc_race_table[race].skills[i])]
comm.c:	ch->pcdata->points = pc_race_table[race].points;
comm.c:	ch->size = pc_race_table[race].size;
comm.c:	case 'm': case 'M': ch->sex = SEX_MALE;
comm.c:			    ch->pcdata->true_sex = SEX_MALE;
comm.c:	case 'f': case 'F': ch->sex = SEX_FEMALE;
comm.c:			    ch->pcdata->true_sex = SEX_FEMALE;
comm.c:         if (pc_race_table[ch->race].class_mult[iClass] != -1)
comm.c:	if (pc_race_table[ch->race].class_mult[iClass] == -1)
comm.c:        ch->class = iClass;
comm.c:	ch->pcdata->points += class_table[iClass].points;
comm.c:	  ch->mod_stat[i] += class_table[iClass].stats[i];
comm.c:	    ch->perm_stat[i] = number_range(10,18) + ch->mod_stat[i];
comm.c:	    if (ch->perm_stat[i] < 10)
comm.c:	      ch->perm_stat[i] = 10;
comm.c:	    else if (ch->perm_stat[i] > pc_race_table[ch->race].max_stats[i])
comm.c:	      ch->perm_stat[i] = pc_race_table[ch->race].max_stats[i];
comm.c:	ch->perm_stat[STAT_STR], ch->perm_stat[STAT_INT],
comm.c:	ch->perm_stat[STAT_WIS], ch->perm_stat[STAT_DEX],
comm.c:	ch->perm_stat[STAT_CON]);
comm.c:	      ch->mod_stat[i] = 0;
comm.c:	    if (!str_cmp(pc_race_table[ch->race].align,"good")
comm.c:		|| !str_cmp(class_table[ch->class].align,"good"))
comm.c:		ch->alignment = 750;
comm.c:	    if (!str_cmp(pc_race_table[ch->race].align,"neutral")
comm.c:		|| !str_cmp(class_table[ch->class].align,"neutral"))
comm.c:		ch->alignment = 0;
comm.c:	    if (!str_cmp(pc_race_table[ch->race].align,"evil")
comm.c:		|| !str_cmp(class_table[ch->class].align,"evil"))
comm.c:		ch->alignment = -750;
comm.c:	    ch->perm_stat[i] = number_range(10,18) + ch->mod_stat[i];
comm.c:	    if (ch->perm_stat[i] < 10)
comm.c:	      ch->perm_stat[i] = 10;
comm.c:	    else if (ch->perm_stat[i] > pc_race_table[ch->race].max_stats[i])
comm.c:	      ch->perm_stat[i] = pc_race_table[ch->race].max_stats[i];
comm.c:	ch->perm_stat[STAT_STR], ch->perm_stat[STAT_INT],
comm.c:	ch->perm_stat[STAT_WIS], ch->perm_stat[STAT_DEX],
comm.c:	ch->perm_stat[STAT_CON]);
comm.c:	  case 'g' : case 'G' : ch->alignment = 750;
comm.c:	    if (ch->race == race_lookup("ogre"))
comm.c:	  case 'n' : case 'N' : ch->alignment = 0;
comm.c:	    if (ch->race == race_lookup("svirfneblin"))
comm.c:	    else if (ch->race == race_lookup("dwarf"))
comm.c:		ch->alignment = -750;
comm.c:	case 'S' : case 's' : ch->hometown = 0;
comm.c:	  if ( ch->class != 3 ) {
comm.c:	    ch->ethos = 1;
comm.c:	'n' : ch->hometown = 1;
comm.c:	  if ( ch->class != 3 ) {
comm.c:	    ch->ethos = 1;
comm.c:	  ch->hometown = 2;
comm.c:	  if ( ch->class != 3 ) {
comm.c:	    ch->ethos = 1;
comm.c:	  ch->hometown = 3;
comm.c:	  ch->hometown = 4;
comm.c:	case 'L': case 'l': ch->ethos = 1; break;
comm.c:	case 'N': case 'n': ch->ethos = 2; break;
comm.c:	case 'C': case 'c': ch->ethos = 3; break;
comm.c:	sprintf( log_buf, "%s@%s new player.", ch->name, d->host);
comm.c:        ch->pcdata->learned[gsn_recall] = 50;
comm.c:	    sprintf(buf,"Creation points: %d\n\r",ch->pcdata->points);
comm.c:		    exp_to_level(ch,ch->gen_data->points_chosen));
comm.c:	    if (ch->pcdata->points < 40)
comm.c:		ch->train = (40 - ch->pcdata->points + 1) / 2;
comm.c:	ch->next	= char_list;
comm.c:	ch->pcdata->host != NULL ? ch->pcdata->host : "unknown");
comm.c:	free_string(ch->pcdata->host);
comm.c:	ch->pcdata->host = str_dup(d->host);
comm.c:	if ( ch->level == 0 )
comm.c:	    ch->level	= 1;
comm.c:	    ch->exp     = base_exp(ch,ch->pcdata->points);
comm.c:	    ch->hit	= ch->max_hit;
comm.c:	    ch->mana	= ch->max_mana;
comm.c:	    ch->move	= ch->max_move;
comm.c:	    ch->train	 = 3;
comm.c:	    ch->practice += 5;
comm.c:	    ch->pcdata->death = 5;
comm.c:	ch->pcdata->total_death = 0;
comm.c:	ch->pcdata->sign=month_name[time_info.month]; 
comm.c:	ch->pcdata->background =
comm.c:		title_table [ch->class] [ch->level]
comm.c:		[ch->sex == SEX_FEMALE ? 1 : 0] );
comm.c:	    if ( ch->hometown == 0 && IS_EVIL(ch) )
comm.c:	    if (ch->hometown == 1)
comm.c:	    if (ch->hometown == 3)
comm.c:	    if (ch->hometown == 2)
comm.c:	    if (ch->hometown == 4)
comm.c:	      if(ch->class == CLASS_MNK) 
comm.c:	    ch->pcdata->learned[gsn_hand_to_hand]= 40;
comm.c: 	    ch->pcdata->learned[get_weapon_sn(ch)]= 40;
comm.c:	    SET_BIT(ch->comm, COMM_SHOW_AFFECTS);
comm.c:	else if ( ch->in_room != NULL )
comm.c:	    char_to_room( ch, ch->in_room );
comm.c:	if (ch->class == class_lookup("warrior"))
comm.c:	    if (ch->pcdata->learned[gsn_charge] < 1)
comm.c:		ch->pcdata->learned[gsn_charge] = 1;
comm.c:	if (ch->pet != NULL)
comm.c:	    char_to_room(ch->pet,ch->in_room);
comm.c:	    act("{G$n has returned with $s owner.{x",ch->pet,NULL,NULL,TO_ROOM);
comm.c:    for ( ch = char_list; ch != NULL; ch = ch->next )
comm.c:	&&   (!fConn || ch->desc == NULL)
comm.c:	&&   !str_cmp( d->character->name, ch->name ) )
comm.c:		d->character->pcdata->pwd = str_dup( ch->pcdata->pwd );
comm.c:		ch->desc	 = d;
comm.c:		ch->timer	 = 0;
comm.c:		    --ch->in_room->light;
comm.c:		sprintf( log_buf, "%s@%s reconnected.", ch->name,d->host);
comm.c: 		if (ch->pcdata->in_progress)
comm.c:		   if (IS_SET(ch->comm,COMM_BUSY))
comm.c:		      REMOVE_BIT(ch->comm,COMM_BUSY);
comm.c:    ||   ch->desc == NULL
comm.c:    ||   ch->desc->connected != CON_PLAYING
comm.c:    ||   ch->was_in_room == NULL
comm.c:    ||   ch->in_room != get_room_index(ROOM_VNUM_LIMBO))
comm.c:    ch->timer = 0;
comm.c:    char_to_room( ch, ch->was_in_room );
comm.c:    ch->was_in_room	= NULL;
comm.c:    if( txt && ch->desc )
comm.c:	    if( IS_SET( ch->act, PLR_COLOR ) )
comm.c:        	write_to_buffer( ch->desc, buf, point2 - buf );
comm.c:        	write_to_buffer( ch->desc, buf, point2 - buf );
comm.c:    if ( txt != NULL && ch->desc != NULL )
comm.c:        write_to_buffer( ch->desc, txt, strlen(txt) );
comm.c:    if ( txt == NULL || ch->desc == NULL)
comm.c:    if (ch->lines == 0 )
comm.c:    ch->desc->showstr_head = alloc_mem(strlen(txt) + 1);
comm.c:    strcpy(ch->desc->showstr_head,txt);
comm.c:    ch->desc->showstr_point = ch->desc->showstr_head;
comm.c:    show_string(ch->desc,"");
comm.c:   if( txt && ch->desc )
comm.c:	    if( IS_SET( ch->act, PLR_COLOR ) )
comm.c:		free_string( ch->desc->showstr_head );
comm.c:		ch->desc->showstr_head  = str_dup( buf );
comm.c:		ch->desc->showstr_point = ch->desc->showstr_head;
comm.c:		show_string( ch->desc, "" );
comm.c:		free_string( ch->desc->showstr_head );
comm.c:		ch->desc->showstr_head  = str_dup( buf );
comm.c:		ch->desc->showstr_point = ch->desc->showstr_head;
comm.c:		show_string( ch->desc, "" );
comm.c:    if (ch->sex < 0 || ch->sex > 2)
comm.c:    	ch->sex = IS_NPC(ch) ? 0 : ch->pcdata->true_sex;
comm.c:    if (ch == NULL || ch->in_room == NULL)
comm.c:    to = ch->in_room->people;
comm.c:	if (vch->in_room == NULL)
comm.c:        to = vch->in_room->people;
comm.c:		    PERS(ch->doppel,to) : PERS( ch,  to );
comm.c:		    PERS(vch->doppel,to):PERS(vch,  to );
comm.c:		    he_she [URANGE(0,ch->doppel->sex,2)] :
comm.c:		    he_she  [URANGE(0, vch->doppel->sex, 2)] :
comm.c:		    he_she  [URANGE(0, vch->sex, 2)];
comm.c:		    him_her [URANGE(0,ch->doppel->sex,2)] :
comm.c:		    him_her [URANGE(0, ch->sex, 2)];
comm.c:		    him_her  [URANGE(0, vch->doppel->sex, 2)] :
comm.c:		    him_her  [URANGE(0, vch->sex, 2)];
comm.c:		    his_her [URANGE(0,ch->doppel->sex,2)] :
comm.c:		    his_her  [URANGE(0, vch->doppel->sex, 2)] :
comm.c:		    his_her  [URANGE(0, vch->sex, 2)];
comm.c:    if( ch->desc && txt )
comm.c:	if( IS_SET( ch->act, PLR_COLOR ) )
db.c:      if ( (ch->in_room->area == pArea) &&
db.c:           ( !IS_SET(ch->in_room->room_flags, ROOM_INDOORS) ) )
db.c:    ch->name			= &str_empty[0];
db.c:    ch->short_descr		= &str_empty[0];
db.c:    ch->long_descr		= &str_empty[0];
db.c:    ch->description		= &str_empty[0];
db.c:    ch->prompt                  = &str_empty[0];
db.c:    ch->logon			= current_time;
db.c:    ch->lines			= PAGELEN;
db.c:    	ch->armor[i]		= 100;
db.c:    ch->position		= POS_STANDING;
db.c:    ch->hit			= 20;
db.c:    ch->max_hit			= 20;
db.c:    ch->mana			= 100;
db.c:    ch->max_mana		= 100;
db.c:    ch->move			= 100;
db.c:    ch->max_move		= 100;
db.c:/*  ch->riding			= NULL;
db.c:    ch->mounted_by		= NULL;
db.c:    ch->last_fought             = NULL;
db.c:    ch->last_fight_time         = -1;
db.c:    ch->last_death_time         = -1;
db.c:    ch->on			= NULL;
db.c:	ch->perm_stat[i] = 13;
db.c:	ch->mod_stat[i] = 0;
db.c:    for (fch = char_list; fch != NULL; fch = fch->next)
db.c:	if (fch->pcdata != NULL)
db.c:	for (af = fch->affected; af != NULL; af = af->next)
db.c:    for (fch = char_free; fch != NULL; fch = fch->next)
db.c:	    ch->in_room ? ch->in_room->vnum : 0, ch->name, str );
fight.c:	ch_next	= ch->next;
fight.c:	if ( ( victim = ch->fighting ) == NULL || ch->in_room == NULL )
fight.c:	if ( IS_AWAKE(ch) && ch->in_room == victim->in_room )
fight.c:	if ( ( victim = ch->fighting ) == NULL )
fight.c:	  ch->last_fought = victim;
fight.c:	ch->last_fight_time = current_time;
fight.c:	for (obj = ch->carrying;obj != NULL; obj = obj->next_content)
fight.c:	if (IS_SET(ch->progtypes,MPROG_FIGHT) && (ch->wait <= 0))
fight.c:	  (ch->pIndexData->moprogs->fight_prog) (ch,victim);
fight.c:    for (rch = ch->in_room->people; rch != NULL; rch = rch_next)
fight.c:	rch_next = rch->next_in_room;
fight.c:	if (IS_AWAKE(rch) && rch->fighting == NULL)
fight.c:	    && IS_SET(rch->off_flags,ASSIST_PLAYERS)
fight.c:	    && (rch->level + 6 > victim->level)
fight.c:	    && IS_SET(rch->off_flags,ASSIST_CLAN)
fight.c:	    &&  (((rch->pIndexData->vnum-100)/10) != victim->kingdom)
fight.c:		if (  ((!IS_NPC(rch) && IS_SET(rch->act,PLR_AUTOASSIST)
fight.c:		&& (rch->desc ))
fight.c:		&& (ch->desc )
fight.c:		if ( (IS_NPC(rch) && IS_SET(rch->off_flags,ASSIST_ALL))
fight.c:		||   (IS_NPC(rch) && rch->race == ch->race
fight.c:		   && IS_SET(rch->off_flags,ASSIST_RACE))
fight.c:		||   (IS_NPC(rch) && IS_SET(rch->off_flags,ASSIST_ALIGN)
fight.c:		||   (rch->pIndexData == ch->pIndexData
fight.c:		   && IS_SET(rch->off_flags,ASSIST_VNUM)) )
fight.c:		    for (vch = ch->in_room->people; vch; vch = vch->next)
fight.c:    if (ch->desc == NULL)
fight.c:	ch->wait = UMAX(0,ch->wait - PULSE_VIOLENCE);
fight.c:    if (ch->position < POS_RESTING)
fight.c:	(!IS_NPC(ch) && IS_SET(ch->act, PLR_GHOST)))
fight.c:         SET_BIT(ch->affected_by,AFF_WEAK_STUN); */
fight.c:	if ( ch->fighting != victim )
fight.c:    if (ch->fighting != victim)
fight.c:    if ( ch->fighting != victim || dt == gsn_backstab || dt == gsn_cleave
fight.c:	if ( ch->fighting != victim )
fight.c:	if ( ch->fighting != victim )
fight.c:	if ( ch->fighting != victim )
fight.c:	if (ch->class == CLASS_MNK) 
fight.c:	if ( ch->fighting != victim )
fight.c:	if (ch->class == CLASS_MNK) 
fight.c:        if ( ch->fighting != victim )
fight.c:	if (ch->class == CLASS_MNK) 
fight.c:        if ( ch->fighting != victim )
fight.c:	if ( ch->fighting != victim )
fight.c:    if (ch->fighting != victim)
fight.c:    if (IS_SET(ch->off_flags,OFF_AREA_ATTACK))
fight.c:	for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
fight.c:	    vch_next = vch->next;
fight.c:	    if ((vch != victim && vch->fighting == ch))
fight.c:    if (IS_AFFECTED(ch,AFF_HASTE) || IS_SET(ch->off_flags,OFF_FAST))
fight.c:    if (ch->fighting != victim || dt == gsn_backstab || dt == gsn_circle ||
fight.c:	if (ch->fighting != victim)
fight.c:	if (ch->fighting != victim)
fight.c:	if (ch->fighting != victim)
fight.c:    if (ch->wait > 0)
fight.c:    if (number == 1 && IS_SET(ch->act,ACT_MAGE))
fight.c:    if (number == 2 && IS_SET(ch->act,ACT_CLERIC))
fight.c:	if (IS_SET(ch->off_flags,OFF_BASH))
fight.c:	if (IS_SET(ch->off_flags,OFF_BERSERK) && !IS_AFFECTED(ch,AFF_BERSERK))
fight.c:	if (IS_SET(ch->off_flags,OFF_DISARM)
fight.c:	&& (IS_SET(ch->act,ACT_WARRIOR)
fight.c:   	||  IS_SET(ch->act,ACT_THIEF))))
fight.c:	if (IS_SET(ch->off_flags,OFF_KICK))
fight.c:	if (IS_SET(ch->off_flags,OFF_KICK_DIRT))
fight.c:	if (IS_SET(ch->off_flags,OFF_TAIL))
fight.c:	if (IS_SET(ch->off_flags,OFF_TRIP))
fight.c:	if (IS_SET(ch->off_flags,OFF_CRUSH))
fight.c:	(!IS_NPC(ch) && IS_SET(ch->act, PLR_GHOST)))
fight.c:    if ( victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:/*    if ((ch->class == CLASS_MNK) && ( get_eq_char( ch, WEAR_HANDS ) != NULL ))
fight.c:	    dt += ch->dam_type;
fight.c:    	    dam_type = attack_table[ch->dam_type].damage;
fight.c:	if (IS_SET(ch->act,ACT_WARRIOR))
fight.c:	else if (IS_SET(ch->act,ACT_THIEF))
fight.c:	else if (IS_SET(ch->act,ACT_CLERIC))
fight.c:	else if (IS_SET(ch->act,ACT_MAGE))
fight.c:	thac0_00 = class_table[ch->class].thac0_00;
fight.c:	thac0_32 = class_table[ch->class].thac0_32;
fight.c:    thac0  = interpolate( ch->level, thac0_00, thac0_32 );
fight.c:    if ( IS_NPC(ch) && (!ch->pIndexData->new_format || wield == NULL))
fight.c:	if (!ch->pIndexData->new_format)
fight.c:	    dam = number_range( ch->level / 2, ch->level * 3 / 2 );
fight.c:	    dam = dice(ch->damage[DICE_NUMBER],ch->damage[DICE_TYPE]);
fight.c:	    dam = number_range( 1 + 4 * skill/100, 2 * ch->level/3 * skill/100);
fight.c:	ch->fighting = victim;
fight.c:      dam = (ch->level/50 + 1) * dam + (ch->level+100);
fight.c:      dam = (ch->level/40 - 1) * dam + (ch->level+100);
fight.c:      dam = (ch->level/55 + 1) * dam + (ch->level+50);
fight.c:	if (number_percent() <= 2 && !counter &&((ch->level-10)>victim->level))
fight.c:    if ( !IS_SET ( ch->in_room->room_flags, ROOM_ARENA ) )
fight.c:         ch->pcdata->awins += 1; } */
fight.c:  sprintf(buf, "{R[{YARENA{R] {c%s {Ris victorious in the arena!{w",ch->name);
fight.c:    if(ch->pcdata->arenahp != 0)
fight.c:    ch->hit = ch->pcdata->arenahp;
fight.c:    ch->hit = ch->max_hit;
fight.c:    if(ch->pcdata->arenamp != 0)
fight.c:    ch->mana = ch->pcdata->arenamp;
fight.c:    ch->mana = ch->max_mana;
fight.c:    if(ch->pcdata->arenamove !=0)
fight.c:    ch->move = ch->pcdata->arenamove;
fight.c:    ch->move = ch->max_move;
fight.c:    ch->hit = ch->max_hit;
fight.c:    ch->mana = ch->max_mana;
fight.c:    ch->pking = 0;
fight.c:    ch->last_fight_time = -1;
fight.c:    REMOVE_BIT(ch->act, PLR_ARENA);
fight.c:                if ( ch->pcdata->room_number == 0 ) 
fight.c:     char_to_room(ch,get_room_index(ch->pcdata->room_number));
fight.c:    sprintf(buf, "{R[{YARENA{R] {c%s {Rhas just defeated %s!{w",ch->name,victim->name);
fight.c:	    if(ch->msp == 1)
fight.c:            (IS_NPC(ch) ? ch->short_descr : ch->name),
fight.c:            ch->in_room->name, ch->in_room->vnum);
fight.c:	   if(!warring(ch->kingdom,victim->kingdom)) 
fight.c:		ch->lastpk = current_time;
fight.c:	&&  (corpse = get_obj_list(ch,"corpse",ch->in_room->contents)) != NULL
fight.c:	    corpse = get_obj_list( ch, "corpse", ch->in_room->contents ); 
fight.c:	    if ( IS_SET(ch->act, PLR_AUTOLOOT) &&
fight.c:   		if (IS_SET(ch->act,PLR_AUTOGOLD) &&
fight.c:                    !IS_SET(ch->act,PLR_AUTOLOOT))  
fight.c:	    if ( IS_SET(ch->act, PLR_AUTOSAC) )
fight.c:       	      if ( IS_SET(ch->act,PLR_AUTOLOOT) && corpse && corpse->contains)
fight.c:	else dam = (dam * 2 + ch->level);
fight.c:	if (number_percent() <= URANGE(10,20+(ch->level-victim->level)*2,50) && !counter && (ch->level/2 > victim->level))
fight.c:    if ( !IS_SET ( ch->in_room->room_flags, ROOM_ARENA ) )
fight.c:    free_string( ch->pcdata->title );ch->pcdata->title = str_dup( buf );}
fight.c:		    if(ch->msp == 1)
fight.c:            (IS_NPC(ch) ? ch->short_descr : ch->name),
fight.c:            ch->in_room->name, ch->in_room->vnum);
fight.c:	   if(!warring(ch->kingdom,victim->kingdom)) 
fight.c:		ch->lastpk = current_time;
fight.c:	&&  (corpse = get_obj_list(ch,"corpse",ch->in_room->contents)) != NULL
fight.c:	    corpse = get_obj_list( ch, "corpse", ch->in_room->contents ); 
fight.c:	    if ( IS_SET(ch->act, PLR_AUTOLOOT) &&
fight.c:		   if (IS_SET(ch->act,PLR_AUTOGOLD) &&
fight.c:                    !IS_SET(ch->act,PLR_AUTOLOOT))  
fight.c:	    if ( IS_SET(ch->act, PLR_AUTOSAC) )
fight.c:       	      if ( IS_SET(ch->act,PLR_AUTOLOOT) && corpse && corpse->contains)
fight.c:    if (!IS_NPC(ch) && ch->pcdata->learned[gsn_deathblow] > 1 &&
fight.c:	ch->level >= skill_table[gsn_deathblow].skill_level[ch->class] )
fight.c:	if (number_percent() < 0.125 * ch->pcdata->learned[gsn_deathblow])
fight.c:		dam *= number_range(1.5,(float)ch->level/40);
fight.c:        if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_POISON))
fight.c:        if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_VAMPIRIC))
fight.c:            ch->hit += dam/2;
fight.c:        if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_FLAMING))
fight.c:        if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_FROST))
fight.c:        if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_SHOCKING))
fight.c:        if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_MANADRAIN))
fight.c:            ch->mana += dam/4;
fight.c:    if (ch->msp == 1)
fight.c:	sprintf(buf,"%s is doing %d damage with %s.",ch->name,dam,obj->name);
fight.c:	    if ( ch->fighting == NULL )
fight.c:	    &&   victim->master->in_room == ch->in_room
fight.c:	if(IS_NPC(ch) && ch->master != NULL
fight.c:    	&& ch->in_room != ch->master->in_room ) {
fight.c:    if ( IS_SET(ch->affected_by, AFF_HIDE)
fight.c:	|| IS_SET(ch->affected_by, AFF_INVISIBLE)
fight.c:	|| IS_SET(ch->affected_by, AFF_FADE)
fight.c:	|| IS_SET(ch->affected_by, AFF_SNEAK)
fight.c:	|| IS_SET(ch->affected_by, AFF_CAMOUFLAGE))
fight.c:              && number_percent() < UMIN( 25, UMAX( 10, ch->level ) )
fight.c:    if ( !IS_SET ( ch->in_room->room_flags, ROOM_ARENA ) )
fight.c:                (IS_NPC(ch) ? ch->short_descr : ch->name),
fight.c:	    if (victim == ch || (IS_NPC(ch) && (ch->master == NULL &&
fight.c:		 ch->leader == NULL)) || IS_SET(victim->act,PLR_WANTED))
fight.c:     ch->pcdata->pkills += 1;
fight.c:    sprintf(buf, " the Nefarious %s", capitalize(class_table[ch->class].name ));
fight.c:    free_string( ch->pcdata->title );ch->pcdata->title = str_dup( buf );}
fight.c:    free_string( ch->pcdata->title );ch->pcdata->title = str_dup( buf );}
fight.c:            ch->pcdata->bounty += (3 * victim->level) + (dice(1,ch->level));
fight.c:               ch->pcdata->owed   += victim->pcdata->bounty;
fight.c:    free_string( ch->pcdata->title );ch->pcdata->title = str_dup( buf );}
fight.c:    free_string( ch->pcdata->title );ch->pcdata->title = str_dup( buf );}
fight.c:    free_string( ch->pcdata->title );ch->pcdata->title = str_dup( buf );}
fight.c:                   (ch->master == NULL && ch->leader == NULL))
fight.c:                   (ch->master == NULL && ch->leader == NULL))
fight.c:         ch->pcdata->awins += 1; } */
fight.c:    sprintf(buf, "{R[{YARENA{R] {c%s {Ris victorious in the arena!{w", ch->name);
fight.c:    if(ch->pcdata->arenahp != 0)
fight.c:    ch->hit = ch->pcdata->arenahp;
fight.c:    ch->hit = ch->max_hit;
fight.c:    if(ch->pcdata->arenamp != 0)
fight.c:    ch->mana = ch->pcdata->arenamp;
fight.c:    ch->mana = ch->max_mana;
fight.c:    if(ch->pcdata->arenamove != 0)
fight.c:    ch->move = ch->pcdata->arenamove;
fight.c:    ch->move = ch->max_move;
fight.c:    ch->hit = ch->max_hit;
fight.c:    ch->mana = ch->max_mana;
fight.c:    ch->last_fight_time = -1;
fight.c:    ch->pking = 0;
fight.c:    REMOVE_BIT(ch->act, PLR_ARENA);
fight.c:                if ( ch->pcdata->room_number == 0 )
fight.c:    char_to_room(ch,get_room_index(ch->pcdata->room_number));
fight.c:    sprintf(buf, "{R[{YARENA{R] {c%s {Rhas just defeated %s!{w",ch->name,victim->name);
fight.c:	    if(ch->msp == 1)
fight.c:            (IS_NPC(ch) ? ch->short_descr : ch->name),
fight.c:            ch->in_room->name, ch->in_room->vnum);
fight.c:	   if(!warring(ch->kingdom,victim->kingdom)) 
fight.c:	ch->lastpk = current_time;
fight.c:	&&  (corpse = get_obj_list(ch,"corpse",ch->in_room->contents)) != NULL
fight.c:	    corpse = get_obj_list( ch, "corpse", ch->in_room->contents ); 
fight.c:	    if ( IS_SET(ch->act, PLR_AUTOLOOT) &&
fight.c:	   if (IS_SET(ch->act,PLR_AUTOGOLD) &&
fight.c:                    !IS_SET(ch->act,PLR_AUTOLOOT))  {
fight.c:	    if ( IS_SET(ch->act, PLR_AUTOSAC) )
fight.c:       	      if ( IS_SET(ch->act,PLR_AUTOLOOT) && corpse && corpse->contains)
fight.c:    for ( obj = ch->carrying; obj; obj = obj->next_content )
fight.c:      (!IS_NPC(ch) && IS_SET(ch->act, PLR_GHOST)))
fight.c:   if ( IS_SET ( ch->in_room->room_flags, ROOM_ARENA ) )
fight.c:  time = current_time - ch->lastpk;
fight.c:  if ((victim->notewrite) || (ch->notewrite))
fight.c:  if(IS_SET(victim->act,PLR_WANTED) && ch->kingdom == 1)
fight.c:if ( strstr( ch->in_room->area->builders, "Arena" ) &&
fight.c:	!IS_SET(ch->in_room->room_flags, ROOM_ARENA) ) 
fight.c:	((strlen(ch->description) < 250 ))) ||
fight.c:	 ((strlen(ch->pcdata->background) < 500 ))))
fight.c:  chexp = IS_NPC(ch) ? ch->exp :
fight.c:    UMAX(ch->exp, ch->exp - exp_this_level(ch,ch->level,ch->pcdata->points));
fight.c:      ((ch->last_death_time != -1 && current_time - ch->last_death_time < 600 )
fight.c:      ((ch->level >= victim->level + 7) || (victim->level >= ch->level + 7)))
fight.c:    if (ch == victim && area && ch->in_room->sector_type == SECT_INSIDE)
fight.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_ARENA ) )      /* ARENA */
fight.c:    if ( IS_SET(ch->affected_by, AFF_CHARM) )
fight.c:	if ( ch->master == NULL )
fight.c:		IS_NPC(ch) ? ch->short_descr : ch->name );
fight.c:	    REMOVE_BIT( ch->affected_by, AFF_CHARM );
fight.c:	send_to_char( "*** You are now a KILLER!! ***\n\r", ch->master );
fight.c:  	SET_BIT(ch->master->act, PLR_KILLER);
fight.c:    ||   ch->level >= LEVEL_IMMORTAL
fight.c:    ||   IS_SET(ch->act, PLR_KILLER) )
fight.c:    SET_BIT(ch->act, PLR_KILLER);
fight.c:	ch->pking = 5;
fight.c:sprintf(buf,"%s is attempting to murder %s",ch->name,victim->name);
fight.c:    	if (IS_SET(ch->off_flags,OFF_FAST) || IS_AFFECTED(ch,AFF_HASTE))
fight.c:    if ( number_percent( ) >= chance + (victim->level/2) - (ch->level/2) )
fight.c:    if ( number_percent( ) >= chance + (victim->level/2) - (ch->level/2) )
fight.c:    	if (IS_SET(ch->off_flags,OFF_FAST) || IS_AFFECTED(ch,AFF_HASTE))
fight.c:	 if((ch->race == race_lookup("pixie")))
fight.c:    if ( number_percent( ) >= chance + (victim->level/2) - (ch->level/2) )
fight.c:/*    if ( ch->fighting != NULL )
fight.c:    ch->fighting = victim;
fight.c:    ch->position = POS_FIGHTING;
fight.c:	if(ch->msp == 1)
fight.c:    for ( fch = char_list; fch != NULL; fch = fch->next )
fight.c:	if ( fch == ch || ( fBoth && fch->fighting == ch ) )
fight.c:	    fch->fighting	= NULL;
fight.c:	    fch->position	= IS_NPC(fch) ? ch->default_pos : POS_STANDING;
fight.c:        name            = ch->short_descr;
fight.c:     if((pShop = ch->pIndexData->pShop) != NULL) {
fight.c:          ch->gold = ch->level*4;
fight.c:          ch->silver = ch->level*3;
fight.c:        if ( ch->gold > 0 )
fight.c:            obj_to_obj( create_money( ch->gold, ch->silver ), corpse );
fight.c:            ch->gold = 0;
fight.c:            ch->silver = 0;
fight.c:        name            = ch->name;
fight.c:        REMOVE_BIT(ch->act,PLR_CANLOOT);
fight.c:        corpse->owner = str_dup(ch->name);
fight.c:            if (ch->gold > 1 || ch->silver > 1)
fight.c:                obj_to_obj(create_money(ch->gold / 2, ch->silver/2),corpse);
fight.c:                ch->gold -= ch->gold/2;
fight.c:                ch->silver -= ch->silver/2;
fight.c:    corpse->level = ch->level;
fight.c:    for ( obj = ch->carrying; obj != NULL; obj = obj_next )
fight.c:                        obj_to_room(in,ch->in_room);
fight.c:          obj_to_room(obj,ch->in_room);
fight.c:    obj_to_room( corpse, ch->in_room );
fight.c:	if (ch->material == 0)
fight.c:	if (IS_SET(ch->parts,PART_GUTS))
fight.c:	if (IS_SET(ch->parts,PART_HEAD))
fight.c:	if (IS_SET(ch->parts,PART_HEART))
fight.c:	if (IS_SET(ch->parts,PART_ARMS))
fight.c:	if (IS_SET(ch->parts,PART_LEGS))
fight.c:	if (IS_SET(ch->parts,PART_BRAINS))
fight.c:	name		= IS_NPC(ch) ? ch->short_descr : ch->name;
fight.c:	    if (IS_SET(ch->form,FORM_POISON))
fight.c:	    else if (!IS_SET(ch->form,FORM_EDIBLE))
fight.c:	obj_to_room( obj, ch->in_room );
fight.c:    was_in_room = ch->in_room;
fight.c:	    ch->in_room = pexit->u1.to_room;
fight.c:    ch->in_room = was_in_room;
fight.c:  for (tmp_ch = char_list; tmp_ch != NULL; tmp_ch = tmp_ch->next)
fight.c:    if (tmp_ch->last_fought == victim)
fight.c:      tmp_ch->last_fought = NULL;
fight.c:    if ( IS_SET ( ch->in_room->room_flags, ROOM_ARENA ) )
fight.c:        if (IS_SET(ch->act, PLR_QUESTOR) && IS_NPC(victim))
fight.c:        {if (ch->questmob == victim->pIndexData->vnum)
fight.c:                ch->questmob = -1;
fight.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
fight.c:	    group_levels += gch->level;
fight.c:   for (lch = ch->in_room->people; lch != NULL; lch = lch->next_in_room)
fight.c:        if (lch->level > highestlevel)            
fight.c:		highestlevel = lch->level;
fight.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
fight.c:	if ( gch->level - highestlevel <= -8 )    {
fight.c:	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
fight.c:		obj_to_room( obj, ch->in_room );
fight.c:  level_range = victim->level - gch->level;
fight.c:    xp = xp * gch->level/total_levels;
fight.c:    if(gch->level < 11 ) 
fight.c:    else if(gch->level < 21 )
fight.c:    else if(gch->level < 31 )
fight.c:    else if(gch->level < 50 )
fight.c:    else if(gch->level < 70)
fight.c:    else if(gch->level < 76 )
fight.c:    else if(gch->level >= 77 )
fight.c:   if(!IS_SET(gch->quest, QUEST_WEAPONSMITH ) && gch->level >= 40) {
fight.c:   if(!IS_SET(gch->quest, QUEST_GOLEM ) && gch->level >= 60) {
fight.c: if (!str_cmp (gch->name, "Asmodai")) {
fight.c:	sprintf( buf2, "You %s yourself%c%s",vs,punct,(IS_SET(ch->act,PLR_AUTODAMAGE) ? buf4 : ""));
fight.c:	sprintf( buf5, "%s %s %s",ch->name,vp,victim->name);
fight.c:        sprintf( buf2, "You %s $N%c%s", vs, punct,(IS_SET(ch->act,PLR_AUTODAMAGE) ? buf4 : "" ));
fight.c:	IS_SET(ch->act,PLR_AUTODAMAGE))? buf4 : "" ));
fight.c:        sprintf( buf5, "%s %s %s",ch->name,vp,victim->name);
fight.c:		sprintf(buf5,"%s is unaffected by %s.",ch->name,attack);
fight.c:		sprintf(buf5,"%s is unaffected by %s's %s!",victim->name,ch->name,attack);
fight.c:                sprintf( buf2, "Your %s %s you%c%s",attack,vp,punct,(IS_SET(ch->act,PLR_AUTODAMAGE) ? buf4 : "" ));
fight.c:                sprintf( buf5, "%s's %s %s %s",ch->name,attack,vp,victim->name);
fight.c:         sprintf( buf1, "$n's %s %s $N%c%s",  attack, vp, punct,(IS_SET(ch->act,PLR_AUTODAMAGE) ? buf4 : "" ) );
fight.c:                sprintf( buf2, "Your %s %s $N%c%s",  attack, vp, punct,(IS_SET(ch->act,PLR_AUTODAMAGE) ? buf4 : "" ));
fight.c:		IS_SET(ch->act,PLR_AUTODAMAGE))? buf4 : "" ));
fight.c:                sprintf( buf5, "%s's %s %s %s",ch->name,attack,vp,victim->name);
fight.c:    if ( (mob = ch->fighting) == NULL )
fight.c:    ||  (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_BERSERK))
fight.c:    &&   ch->level < skill_table[gsn_berserk].skill_level[ch->class]))
fight.c:    if (ch->mana < 50)
fight.c:    if (ch->position == POS_FIGHTING)
fight.c:    hp_percent = 100 * ch->hit/ch->max_hit;
fight.c:	ch->mana -= 50;
fight.c:	ch->move /= 2;
fight.c:	ch->hit += ch->level * 2;
fight.c:	ch->hit = UMIN(ch->hit,ch->max_hit);
fight.c:	af.level	= ch->level;
fight.c:	af.duration	= number_fuzzy(ch->level / 8);
fight.c:	af.modifier	= UMAX(1,ch->level/5);
fight.c:	af.modifier	= UMAX(10,10 * (ch->level/5));
fight.c:	ch->mana -= 25;
fight.c:	ch->move /= 2;
fight.c:    if (ch->fighting != NULL)
fight.c:    ||	 (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_BASH))
fight.c:    &&	  ch->level < skill_table[gsn_bash].skill_level[ch->class]))
fight.c:	victim = ch->fighting;
fight.c:    if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
fight.c:    chance += ch->carry_weight / 25;
fight.c:    if (ch->size < victim->size)
fight.c:	chance += (ch->size - victim->size) * 25;
fight.c:	chance += (ch->size - victim->size) * 10;
fight.c:    if (IS_SET(ch->off_flags,OFF_FAST))
fight.c:    chance += (ch->level - victim->level) * 2;
fight.c:	damage(ch,victim,number_range(4,4 + 2 * ch->size + chance/10),gsn_bash,
fight.c:	ch->position = POS_RESTING;
fight.c:		ch->doppel->name : ch->name);
fight.c:    if (ch->fighting != NULL)
fight.c:    ||   (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_KICK_DIRT))
fight.c:    &&    ch->level < skill_table[gsn_dirt].skill_level[ch->class]))
fight.c:	victim = ch->fighting;
fight.c:    if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
fight.c:    if (IS_SET(ch->off_flags,OFF_FAST) || IS_AFFECTED(ch,AFF_HASTE))
fight.c:    chance += (ch->level - victim->level) * 2;
fight.c:    switch(ch->in_room->sector_type)
fight.c:	af.level 	= ch->level;
fight.c:		gsn_doppelganger) && !IS_IMMORTAL(victim)) ? ch->doppel->name
fight.c:		: ch->name);
fight.c:    if (ch->fighting != NULL)
fight.c:    ||   (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_TRIP) &&
fight.c:	ch->master != NULL)
fight.c:	  && ch->level < skill_table[gsn_trip].skill_level[ch->class]))
fight.c:	victim = ch->fighting;
fight.c:    if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
fight.c:    if (ch->size < victim->size)
fight.c:        chance += (ch->size - victim->size) * 10;  /* bigger = harder to trip */
fight.c:    if (IS_SET(ch->off_flags,OFF_FAST) || IS_AFFECTED(ch,AFF_HASTE))
fight.c:    chance += (ch->level - victim->level) * 2;
fight.c:		ch->doppel->name : ch->name);
fight.c:    if ( ch->position == POS_FIGHTING)
fight.c:      if (victim == ch->fighting)
fight.c:	  ch->fighting = victim;
fight.c:    if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
fight.c:    if (IS_AFFECTED(ch,AFF_CHARM) || (IS_NPC(ch) && IS_SET(ch->act,ACT_PET)))
fight.c:    if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
fight.c:    if ( ch->position == POS_FIGHTING )
fight.c:	  sprintf(buf, "Help! I am being attacked by %s!{x",ch->short_descr);
fight.c:		  ch->doppel->name : ch->name );
fight.c:	if (ch->master != NULL && IS_NPC(ch))
fight.c:    &&   ch->level < skill_table[gsn_backstab].skill_level[ch->class] )
fight.c:	ch->kingdom != KINGDOM_CRESCENT))
fight.c:    ||   number_percent( ) < ch->pcdata->learned[gsn_backstab] )
fight.c:	    number_percent( ) < (ch->pcdata->learned[gsn_dual_backstab]))
fight.c:		ch->doppel->name : ch->name );
fight.c:    free_string( ch->pcdata->title );ch->pcdata->title = str_dup( buf );}
fight.c:	if (ch->master != NULL && IS_NPC(ch))
fight.c:    &&   ch->level < skill_table[gsn_cleave].skill_level[ch->class] )
fight.c:    ||   number_percent( ) < ch->pcdata->learned[gsn_cleave] )
fight.c:		ch->doppel->name : ch->name );
fight.c:    free_string( ch->pcdata->title );ch->pcdata->title = str_dup( buf );}
fight.c:         ch->level < skill_table[gsn_ambush].skill_level[ch->class] )
fight.c:    ||   number_percent( ) < ch->pcdata->learned[gsn_ambush] )
fight.c:		    ch->doppel->name : ch->name );
fight.c:    free_string( ch->pcdata->title );ch->pcdata->title = str_dup( buf );}
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:        if ( ch->position == POS_FIGHTING )
fight.c:            ch->position = POS_STANDING;
fight.c:    was_in = ch->in_room;
fight.c:	if ( ( now_in = ch->in_room ) == was_in )
fight.c:	ch->in_room = was_in;
fight.c:	ch->in_room = now_in;
fight.c:	 if ( ch->exp > exp_per_level(ch,ch->pcdata->points)      
fight.c:                          * ch->level )
fight.c:	  ch->last_fought = NULL;  /* Once fled, the mob will not go after */
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:        if ( ch->position == POS_FIGHTING )
fight.c:            ch->position = POS_STANDING;
fight.c:    was_in = ch->in_room;
fight.c:	if ( ( now_in = ch->in_room ) == was_in )
fight.c:	ch->in_room = was_in;
fight.c:	ch->in_room = now_in;
fight.c:	 if ( ch->exp > exp_per_level(ch,ch->pcdata->points)      
fight.c:                          * ch->level )
fight.c:	  ch->last_fought = NULL;  /* Once fled, the mob will not go after */
fight.c:    if ( ch->fighting == victim )
fight.c:    if (IS_NPC(ch) && ch->master != NULL && IS_NPC(victim))
fight.c:    if (ch->master != NULL)
fight.c:	if (is_safe(ch->master, fch)) return;
fight.c:    if ( !IS_NPC(ch) && number_percent( ) > ch->pcdata->learned[gsn_rescue] )
fight.c:    &&   ch->level < skill_table[gsn_kick].skill_level[ch->class] )
fight.c:    if (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_KICK))
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:    if ( IS_NPC(ch) || number_percent( ) < ch->pcdata->learned[gsn_kick] )
fight.c:	damage( ch,victim,number_range(1,1.5 * ch->level),gsn_kick,DAM_BASH, TRUE
fight.c:    ||   ch->level < skill_table[gsn_circle].skill_level[ch->class] )
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:    for (person = ch->in_room->people;person != NULL;
fight.c:    if ( IS_NPC(ch) || number_percent( ) < ch->pcdata->learned[gsn_circle] )
fight.c:	if (ch->master != NULL && IS_NPC(ch))
fight.c:    ||    (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_DISARM))))
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:    chance += (ch->level - victim->level) * 2;
fight.c:  if (ch->level < skill_table[gsn_nerve].skill_level[ch->class] )
fight.c:  if (ch->fighting == NULL)
fight.c:  victim = ch->fighting;
fight.c:      number_percent() < (ch->pcdata->learned[gsn_nerve] + ch->level
fight.c:      af.level 	= ch->level;
fight.c:      af.duration = ch->level * PULSE_VIOLENCE/PULSE_TICK;
fight.c:		  ch->doppel->name : ch->name );
fight.c:  if ( ch->level < skill_table[gsn_endure].skill_level[ch->class] ||
fight.c:       ch->pcdata->learned[gsn_endure] <= 1 )
fight.c:  af.level 	= ch->level;
fight.c:  af.duration = ch->level / 4;
fight.c:  af.modifier = -1 * (ch->pcdata->learned[gsn_endure] / 10);
fight.c:  if (number_percent() < ch->pcdata->learned[gsn_tame] + 15
fight.c:                         + 4*(ch->level - victim->level))
fight.c:	if (ch->master != NULL && IS_NPC(ch))
fight.c:    &&   ch->level < skill_table[gsn_assassinate].skill_level[ch->class] )
fight.c:	||   number_percent( ) < ch->pcdata->learned[gsn_assassinate])
fight.c:		    ch->doppel->name : ch->name );
fight.c:  CHAR_DATA *victim = ch->fighting;
fight.c:  if (IS_NPC(ch) || ch->pcdata->learned[gsn_caltraps] < 1)
fight.c:  if (!IS_NPC(ch) && number_percent() >= ch->pcdata->learned[gsn_caltraps])
fight.c:  damage(ch,victim,ch->level,gsn_caltraps,DAM_PIERCE, TRUE);
fight.c:      tohit.level     = ch->level;
fight.c:      todam.level = ch->level;
fight.c:      todex.level = ch->level;
fight.c:         ch->level < skill_table[gsn_throw].skill_level[ch->class] )
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:    if ( IS_NPC(ch) || number_percent( ) < ch->pcdata->learned[gsn_throw] )
fight.c:      damage( ch, victim,ch->level + get_curr_stat(ch,STAT_STR),
fight.c:	 ch->level < skill_table[gsn_strangle].skill_level[ch->class] )
fight.c:    ch->last_fight_time = current_time;
fight.c:    if(ch->kingdom != KINGDOM_KUJIKIRI)
fight.c:	number_percent() < 0.4 * (ch->pcdata->learned[gsn_strangle]+bonus))
fight.c:	number_percent() < 0.5 * (ch->pcdata->learned[gsn_strangle]+bonus))	
fight.c:	af.level = ch->level;
fight.c:		    ch->doppel->name : ch->name );
fight.c:	 ch->level < skill_table[gsn_blackjack].skill_level[ch->class] )
fight.c:    ch->last_fight_time = current_time;
fight.c:/*    chance = 0.4 * ch->pcdata->learned[gsn_blackjack]; */
fight.c:      chance = 0.7 * ch->pcdata->learned[gsn_blackjack];
fight.c:  if(ch->kingdom != KINGDOM_KUJIKIRI)
fight.c:	af.level = ch->level;
fight.c:		    ch->doppel->name : ch->name );
fight.c:    free_string( ch->pcdata->title );ch->pcdata->title = str_dup( buf );}
fight.c:        && ch->level < skill_table[gsn_whirlwind].skill_level[ch->class] )
fight.c:   for ( pChar = ch->in_room->people; pChar; pChar = pChar_next )
fight.c:      ch->position = POS_STUNNED;
fight.c:	 && ch->level < skill_table[gsn_bloodthirst].skill_level[ch->class]))
fight.c:    if (ch->fighting == NULL)
fight.c:    hp_percent = 100 * ch->hit/ch->max_hit;
fight.c:        af.level        = ch->level;
fight.c:        af.duration     = ch->level / 4;
fight.c:        af.modifier     = UMIN(15,ch->level/2);
fight.c:	af.modifier	= - UMIN(ch->level - 5,35);
fight.c:  if (ch->level < skill_table[gsn_spellbane].skill_level[ch->class] )
fight.c:  if (ch->mana < 50)
fight.c:  if (!IS_NPC(ch) && number_percent() < ch->pcdata->learned[gsn_spellbane])
fight.c:      af.level 	= ch->level;
fight.c:      af.duration = ch->level+5;
fight.c:      af.modifier = -ch->level/4;
fight.c:      ch->mana -= 50;
fight.c:      ch->mana -= 25;
fight.c:  if (ch->level < skill_table[gsn_resistance].skill_level[ch->class] )
fight.c:  if (ch->mana < 50)
fight.c:  if (!IS_NPC(ch) && number_percent() < ch->pcdata->learned[gsn_resistance])
fight.c:      af.level 	= ch->level;
fight.c:      af.duration = ch->level / 6;
fight.c:      ch->mana -= 50;
fight.c:      ch->mana -= 25;
fight.c:  if (IS_NPC(ch) || ch->level < skill_table[gsn_stronghold].skill_level[ch->class] )
fight.c:  if (ch->move < 50)
fight.c:  if (IS_NPC(ch) || ch->level < skill_table[gsn_trophy].skill_level[ch->class] )
fight.c:  if (ch->mana < 30)
fight.c:  if (!IS_NPC(ch) && number_percent() < ch->pcdata->learned[gsn_trophy])
fight.c:      af.level	= ch->level;
fight.c:      af.duration	= ch->level;
fight.c:	  trophy->timer = ch->level * 2;
fight.c:	  ch->mana -= 30;
fight.c:	  af.modifier  = ch->level / 5;
fight.c:	  af.modifier  = ch->level / 5;
fight.c:	  trophy->value[0] = ch->level;
fight.c:	  trophy->value[1] = ch->level;
fight.c:	  trophy->value[2] = ch->level;
fight.c:	  trophy->value[3] = ch->level;
fight.c:      ch->mana -= 15;
fight.c:        ch->level < skill_table[gsn_truesight].skill_level[ch->class] )
fight.c:  if (ch->mana < 50)
fight.c:  if (!IS_NPC(ch) && number_percent() < ch->pcdata->learned[gsn_truesight])
fight.c:      af.level 	= ch->level;
fight.c:      af.duration = ch->level;
fight.c:      ch->mana -= 50;
fight.c:      ch->mana -= 25;
fight.c:      ch->level < skill_table[gsn_vanish].skill_level[ch->class] )
fight.c:  if (ch->mana < 25)
fight.c:  if (number_percent() > ch->pcdata->learned[gsn_vanish])
fight.c:  if ( ch->in_room == NULL
fight.c:      ||   IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL))
fight.c:	    && ch->in_room->area == pRoomIndex->area)
fight.c:  if (!IS_NPC(ch) && ch->fighting != NULL && number_bits(1) == 1) {
fight.c:      ch->level < skill_table[gsn_warcry].skill_level[ch->class] )
fight.c:  if (ch->mana < 30)
fight.c:  if (number_percent() > ch->pcdata->learned[gsn_warcry])
fight.c:  ch->mana -= 30;
fight.c:  af.level	 = ch->level;
fight.c:  af.duration  = 6+ch->level;
fight.c:  af.modifier  = ch->level / 8;
fight.c:  af.modifier  = 0 - ch->level / 8;
fight.c:      ch->level < skill_table[gsn_barkskin].skill_level[ch->class] )
fight.c:  if (number_percent() > ch->pcdata->learned[gsn_barkskin])
fight.c:  ch->mana -= 40;
fight.c:    af.level     = ch->level;
fight.c:    af.duration  = ch->level;
fight.c:    af.modifier  = -(ch->level * 1.5);
fight.c:  if (IS_NPC(ch) || ch->pcdata->learned[gsn_guard] < 40 ||
fight.c:        ch->level < skill_table[gsn_guard].skill_level[ch->class] )
fight.c:	if (ch->guarding == NULL)
fight.c:      act("{cYou stop guarding $N.{x", ch, NULL, ch->guarding, TO_CHAR);
fight.c:      act("{c$n stops guarding you.{x", ch, NULL, ch->guarding, TO_VICT);
fight.c:      act("{c$n stops guarding $N.{x", ch, NULL, ch->guarding, TO_NOTVICT);
fight.c:      ch->guarding->guarded_by = NULL;
fight.c:      ch->guarding             = NULL;
fight.c:  if (ch->guarding == victim)
fight.c:  if (ch->guarding != NULL)
fight.c:  if (ch->fighting != NULL)
fight.c:  ch->guarding = victim;
fight.c:  if (ch->guarded_by == NULL ||
fight.c:      get_char_room(ch,ch->guarded_by->name) == NULL)
fight.c:      chance = (get_skill(ch->guarded_by,gsn_guard) -
fight.c:		(1.5 * (ch->level - mob->level)));
fight.c:	  act("{c$n jumps in front of $N!{x",ch->guarded_by,NULL,ch,TO_NOTVICT);
fight.c:	  act("{c$n jumps in front of you!{x",ch->guarded_by,NULL,ch,TO_VICT);
fight.c:	  act("{cYou jump in front of $N!{x",ch->guarded_by,NULL,ch,TO_CHAR);
fight.c:	  check_improve(ch->guarded_by,gsn_guard,TRUE,3);
fight.c:	  return ch->guarded_by;
fight.c:	  check_improve(ch->guarded_by, gsn_guard, FALSE, 3);
fight.c:    if (ch->fighting != NULL)
fight.c:    ||	 (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_BASH))
fight.c:    &&	  ch->level < skill_table[gsn_shieldbash].skill_level[ch->class]))
fight.c:	victim = ch->fighting;
fight.c:    if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
fight.c:    chance += ch->carry_weight / 25;
fight.c:    if (ch->size < victim->size)
fight.c:	chance += (ch->size - victim->size) * 25;
fight.c:	chance += (ch->size - victim->size) * 10;
fight.c:    if (IS_SET(ch->off_flags,OFF_FAST))
fight.c:    chance += (ch->level - victim->level) * 2;
fight.c:	damage(ch,victim,number_range(4,4 + 4 * ch->size + chance/10),gsn_shieldbash,
fight.c:	ch->position = POS_RESTING;
fight.c:		ch->doppel->name : ch->name);
fight.c:    || ch->level < skill_table[gsn_blindness_dust].skill_level[ch->class])
fight.c:    if (ch->position < skill_table[gsn_blindness_dust].minimum_position)
fight.c:    if (ch->mana < 20)
fight.c:    if (number_percent() > ch->pcdata->learned[gsn_blindness_dust])
fight.c:	ch->mana -= 10;
fight.c:	for (tmp_vict = ch->in_room->people; tmp_vict != NULL;
fight.c:		if (!IS_NPC(ch) && tmp_vict != ch && ch->fighting != tmp_vict
fight.c:			&& !IS_IMMORTAL(tmp_vict)) ? ch->doppel->name :
fight.c:			ch->name);
fight.c:		    spell_blindness(gsn_blindness, ch->level, ch,
fight.c:	ch->mana -= 20;
fight.c:    || ch->level < skill_table[gsn_poison_smoke].skill_level[ch->class])
fight.c:    if (ch->position < skill_table[gsn_poison_smoke].minimum_position)
fight.c:    if (ch->mana < 20)
fight.c:    if (number_percent() > ch->pcdata->learned[gsn_poison_smoke])
fight.c:	ch->mana -= 10;
fight.c:	for (tmp_vict = ch->in_room->people; tmp_vict != NULL;
fight.c:		if (!IS_NPC(ch) && tmp_vict != ch && ch->fighting != tmp_vict
fight.c:			&& !IS_IMMORTAL(tmp_vict)) ? ch->doppel->name :
fight.c:			ch->name);
fight.c:		    spell_poison(gsn_poison, ch->level, ch,
fight.c:	ch->mana -= 20;
fight.c:    && ch->level < skill_table[gsn_charge].skill_level[ch->class])
fight.c:	victim = ch->fighting;
fight.c:    dam = number_range(10, ch->level * 3);
fight.c:      && number_percent() > ( (ch->hit * 100) / ch->max_hit ) )
fight.c:  if ( !IS_NPC(ch) && /* IS_SET( ch->off_flags, OFF_CRIT ) ) ||*/
fight.c:      diceroll += ( victim->level - ch->level ) * 2;
fight.c:      diceroll -= ( ch->level - victim->level );
fight.c:    if ( (IS_NPC(ch) && (diceroll <= (ch->level / 13))) ||
fight.c:          baf.level = ch->level;
fight.c:         && ch->level < skill_table[gsn_bandage].skill_level[ch->class]))
fight.c:        heal = dice(4, 8) + ch->level / 2;
fight.c:        ch->hit = UMIN( ch->hit + heal, ch->max_hit );
fight.c:        af.level        = ch->level;
fight.c:        af.duration     = ch->level / 10;
fight.c:        af.modifier     = UMIN(15,ch->level/2);
fight.c:  CHAR_DATA *victim = ch->fighting;
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:  if ( ch->mana < cost && ch->level < LEVEL_IMMORTAL )
fight.c:                                        URANGE( 1, ch->level, 141 ),
fight.c:  if ( victim->position != POS_DEAD && ch->in_room == victim->in_room )
fight.c:                                        URANGE( 1, ch->level, 141 ),
fight.c:  if ( ch->level < LEVEL_IMMORTAL )
fight.c:        ch->mana -= cost;
handler.c:	if (IS_SET(ch->off_flags,ASSIST_PLAYERS))
handler.c:	else if ( (IS_SET(ch->off_flags,ASSIST_CLAN))
handler.c:		 && ((ch->pIndexData->vnum-100)/10)==victim->kingdom )
handler.c:    if (IS_SET(ch->off_flags,ASSIST_ALL))
handler.c:    if (ch->group && ch->group == victim->group)
handler.c:    if (IS_SET(ch->off_flags,ASSIST_VNUM) 
handler.c:    &&  ch->pIndexData == victim->pIndexData)
handler.c:    if (IS_SET(ch->off_flags,ASSIST_RACE) && ch->race == victim->race)
handler.c:    if (IS_SET(ch->off_flags,ASSIST_ALIGN)
handler.c:    &&  !IS_SET(ch->act,ACT_NOALIGN) && !IS_SET(victim->act,ACT_NOALIGN)
handler.c:    for (fch = obj->in_room->people; fch != NULL; fch = fch->next_in_room)
handler.c:	if (fch->on == obj)
handler.c:  if ((ch->kingdom != skill_table[sn].kingdom)
handler.c:	ch->pcdata->learned[sn] = 0; 
handler.c:    if (kingdom_table[ch->kingdom].obj_ptr->in_room->vnum !=
handler.c:          kingdom_table[ch->kingdom].room_vnum) {
handler.c:  if ( ((ch->kingdom != skill_table[sn].kingdom)
handler.c:      kingdom_table[ch->kingdom].obj_ptr != NULL) &&
handler.c:   (kingdom_table[ch->kingdom].obj_ptr->carried_by == NULL && 
handler.c:   kingdom_table[ch->kingdom].obj_ptr->carried_by->in_room == NULL) &&
handler.c:   (kingdom_table[ch->kingdom].obj_ptr->in_obj == NULL &&
handler.c:    kingdom_table[ch->kingdom].obj_ptr->in_obj->in_room == NULL) &&
handler.c:      kingdom_table[ch->kingdom].obj_ptr->in_room != NULL &&
handler.c:	(kingdom_table[ch->kingdom].obj_ptr->in_room->vnum !=
handler.c:          kingdom_table[ch->kingdom].room_vnum))) */{
handler.c:	if (IS_SET(ch->imm_flags,IMM_WEAPON))
handler.c:	else if (IS_SET(ch->res_flags,RES_WEAPON))
handler.c:	else if (IS_SET(ch->vuln_flags,VULN_WEAPON))
handler.c:	if (IS_SET(ch->imm_flags,IMM_MAGIC))
handler.c:	else if (IS_SET(ch->res_flags,RES_MAGIC))
handler.c:	else if (IS_SET(ch->vuln_flags,VULN_MAGIC))
handler.c:    if (IS_SET(ch->imm_flags,bit))
handler.c:    else if (IS_SET(ch->res_flags,bit) && immune != IS_IMMUNE)
handler.c:    else if (IS_SET(ch->vuln_flags,bit))
handler.c:    if (ch->pIndexData == NULL)
handler.c:    else if (ch->pIndexData->new_format)
handler.c:	skill = ch->level * 5 / 2;
handler.c:	if (ch->level < skill_table[sn].skill_level[ch->class])
handler.c:	    skill = ch->pcdata->learned[sn];
handler.c:	    skill = 40 + 2 * ch->level;
handler.c:	    skill = ch->level * 2 + 20;
handler.c:        else if ((sn == gsn_dodge && IS_SET(ch->off_flags,OFF_DODGE))
handler.c: 	||       (sn == gsn_parry && IS_SET(ch->off_flags,OFF_PARRY)))
handler.c:	    skill = ch->level * 2;
handler.c:	    skill = 10 + 2 * ch->level;
handler.c:	&& (IS_SET(ch->act,ACT_WARRIOR) || IS_SET(ch->act,ACT_THIEF)))
handler.c:	    skill = 10 + 4 * ch->level;
handler.c:	&& (IS_SET(ch->act,ACT_WARRIOR) || IS_SET(ch->act,ACT_THIEF)))
handler.c:	    skill = 10 + 3 * ch->level;
handler.c:	else if (sn == gsn_third_attack && IS_SET(ch->act,ACT_WARRIOR))
handler.c:	    skill = 4 * ch->level - 40;
handler.c:	    skill = 40 + 2 * ch->level;
handler.c: 	else if (sn == gsn_trip && IS_SET(ch->off_flags,OFF_TRIP))
handler.c:	    skill = 10 + 3 * ch->level;
handler.c: 	else if (sn == gsn_bash && IS_SET(ch->off_flags,OFF_BASH))
handler.c:	    skill = 10 + 3 * ch->level;
handler.c: 	else if (sn == gsn_shieldbash && IS_SET(ch->off_flags,OFF_BASH))
handler.c:	    skill = 10 + 3 * ch->level;
handler.c:	     &&  (IS_SET(ch->off_flags,OFF_DISARM) 
handler.c:	     ||   IS_SET(ch->act,ACT_WARRIOR)
handler.c:	     ||	  IS_SET(ch->act,ACT_THIEF)))
handler.c:	    skill = 20 + 3 * ch->level;
handler.c:	else if (sn == gsn_berserk && IS_SET(ch->off_flags,OFF_BERSERK))
handler.c:	    skill = 3 * ch->level;
handler.c:	    skill = 10 + 3 * ch->level;
handler.c:	else if (sn == gsn_backstab && IS_SET(ch->act,ACT_THIEF))
handler.c:	    skill = 20 + 2 * ch->level;
handler.c:	    skill = 40 + ch->level; 
handler.c:	    skill = 40 + ch->level;
handler.c:	    skill = 40 + 5 * ch->level / 2;
handler.c:    if (ch->daze > 0)
handler.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK]  > 10 )
handler.c:	    skill = 3 * ch->level;
handler.c:	    skill = 40 + 2 * ch->level;
handler.c:	    skill = 40 + 5 * ch->level / 2;
handler.c:	    skill = 3 * ch->level;
handler.c:	    skill = ch->pcdata->learned[sn];
handler.c:    if (ch->pcdata->perm_hit == 0 
handler.c:    ||	ch->pcdata->perm_mana == 0
handler.c:    ||  ch->pcdata->perm_move == 0
handler.c:    ||	ch->pcdata->last_level == 0)
handler.c:		    case APPLY_SEX:	ch->sex		-= mod;
handler.c:					if (ch->sex < 0 || ch->sex >2)
handler.c:					    ch->sex = IS_NPC(ch) ?
handler.c:						ch->pcdata->true_sex;
handler.c:		    case APPLY_MANA:	ch->max_mana	-= mod;		break;
handler.c:		    case APPLY_HIT:	ch->max_hit	-= mod;		break;
handler.c:		    case APPLY_MOVE:	ch->max_move	-= mod;		break;
handler.c:                    case APPLY_SEX:     ch->sex         -= mod;         break;
handler.c:                    case APPLY_MANA:    ch->max_mana    -= mod;         break;
handler.c:                    case APPLY_HIT:     ch->max_hit     -= mod;         break;
handler.c:                    case APPLY_MOVE:    ch->max_move    -= mod;         break;
handler.c:	ch->pcdata->perm_hit 	= ch->max_hit;
handler.c:	ch->pcdata->perm_mana 	= ch->max_mana;
handler.c:	ch->pcdata->perm_move	= ch->max_move;
handler.c:	ch->pcdata->last_level	= ch->played/3600;
handler.c:	if (ch->pcdata->true_sex < 0 || ch->pcdata->true_sex > 2)
handler.c:		if (ch->sex > 0 && ch->sex < 3)
handler.c:	    	    ch->pcdata->true_sex	= ch->sex;
handler.c:		    ch->pcdata->true_sex 	= 0;
handler.c:	ch->mod_stat[stat] = 0;
handler.c:    if (ch->pcdata->true_sex < 0 || ch->pcdata->true_sex > 2)
handler.c:	ch->pcdata->true_sex = 0; 
handler.c:    ch->sex		= ch->pcdata->true_sex;
handler.c:    ch->max_hit 	= ch->pcdata->perm_hit;
handler.c:    ch->max_mana	= ch->pcdata->perm_mana;
handler.c:    ch->max_move	= ch->pcdata->perm_move;
handler.c:    	ch->armor[i]	= 100;
handler.c:    ch->hitroll		= 0;
handler.c:    ch->damroll		= 0;
handler.c:    ch->saving_throw	= 0;
handler.c:	    ch->armor[i] -= apply_ac( obj, loc, i );
handler.c:		case APPLY_STR:		ch->mod_stat[STAT_STR]	+= mod;	break;
handler.c:		case APPLY_DEX:		ch->mod_stat[STAT_DEX]	+= mod; break;
handler.c:		case APPLY_INT:		ch->mod_stat[STAT_INT]	+= mod; break;
handler.c:		case APPLY_WIS:		ch->mod_stat[STAT_WIS]	+= mod; break;
handler.c:		case APPLY_CON:		ch->mod_stat[STAT_CON]	+= mod; break;
handler.c:		case APPLY_SEX:		ch->sex			+= mod; break;
handler.c:		case APPLY_MANA:	ch->max_mana		+= mod; break;
handler.c:		case APPLY_HIT:		ch->max_hit		+= mod; break;
handler.c:		case APPLY_MOVE:	ch->max_move		+= mod; break;
handler.c:			ch->armor[i] += mod; 
handler.c:		case APPLY_HITROLL:	ch->hitroll		+= mod; break;
handler.c:		case APPLY_DAMROLL:	ch->damroll		+= mod; break;
handler.c:		case APPLY_SAVES:		ch->saving_throw += mod; break;
handler.c:		case APPLY_SAVING_ROD: 		ch->saving_throw += mod; break;
handler.c:		case APPLY_SAVING_PETRI:	ch->saving_throw += mod; break;
handler.c:		case APPLY_SAVING_BREATH: 	ch->saving_throw += mod; break;
handler.c:		case APPLY_SAVING_SPELL:	ch->saving_throw += mod; break;
handler.c:                case APPLY_STR:         ch->mod_stat[STAT_STR]  += mod; break;
handler.c:                case APPLY_DEX:         ch->mod_stat[STAT_DEX]  += mod; break;
handler.c:                case APPLY_INT:         ch->mod_stat[STAT_INT]  += mod; break;
handler.c:                case APPLY_WIS:         ch->mod_stat[STAT_WIS]  += mod; break;
handler.c:                case APPLY_CON:         ch->mod_stat[STAT_CON]  += mod; break;
handler.c:                case APPLY_SEX:         ch->sex                 += mod; break;
handler.c:                case APPLY_MANA:        ch->max_mana            += mod; break;
handler.c:                case APPLY_HIT:         ch->max_hit             += mod; break;
handler.c:                case APPLY_MOVE:        ch->max_move            += mod; break;
handler.c:                        ch->armor[i] += mod;
handler.c:		case APPLY_HITROLL:     ch->hitroll             += mod; break;
handler.c:                case APPLY_DAMROLL:     ch->damroll             += mod; break;
handler.c:                case APPLY_SAVES:         ch->saving_throw += mod; break;
handler.c:                case APPLY_SAVING_ROD:          ch->saving_throw += mod; break;
handler.c:                case APPLY_SAVING_PETRI:        ch->saving_throw += mod; break;
handler.c:                case APPLY_SAVING_BREATH:       ch->saving_throw += mod; break;
handler.c:                case APPLY_SAVING_SPELL:        ch->saving_throw += mod; break;
handler.c:    for (af = ch->affected; af != NULL; af = af->next)
handler.c:                case APPLY_STR:         ch->mod_stat[STAT_STR]  += mod; break;
handler.c:                case APPLY_DEX:         ch->mod_stat[STAT_DEX]  += mod; break;
handler.c:                case APPLY_INT:         ch->mod_stat[STAT_INT]  += mod; break;
handler.c:                case APPLY_WIS:         ch->mod_stat[STAT_WIS]  += mod; break;
handler.c:                case APPLY_CON:         ch->mod_stat[STAT_CON]  += mod; break;
handler.c:                case APPLY_SEX:         ch->sex                 += mod; break;
handler.c:                case APPLY_MANA:        ch->max_mana            += mod; break;
handler.c:                case APPLY_HIT:         ch->max_hit             += mod; break;
handler.c:                case APPLY_MOVE:        ch->max_move            += mod; break;
handler.c:                        ch->armor[i] += mod;
handler.c:                case APPLY_HITROLL:     ch->hitroll             += mod; break;
handler.c:                case APPLY_DAMROLL:     ch->damroll             += mod; break;
handler.c:                case APPLY_SAVES:         ch->saving_throw += mod; break;
handler.c:                case APPLY_SAVING_ROD:          ch->saving_throw += mod; break;
handler.c:                case APPLY_SAVING_PETRI:        ch->saving_throw += mod; break;
handler.c:                case APPLY_SAVING_BREATH:       ch->saving_throw += mod; break;
handler.c:                case APPLY_SAVING_SPELL:        ch->saving_throw += mod; break;
handler.c:    if (ch->sex < 0 || ch->sex > 2)
handler.c:	ch->sex = ch->pcdata->true_sex;
handler.c://    if ( ch->desc != NULL && ch->desc->original != NULL )
handler.c://	ch = ch->desc->original;
handler.c:	if(ch->desc && ch->desc->original)
handler.c:	ch = ch->desc->original;
handler.c:    if ( ch->trust != 0 && IS_SET(ch->comm,COMM_TRUE_TRUST))
handler.c:	return ch->trust;
handler.c:    if ( IS_NPC(ch) && ch->level >= LEVEL_HERO )
handler.c:	return ch->level;
handler.c:    return 17 + ( ch->played + (int) (current_time - ch->logon) ) / 72000;
handler.c:    if (IS_NPC(ch) || ch->level > LEVEL_IMMORTAL)
handler.c:	max = pc_race_table[ch->race].max_stats[stat] + 4;
handler.c:	if (class_table[ch->class].attr_prime == stat)
handler.c:	if ( ch->race == race_lookup("human"))
handler.c:    return URANGE(3,ch->perm_stat[stat] + ch->mod_stat[stat], max);
handler.c:    if (IS_NPC(ch) || ch->level > LEVEL_IMMORTAL)
handler.c:    max = pc_race_table[ch->race].max_stats[stat];
handler.c:    if (class_table[ch->class].attr_prime == stat)
handler.c:	if ( ch->race == race_lookup("human"))
handler.c:    if ( !IS_NPC(ch) && ch->level >= LEVEL_IMMORTAL )
handler.c:    if ( IS_NPC(ch) && IS_SET(ch->act, ACT_PET) )
handler.c:    return MAX_WEAR + get_curr_stat(ch,STAT_DEX) - 10 + ch->size;
handler.c:    if ( !IS_NPC(ch) && ch->level >= LEVEL_IMMORTAL )
handler.c:    if ( IS_NPC(ch) && IS_SET(ch->act, ACT_PET) )
handler.c:    return str_app[get_curr_stat(ch,STAT_STR)].carry * 10 + ch->level * 25;
handler.c:	      SET_BIT(ch->affected_by, paf->bitvector);
handler.c:	 SET_BIT(ch->affected_by2, paf->bitvector);
handler.c:	SET_BIT(ch->detection, paf->bitvector);
handler.c:	    SET_BIT(ch->imm_flags,paf->bitvector);
handler.c:	    SET_BIT(ch->res_flags,paf->bitvector);
handler.c:	    SET_BIT(ch->vuln_flags,paf->bitvector);
handler.c:              REMOVE_BIT(ch->affected_by, paf->bitvector);
handler.c:	      REMOVE_BIT(ch->affected_by2, paf->bitvector);
handler.c:		REMOVE_BIT(ch->detection, paf->bitvector);
handler.c:            REMOVE_BIT(ch->imm_flags,paf->bitvector);
handler.c:            REMOVE_BIT(ch->res_flags,paf->bitvector);
handler.c:            REMOVE_BIT(ch->vuln_flags,paf->bitvector);
handler.c:    case APPLY_STR:           ch->mod_stat[STAT_STR]	+= mod;	break;
handler.c:    case APPLY_DEX:           ch->mod_stat[STAT_DEX]	+= mod;	break;
handler.c:    case APPLY_INT:           ch->mod_stat[STAT_INT]	+= mod;	break;
handler.c:    case APPLY_WIS:           ch->mod_stat[STAT_WIS]	+= mod;	break;
handler.c:    case APPLY_CON:           ch->mod_stat[STAT_CON]	+= mod;	break;
handler.c:    case APPLY_SEX:           ch->sex			+= mod;	break;
handler.c:    case APPLY_MANA:          ch->max_mana		+= mod;	break;
handler.c:    case APPLY_HIT:           ch->max_hit		+= mod;	break;
handler.c:    case APPLY_MOVE:          ch->max_move		+= mod;	break;
handler.c:            ch->armor[i] += mod;
handler.c:    case APPLY_HITROLL:       ch->hitroll		+= mod;	break;
handler.c:    case APPLY_DAMROLL:       ch->damroll		+= mod;	break;
handler.c:    case APPLY_SAVES:   ch->saving_throw		+= mod;	break;
handler.c:    case APPLY_SAVING_ROD:    ch->saving_throw		+= mod;	break;
handler.c:    case APPLY_SAVING_PETRI:  ch->saving_throw		+= mod;	break;
handler.c:    case APPLY_SAVING_BREATH: ch->saving_throw		+= mod;	break;
handler.c:    case APPLY_SAVING_SPELL:  ch->saving_throw		+= mod;	break;
handler.c:	    obj_to_room( wield, ch->in_room );
handler.c:    for (paf = ch->affected; paf != NULL; paf = paf->next)
handler.c:		      SET_BIT(ch->affected_by,vector);
handler.c:			SET_BIT(ch->affected_by2, vector);
handler.c:			SET_BIT(ch->detection, vector);
handler.c:		    SET_BIT(ch->imm_flags,vector);   
handler.c:		    SET_BIT(ch->res_flags,vector);
handler.c:		    SET_BIT(ch->vuln_flags,vector);
handler.c:    for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
handler.c:                      SET_BIT(ch->affected_by,vector);
handler.c:		 	SET_BIT(ch->affected_by2,vector);
handler.c:			SET_BIT(ch->detection,vector);
handler.c:                        SET_BIT(ch->imm_flags,vector);
handler.c:                        SET_BIT(ch->res_flags,vector);
handler.c:                        SET_BIT(ch->vuln_flags,vector);
handler.c:                      SET_BIT(ch->affected_by,vector);
handler.c:			SET_BIT(ch->affected_by2,vector);
handler.c:			SET_BIT(ch->detection,vector);
handler.c:                        SET_BIT(ch->imm_flags,vector);
handler.c:                        SET_BIT(ch->res_flags,vector);
handler.c:                        SET_BIT(ch->vuln_flags,vector);
handler.c:    paf_new->next	= ch->affected;
handler.c:    ch->affected	= paf_new;
handler.c:    if ( ch->affected == NULL )
handler.c:    if ( paf == ch->affected )
handler.c:	ch->affected	= paf->next;
handler.c:	for ( prev = ch->affected; prev != NULL; prev = prev->next )
handler.c:    for ( paf = ch->affected; paf != NULL; paf = paf_next )
handler.c:    for ( paf = ch->affected; paf != NULL; paf = paf->next )
handler.c:    for ( paf_old = ch->affected; paf_old != NULL; paf_old = paf_old->next )
handler.c:    ROOM_INDEX_DATA *prev_room = ch->in_room;
handler.c:    if ( ch->in_room == NULL )
handler.c:	--ch->in_room->area->nplayer;
handler.c:    &&   ch->in_room->light > 0 )
handler.c:	--ch->in_room->light;
handler.c:    if ( ch == ch->in_room->people )
handler.c:	ch->in_room->people = ch->next_in_room;
handler.c:	for ( prev = ch->in_room->people; prev; prev = prev->next_in_room )
handler.c:		prev->next_in_room = ch->next_in_room;
handler.c:    ch->in_room      = NULL;
handler.c:    ch->next_in_room = NULL;
handler.c:    ch->on 	     = NULL;  /* sanity check! */
handler.c:     ch->mount->riding  = FALSE;
handler.c:     ch->riding         = FALSE;
handler.c:    ch->in_room		= pRoomIndex;
handler.c:    ch->next_in_room	= pRoomIndex->people;
handler.c:	if (ch->in_room->area->empty)
handler.c:	    ch->in_room->area->empty = FALSE;
handler.c:	    ch->in_room->area->age = 0;
handler.c:	++ch->in_room->area->nplayer;
handler.c:	++ch->in_room->light;
handler.c:        for ( af = ch->affected; af != NULL; af = af->next )
handler.c:            REMOVE_BIT(ch->affected_by,AFF_PLAGUE);
handler.c:        for ( vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
handler.c:     if ( ch->in_room->affected_by )
handler.c:         else raffect_to_char( ch->in_room, ch);
handler.c:    obj->next_content	 = ch->carrying;
handler.c:    ch->carrying	 = obj;
handler.c:    ch->carry_number	+= get_obj_number( obj );
handler.c:    ch->carry_weight	+= get_obj_weight( obj );
handler.c:    if ( ch->carrying == obj )
handler.c:	ch->carrying = obj->next_content;
handler.c:	for ( prev = ch->carrying; prev != NULL; prev = prev->next_content )
handler.c:    ch->carry_number	-= get_obj_number( obj );
handler.c:    ch->carry_weight	-= get_obj_weight( obj );
handler.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
handler.c:	obj_to_room( obj, ch->in_room );
handler.c:    	ch->armor[i]      	-= apply_ac( obj, iWear,i );
handler.c:    &&   ch->in_room != NULL )
handler.c:	++ch->in_room->light;
handler.c:    	ch->armor[i]	+= apply_ac( obj, obj->wear_loc,i );
handler.c:	        for ( lpaf = ch->affected; lpaf != NULL; lpaf = lpaf_next )
handler.c:	    for ( lpaf = ch->affected; lpaf != NULL; lpaf = lpaf_next )
handler.c:    &&   ch->in_room != NULL
handler.c:    &&   ch->in_room->light > 0 )
handler.c:	--ch->in_room->light;
handler.c:    for (ch = in_room->people; ch != NULL; ch = ch->next_in_room)
handler.c:	if (ch->on == obj)
handler.c:	    ch->on = NULL;
handler.c:    if (ch->extracted)  /* if the char has already been extracted once */
handler.c:        sprintf(buf, "Warning! Extraction of %s.", ch->name);
handler.c:      ch->extracted = TRUE;  /* if it hasn't been extracted yet, now
handler.c:    if ( ch->in_room == NULL )
handler.c:    ch->pet = NULL; /* just in case */
handler.c:if ( !IS_SET ( ch->in_room->room_flags, ROOM_ARENA ) )
handler.c:    for ( obj = ch->carrying; obj != NULL; obj = obj_next )
handler.c:        char_to_room(ch, get_room_index(hometown_table[ch->hometown].altar[i]));
handler.c:        ch->pcdata->quest = NULL;
handler.c:	--ch->pIndexData->count;
handler.c: if ( ch->mount && ch->mount->mount == ch )
handler.c:            ch->mount->mount = NULL;
handler.c:            if (ch->mount->riding)
handler.c:                act("You fall off of $N.", ch->mount, NULL, ch, TO_CHAR);
handler.c:                act("$n falls off of $N.", ch->mount, NULL, ch, TO_ROOM);
handler.c:                ch->mount->riding = FALSE;
handler.c:                if (!IS_IMMORTAL(ch->mount))
handler.c:             ch->mount->position = POS_SITTING;
handler.c:    if ( ch->desc != NULL && ch->desc->original != NULL )
handler.c:	ch->desc = NULL;
handler.c:    for ( wch = char_list; wch != NULL; wch = wch->next )
handler.c:	if ( wch->reply == ch )
handler.c:	    wch->reply = NULL;
handler.c:        if ( ch->mprog_target == ch )
handler.c:           wch->mprog_target = NULL;
handler.c:       char_list = ch->next;
handler.c:		prev->next = ch->next;
handler.c:    if ( ch->desc != NULL )
handler.c:	ch->desc->character = NULL;
handler.c:  for (rch=ch->in_room->people;rch!=NULL;rch=rch->next_in_room)
handler.c:  for (rch=ch->in_room->people;rch!=NULL;rch=rch->next_in_room)
handler.c:  for (rch=char_list;rch!=NULL;rch=rch->next)
handler.c:  for (rch=ch->in_room->people;rch!=NULL;rch=rch->next_in_room)
handler.c:    for ( rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room )
handler.c:              && !IS_SET(ch->act,PLR_HOLYLIGHT))?
handler.c:            !is_name(arg,rch->doppel->name):!is_name(arg,rch->name) )
handler.c:              && !IS_SET(ch->act,PLR_HOLYLIGHT))?
handler.c:            !is_name_imm(arg,rch->doppel->name):!is_name_imm(arg,rch->name) )
handler.c:    for ( rch = room->people; rch != NULL; rch = rch->next_in_room )
handler.c:              && !IS_SET(ch->act,PLR_HOLYLIGHT))?
handler.c:        !is_name(argument,rch->doppel->name):!is_name(argument,rch->name))
handler.c:    for ( wch = char_list; wch != NULL ; wch = wch->next )
handler.c:	if ( wch->in_room == NULL || !can_see( ch, wch ) 
handler.c:	||   !is_name( arg, wch->name ))
handler.c:	if ( wch->in_room == NULL || !can_see( ch, wch ) 
handler.c:	||   !is_name_imm( arg, wch->name ))
handler.c:    if ( ch->pcdata )
handler.c:    else if ( ch->desc )
handler.c:      return ch->desc->original;
handler.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
handler.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
handler.c:    obj = get_obj_list( ch, argument, ch->in_room->contents );
handler.c:    silver = UMIN(ch->silver,cost); 
handler.c:    ch->gold -= gold;
handler.c:    ch->silver -= silver;
handler.c:    if (ch->gold < 0)
handler.c:	bug("deduct costs: gold %d < 0",ch->gold);
handler.c:	ch->gold = 0;
handler.c:    if (ch->silver < 0)
handler.c:	bug("deduct costs: silver %d < 0",ch->silver);
handler.c:	ch->silver = 0;
handler.c:    return is_full_name(ch->name,room->owner);
handler.c:    for ( rch = pRoomIndex->people; rch != NULL; rch = rch->next_in_room )
handler.c:    &&  ch->level > 5 && !IS_IMMORTAL(ch))
handler.c:    &&  ch->level > 10 && !IS_IMMORTAL(ch))
handler.c:    if (get_trust(ch) < victim->incog_level && ch->in_room != victim->in_room)
handler.c:    if (((ch->level == 84) && victim->level < 83) && !IS_NPC(victim))
handler.c:    if ( (!IS_NPC(ch) && IS_SET(ch->act, PLR_HOLYLIGHT)) 
handler.c:    if ( ch->in_room == NULL )
handler.c:    if ( room_is_dark( ch->in_room ,ch) && !IS_AFFECTED(ch, AFF_INFRARED) )
handler.c:	chance += ch->level - victim->level * 3/2;
handler.c:    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_HOLYLIGHT) )
handler.c:    if ( room_is_dark( ch->in_room ,ch) && !IS_AFFECTED(ch, AFF_INFRARED) )
handler.c:    if ( !IS_NPC(ch) && ch->level >= LEVEL_IMMORTAL )
handler.c:     for (vch=room->people;vch;vch=vch->next_in_room)
handler.c:  ch->last_fight_time = current_time;
handler.c:    temp = ch->in_room;
handler.c:        room_record(ch->name,temp, opdoor);
healer.c:    for ( mob = ch->in_room->people; mob; mob = mob->next_in_room )
healer.c:    if (cost > (ch->gold * 100 + ch->silver))
healer.c:	ch->mana += dice(2,8) + mob->level / 3;
healer.c:	ch->mana = UMIN(ch->mana,ch->max_mana);
interp.c:    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_FREEZE) )
interp.c:    if (IS_IMMORTAL(ch) && ch->level != MAX_LEVEL)
interp.c:	if (!ch->desc->original) 
interp.c:	 sprintf( file, "../../../logs/%s.log", ch->name);
interp.c: 	 sprintf( file, "../../../logs/%s.log", ch->desc->original->name);
interp.c:         sprintf(buf,"%s :[%s]:%s\n", strtime,ch->name,logline);
interp.c:       if ( ch->desc )
interp.c:           rch = ch->desc->original;
interp.c:              REMOVE_BIT(ch->affected_by, AFF_HIDE);
interp.c:              REMOVE_BIT(ch->affected_by, AFF_FADE);
interp.c:          if (IS_SET(ch->act, PLR_GHOST) && !IS_NPC(ch)
interp.c:    if ( ( ( !IS_NPC(ch) && IS_SET(ch->act, PLR_LOG) )
interp.c:	sprintf( log_buf, "Log %s: %s", ch->name, logline );
interp.c:    if ( ch->desc != NULL && ch->desc->snoop_by != NULL )
interp.c:	write_to_buffer( ch->desc->snoop_by, "% ",    2 );
interp.c:	write_to_buffer( ch->desc->snoop_by, logline, 0 );
interp.c:	write_to_buffer( ch->desc->snoop_by, "\n\r",  2 );
interp.c:    if ( ch->position < cmd_table[cmd].position )
interp.c:	switch( ch->position )
interp.c:    if ( !IS_NPC(ch) && IS_SET(ch->comm, COMM_NOEMOTE) )
interp.c:    switch ( ch->position )
interp.c:      REMOVE_BIT( ch->affected_by, AFF_HIDE );
interp.c: do_sgrant(ch,ch->name);
interp.c:	||  (IS_IMMORTAL(victim) && victim->trust >= ch->trust))
interp.c:    for ( och = ch->in_room->people; och != NULL; och = och_next )
interp.c:	och_next = och->next_in_room;
interp.c:	&&   och->master == ch
interp.c:       (cmd == do_kick) ) && ch->fighting == NULL ) return FALSE;
interp.c:    if ( race_table[ch->race].pc_race ) return(TRUE);
interp.c:    if ( ch->race != 34  &&		/* doll */
interp.c:         ch->race != 35  &&		/* dragon */
interp.c:         ch->race != 38  &&		/* goblin */
interp.c:         ch->race != 39  &&		/* hobgoblin */
interp.c:         ch->race != 40  &&		/* kobolt */
interp.c:         ch->race != 41  &&		/* lizard */
interp.c:         ch->race != 42  &&		/* modron */
interp.c:         ch->race != 43  &&		/* orc */
interp.c:         ch->race != 49  )		/* troll */
interp.c:    if ( IS_SET(ch->act, ACT_THIEF) ) return(TRUE);
interp.c:	(ch->level < 95))
interp.c:    if ( ch->level < victim->level )
interp.c:    if ( ch->level <= victim->level )
interp.c:        p->disabled_by = str_dup (ch->name);
iprog.c:  if ( ch == NULL || ch->fighting == NULL )
iprog.c:  victim = ch->fighting;
iprog.c:	  obj_cast_spell(gsn_acid_blast,ch->level, ch, victim, obj);
iprog.c:	  obj_cast_spell(gsn_cure_serious,ch->level, ch, ch, obj );
iprog.c:	  obj_cast_spell(gsn_cure_serious,ch->level, ch, ch, obj );
iprog.c:	  obj_cast_spell(gsn_cure_critical,ch->level, ch, ch, obj );
iprog.c:	  obj_cast_spell(gsn_cure_critical,ch->level, ch, ch, obj );
iprog.c:      af.level = ch->level;
iprog.c:      af.modifier = 1 + (ch->level >= 18) + (ch->level >= 30) + (ch->level >= 45);
iprog.c:  ch->hit = ch->max_hit;
iprog.c:      && (ch->fighting) && (get_eq_char(ch,WEAR_WIELD) == obj))
iprog.c:      obj_cast_spell(gsn_acid_blast,ch->level,ch,ch->fighting,NULL);
iprog.c:	 (ch->hit - 1) > 1000? 1000 : (ch->hit - 1),
iprog.c:  ch->gold = 0;
iprog.c:/*  ch->siver = 0; */
iprog.c:      obj_cast_spell(gsn_cure_critical,ch->level,ch,ch,obj);
iprog.c:      if ( ((float) ch->hit)/((float) ch->max_hit) > 0.9)
iprog.c:      else if ( ((float) ch->hit)/((float) ch->max_hit) > 0.6)
iprog.c:      else if ( ((float) ch->hit)/((float) ch->max_hit) > 0.4)
iprog.c:  if ( strstr( obj->extra_descr->description, ch->name ) != NULL )  
iprog.c:  obj_to_room( obj, ch->in_room );
iprog.c:    spell_curse( gsn_curse, ch->level < 10? 1 : ch->level-9, ch, ch, TARGET_CHAR );
iprog.c:    spell_poison( gsn_poison, ch->level < 10? 1 : ch->level-9, ch, ch, TARGET_CHAR );
iprog.c:      obj_to_room(obj, ch->in_room);
iprog.c:/*  if (kingdom_table[ch->kingdom].obj_ptr == obj) 
iprog.c:    damage(ch,ch,ch->hit + 10,TYPE_HIT,DAM_HOLY);
iprog.c:  ch->gold = 0;
iprog.c:      obj_cast_spell(gsn_terangreal,ch->level,ch,ch,NULL);
iprog.c:      obj_to_room(obj, ch->in_room);
iprog.c:	  ch, NULL, ch->fighting, TO_CHAR);
iprog.c:	  ch, NULL, ch->fighting, TO_VICT);
iprog.c:	  ,ch, NULL, ch->fighting, TO_NOTVICT);
iprog.c:      ch->fighting->hit = 1;
iprog.c:      ch->hit = 1;
iprog.c:    obj_cast_spell(86,ch->level,ch,ch,NULL);
iprog.c:    obj_cast_spell(87,ch->level,ch,ch,NULL);
iprog.c:	   && (ch->fighting) && !IS_NPC(ch))
iprog.c:	  ch,NULL,ch->fighting,TO_CHAR);
iprog.c:	  ch,NULL,ch->fighting,TO_VICT);
iprog.c:	  ch,NULL,ch->fighting,TO_NOTVICT);
iprog.c:      obj_cast_spell(88,ch->level,ch,ch->fighting,NULL);
iprog.c:      obj_cast_spell(gsn_mirror,ch->level,ch,ch,obj); 
iprog.c:      obj_cast_spell(gsn_garble,ch->level,ch,ch->fighting,obj);
iprog.c:      obj_cast_spell(gsn_confuse, ch->level,ch,ch->fighting,obj);
iprog.c:      obj_cast_spell(gsn_cure_light, ch->level, ch, ch, obj);
iprog.c:      obj_cast_spell(gsn_cure_serious, ch->level, ch, ch, obj);
iprog.c:      obj_cast_spell(gsn_blindness, ch->level, ch,ch->fighting, obj);
iprog.c:      obj_cast_spell(gsn_shield, ch->level,ch,ch, obj);
iprog.c:      obj_cast_spell(gsn_blindness_dust, ch->level,ch,ch->fighting, obj);
iprog.c:      obj_cast_spell(gsn_bless, ch->level/2, ch, ch,obj);
iprog.c:      obj_cast_spell(gsn_cure_serious, ch->level/2, ch, ch, obj);
iprog.c:      obj_cast_spell(gsn_cure_light, ch->level, ch, ch, obj); 
iprog.c:      obj_cast_spell(gsn_demonfire, ch->level/2.5, ch, ch->fighting, obj);
iprog.c:      obj_cast_spell(gsn_ray_of_truth, ch->level, ch, ch->fighting, obj);
iprog.c:      obj_cast_spell(gsn_shield, ch->level, ch, ch->fighting, obj);
iprog.c:	if(ch->max_mana > ch->mana) {
iprog.c:		ch->mana += 10; }
iprog.c:      obj_cast_spell(gsn_curse, ch->level, ch, ch->fighting, obj);
iprog.c:      obj_cast_spell(gsn_weaken, ch->level, ch, ch->fighting, obj);
iprog.c:      obj_cast_spell(gsn_plague, ch->level, ch, ch->fighting, obj);
iprog.c:	  af.level = ch->level;
iprog.c:	  af.duration = ch->level / 3;
iprog.c:	  af.modifier = ch->level / 6;
iprog.c:	  af.modifier = 10 * (ch->level / 6);
iprog.c:	  ch->hit += ch->level * 2;
iprog.c:	  ch->hit = UMIN(ch->hit,ch->max_hit);
iprog.c:	  ch->hit += 15;
iprog.c:          ch->hit = UMIN(ch->hit,ch->max_hit);
iprog.c:	  ch->hit += 7;
iprog.c:          ch->hit = UMIN(ch->hit,ch->max_hit);
iprog.c:	  ch->hit += 14;
iprog.c:          ch->hit = UMIN(ch->hit,ch->max_hit);
iprog.c:	  ch->hit += 3;
iprog.c:          ch->hit = UMIN(ch->hit,ch->max_hit);
iprog.c:	  obj_cast_spell(gsn_cure_critical,ch->level,ch,ch,obj);
iprog.c:	  obj_cast_spell(gsn_cure_serious,ch->level,ch,ch,obj);
iprog.c:		ch->fighting, TO_CHAR);
iprog.c:		ch->fighting, TO_VICT);
iprog.c:		ch->fighting, TO_NOTVICT);
iprog.c:	obj_cast_spell(gsn_poison, ch->level, ch, ch->fighting, obj);
iprog.c:		ch->fighting, TO_CHAR);
iprog.c:		ch->fighting, TO_VICT);
iprog.c:		ch->fighting, TO_NOTVICT);
iprog.c:	obj_cast_spell(gsn_weaken, ch->level, ch, ch->fighting, obj);
iprog.c:	NULL, ch->fighting, TO_CHAR);
iprog.c:	ch, NULL, ch->fighting, TO_VICT);
iprog.c:	ch, NULL, ch->fighting, TO_NOTVICT);
iprog.c:      obj_cast_spell(gsn_lightning_bolt, ch->level, ch, ch->fighting, obj);
iprog.c:  if ( ch->class != 10 )          /* ranger */
iprog.c:     obj_to_room( obj, ch->in_room );
iprog.c:	dam = number_percent()/2 + 30 + ch->level;
iprog.c:	act( "Your gauntlets burns $N's face!", ch, NULL, ch->fighting, TO_CHAR);
iprog.c:	act( "$n's gauntlets burns $N's face!", ch, NULL, ch->fighting, TO_NOTVICT);
iprog.c:	act( "$N's gauntlets burns your face!", ch->fighting, NULL, ch, TO_CHAR);
iprog.c:	damage( ch, ch->fighting, dam/2, gsn_burning_hands, DAM_FIRE, TRUE);
iprog.c:	if ( ch == NULL || ch->fighting == NULL )
iprog.c:	fire_effect( ch->fighting, obj->level/2, dam/2, TARGET_CHAR );
iprog.c:  victim = ch->fighting;
iprog.c:if ( IS_SET( ch->in_room->room_flags, ROOM_ARENA ) )      /* ARENA */
magic.c:	    if (ch->level >= skill_table[sn].skill_level[ch->class]
magic.c:	    &&  ch->pcdata->learned[sn] > 0)
magic.c:switch (ch->class)
magic.c:    for ( rch = ch->in_room->people; rch; rch = rch->next_in_room )
magic.c:(get_skill(rch,gsn_spell_craft)*0.9)/(class_table[rch->class].fMana?1:2)<number_percent() ? 
magic.c:    if (ch->level + 2 == level)
magic.c:    return UMAX(min_mana,(100/(2 + ch->level - level)));
magic.c:if (ch->class == CLASS_BRD)
magic.c:if ((ch->class == CLASS_PDN) || (ch->class == CLASS_CLE))
magic.c:    if ( IS_NPC(ch) && ch->desc == NULL)
magic.c:    if (ch->kingdom == KINGDOM_HORDE && !IS_IMMORTAL(ch)) {
magic.c:    || ( !IS_NPC(ch) && (ch->level < skill_table[sn].skill_level[ch->class]
magic.c:    ||   		 ch->pcdata->learned[sn] == 0)))
magic.c:        if (ch->pcdata->learned[sn] > 1)
magic.c:          ch->pcdata->learned[sn] -= 1;
magic.c:    if ( ch->position < skill_table[sn].minimum_position )
magic.c:    if (IS_SET(ch->in_room->room_flags,ROOM_NO_MAGIC))
magic.c:    if (ch->level + 2 == skill_table[sn].skill_level[ch->class])
magic.c:	    100 / ( 2 + ch->level - skill_table[sn].skill_level[ch->class] ) );
magic.c:            damage(ch,ch,10 * ch->level,gsn_spellbane,DAM_NEGATIVE, TRUE);
magic.c:	    if ( ( victim = ch->fighting ) == NULL )
magic.c:	if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
magic.c:            ch->fighting != victim && victim->fighting != ch &&
magic.c:                     ch->doppel->name : ch->name);
magic.c:                damage(ch,ch,10 * ch->level,gsn_spellbane,DAM_NEGATIVE, TRUE);
magic.c:	if ( arg2[0] != '\0' && !is_name( target_name, ch->name ) )
magic.c:            damage(ch,ch,10 * ch->level,gsn_spellbane,DAM_NEGATIVE, TRUE);
magic.c:            damage(ch,ch,10 * ch->level,gsn_spellbane,DAM_NEGATIVE, TRUE);
magic.c:	    if ((victim = ch->fighting) == NULL)
magic.c:	    if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
magic.c:    if ( !IS_NPC(ch) && ch->mana < mana )
magic.c:	ch->mana -= mana / 2;
magic.c:	ch->mana -= mana;
magic.c:	if (IS_NPC(ch) || class_table[ch->class].fMana)
magic.c:	    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, vo,target);
magic.c:	    (*skill_table[sn].spell_fun) (sn, 3 * ch->level/4, ch, vo,target);
magic.c:	for ( vch = ch->in_room->people; vch; vch = vch_next )
magic.c:	    vch_next = vch->next_in_room;
magic.c:if (ch->class != CLASS_BRD)
magic.c:    if ( IS_NPC(ch) && ch->desc == NULL)
magic.c:    if (ch->kingdom == KINGDOM_HORDE && !IS_IMMORTAL(ch)) {
magic.c:    || ( !IS_NPC(ch) && (ch->level <
magic.c:skill_table[sn].skill_level[ch->class]
magic.c:    ||   		 ch->pcdata->learned[sn] == 0)))
magic.c:        if (ch->pcdata->learned[sn] > 1)
magic.c:          ch->pcdata->learned[sn] -= 1;
magic.c:    if ( ch->position < skill_table[sn].minimum_position )
magic.c:    if (IS_SET(ch->in_room->room_flags,ROOM_NO_MAGIC))
magic.c:    if (ch->level + 2 == skill_table[sn].skill_level[ch->class])
magic.c:	    100 / ( 2 + ch->level - skill_table[sn].skill_level[ch->class]
magic.c:            damage(ch,ch,10 * ch->level,gsn_spellbane,DAM_NEGATIVE, TRUE);
magic.c:	    if ( ( victim = ch->fighting ) == NULL )
magic.c:	if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
magic.c:            ch->fighting != victim && victim->fighting != ch &&
magic.c:                     ch->doppel->name : ch->name);
magic.c:                damage(ch,ch,10 * ch->level,gsn_spellbane,DAM_NEGATIVE,
magic.c:	if ( arg2[0] != '\0' && !is_name( target_name, ch->name ) )
magic.c:            damage(ch,ch,10 * ch->level,gsn_spellbane,DAM_NEGATIVE, TRUE);
magic.c:            damage(ch,ch,10 * ch->level,gsn_spellbane,DAM_NEGATIVE, TRUE);
magic.c:	    if ((victim = ch->fighting) == NULL)
magic.c:	    if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
magic.c:    if ( !IS_NPC(ch) && ch->mana < mana )
magic.c:	ch->mana -= mana / 2;
magic.c:	ch->mana -= mana;
magic.c:	if (IS_NPC(ch) || class_table[ch->class].fMana)
magic.c:	    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, vo,target);
magic.c:	    (*skill_table[sn].spell_fun) (sn, 3 * ch->level/4, ch,
magic.c:	for ( vch = ch->in_room->people; vch; vch = vch_next )
magic.c:	    vch_next = vch->next_in_room;
magic.c:if (!((ch->class == CLASS_CLE) || (ch->class == CLASS_PDN)) )
magic.c:    if ( IS_NPC(ch) && ch->desc == NULL)
magic.c:    if (ch->kingdom == KINGDOM_HORDE && !IS_IMMORTAL(ch)) {
magic.c:    || ( !IS_NPC(ch) && (ch->level < skill_table[sn].skill_level[ch->class]
magic.c:    ||   		 ch->pcdata->learned[sn] == 0)))
magic.c:        if (ch->pcdata->learned[sn] > 1)
magic.c:          ch->pcdata->learned[sn] -= 1;
magic.c:    if ( ch->position < skill_table[sn].minimum_position )
magic.c:    if (IS_SET(ch->in_room->room_flags,ROOM_NO_MAGIC))
magic.c:    if (ch->level + 2 == skill_table[sn].skill_level[ch->class])
magic.c:	    100 / ( 2 + ch->level - skill_table[sn].skill_level[ch->class]
magic.c:            damage(ch,ch,10 * ch->level,gsn_spellbane,DAM_NEGATIVE, TRUE);
magic.c:	    if ( ( victim = ch->fighting ) == NULL )
magic.c:	if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
magic.c:            ch->fighting != victim && victim->fighting != ch &&
magic.c:                     ch->doppel->name : ch->name);
magic.c:                damage(ch,ch,10 * ch->level,gsn_spellbane,DAM_NEGATIVE,
magic.c:	if ( arg2[0] != '\0' && !is_name( target_name, ch->name ) )
magic.c:            damage(ch,ch,10 * ch->level,gsn_spellbane,DAM_NEGATIVE, TRUE);
magic.c:            damage(ch,ch,10 * ch->level,gsn_spellbane,DAM_NEGATIVE, TRUE);
magic.c:	    if ((victim = ch->fighting) == NULL)
magic.c:	    if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
magic.c:    if ( !IS_NPC(ch) && ch->mana < mana )
magic.c:	ch->mana -= mana / 2;
magic.c:	ch->mana -= mana;
magic.c:	if (IS_NPC(ch) || class_table[ch->class].fMana)
magic.c:	    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, vo,target);
magic.c:	    (*skill_table[sn].spell_fun) (sn, 3 * ch->level/4, ch,
magic.c:	for ( vch = ch->in_room->people; vch; vch = vch_next )
magic.c:	    vch_next = vch->next_in_room;
magic.c:	    victim = ch->fighting;
magic.c:                number_percent() < 2*ch->pcdata->learned[gsn_spellbane]/3) )
magic.c:            damage(ch,ch,10 * ch->level,gsn_spellbane,DAM_NEGATIVE, TRUE);
magic.c:	    if (ch->fighting != NULL)
magic.c:		victim = ch->fighting;
magic.c:	for ( vch = ch->in_room->people; vch; vch = vch_next )
magic.c:	    vch_next = vch->next_in_room;
magic.c:    ass = (ch->class == class_lookup("assassin")) ? level/2 : level;
magic.c:    ass = (ch->class == class_lookup("assassin")) ? level/2 : level;
magic.c:	vch_next	= vch->next;
magic.c:	if ( vch->in_room == NULL )
magic.c:	if ( vch->in_room == ch->in_room )
magic.c:	if ( vch->in_room->area == ch->in_room->area
magic.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
magic.c:	if (vch->position == POS_FIGHTING)
magic.c:	      mlevel += vch->level;
magic.c:	      mlevel += vch->level/2;
magic.c:	    high_level = UMAX(high_level,vch->level);
magic.c:	for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
magic.c:	    if (IS_NPC(vch) && (IS_SET(vch->imm_flags,IMM_MAGIC) ||
magic.c:				IS_SET(vch->act,ACT_UNDEAD)))
magic.c:	    if (vch->fighting || vch->position == POS_FIGHTING)
magic.c:	 !(IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim) ) ||
magic.c:        ch->fighting != victim && victim->fighting != ch &&
magic.c:                    ch->doppel->name : ch->name);
magic.c:	for (tmp_vict = ch->in_room->people;
magic.c:                ch->fighting != tmp_vict && tmp_vict->fighting != ch &&
magic.c:                     ch->doppel->name : ch->name);
magic.c:    if((ch->class != CLASS_MAG) && (ch->class !=CLASS_BRD) && ch->class != CLASS_PRO) 
magic.c:	if((ch->level-5) < victim->level)
magic.c:    if((ch->class == CLASS_MAG) || (ch->class == CLASS_BRD) || ch->class == CLASS_PRO)
magic.c:	numcharmie = ch-level/40 + 1;
magic.c:    if(ch->charmie < numcharmie)
magic.c:    ch->charmie++;
magic.c:    obj_to_room( light, ch->in_room );
magic.c:    obj_to_room( mushroom, ch->in_room );
magic.c:    obj_to_room( spring, ch->in_room );
magic.c:    ch->alignment = UMAX(-1000, ch->alignment - 50);
magic.c:    ass = (ch->class == class_lookup("assassin")) ? level/2 : level;
magic.c:    if (victim->hit > (ch->level * 4))
magic.c:    if (victim->hit > (ch->level * 4))
magic.c:	vch_next	= vch->next;
magic.c:	if ( vch->in_room == NULL )
magic.c:	if ( vch->in_room == ch->in_room )
magic.c:	if ( vch->in_room->area == ch->in_room->area )
magic.c:        ch->alignment = UMAX(-1000, ch->alignment - 50);
magic.c:	dam		 = ch->hit + 1;
magic.c:	ch->hit		+= dam;
magic.c:    movedam     = number_range( ch->level, 2 * ch->level );
magic.c:  for (tmp_vict = ch->in_room->people;tmp_vict != NULL;
magic.c:              ch->fighting != tmp_vict && tmp_vict->fighting != ch &&
magic.c:	(is_affected(ch,gsn_doppelganger)&&!IS_IMMORTAL(tmp_vict))? ch->doppel->name : ch->name);
magic.c:    ass = (ch->class == class_lookup("assassin")) ? level/2 : level;
magic.c:    for ( ich = ch->in_room->people; ich != NULL; ich = ich->next_in_room )
magic.c:	if (ich->invis_level > 0)
magic.c:	REMOVE_BIT   ( ich->affected_by, AFF_HIDE	);
magic.c:	REMOVE_BIT   ( ich->affected_by, AFF_FADE	);
magic.c:	REMOVE_BIT   ( ich->affected_by, AFF_INVISIBLE	);
magic.c:        if ( IS_NPC(ich) || !IS_SET(race_table[ich->race].aff,AFF_SNEAK) )
magic.c:            REMOVE_BIT   ( ich->affected_by, AFF_SNEAK  );
magic.c:    disc->value[0]	= ch->level * 10; /* 10 pounds per level capacity */
magic.c:    disc->value[3]	= ch->level * 5; /* 5 pounds per level max per item */
magic.c:    disc->timer		= ch->level * 2 - number_range(0,level / 2); 
magic.c:    if (current_time - ch->last_fight_time < FIGHT_DELAY_TIME)
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_NOSUMMON)
magic.c:    ||   strstr( ch->in_room->area->builders, "Unlinked" ) 
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_ARENA )
magic.c:    ||   (!IS_NPC(victim) && ch->in_room->area != victim->in_room->area )
magic.c:    if (ch->pet != NULL && ch->in_room == ch->pet->in_room)
magic.c:	act("$n steps through a gate and vanishes.",ch->pet,NULL,NULL,TO_ROOM);
magic.c:	send_to_char("You step through a gate and vanish.\n\r",ch->pet);
magic.c:	char_from_room(ch->pet);
magic.c:	char_to_room(ch->pet,victim->in_room);
magic.c:	act("$n has arrived through a gate.",ch->pet,NULL,NULL,TO_ROOM);
magic.c:	do_look(ch->pet,"auto");
magic.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch_next )
magic.c:	vch_next = vch->next_in_room;
magic.c:                ch->fighting != vch && vch->fighting != ch &&
magic.c:                (IS_SET(vch->affected_by,AFF_CHARM) || !IS_NPC(vch)))
magic.c:                     ch->doppel->name : ch->name);
magic.c:                ch->fighting != vch && vch->fighting != ch &&
magic.c:                (IS_SET(vch->affected_by,AFF_CHARM) || !IS_NPC(vch)))
magic.c:                     ch->doppel->name : ch->name);
magic.c:    ch->move /= (4/3);
magic.c:    ch->hit /= (4/3);
magic.c:    ass = (ch->class == class_lookup("assassin")) ? level/2 : level;
magic.c:	||   ch->level < obj->level)
magic.c:	if ( ch->level > 4 )  {
magic.c:    if ( ch->level > 4 )  {
magic.c:    if ( ch->level > 8 )  {
magic.c:    if ( ch->level > 12 )  {
magic.c:    if ( ch->level > 16 )  {
magic.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
magic.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
magic.c:    ran = (ch->class == class_lookup("ranger")) ? level/2 : level;
magic.c:    ass = (ch->class == class_lookup("assassin")) ? level/2 : level;
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_SAFE)
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_NOSUMMON)
magic.c:    ||   IS_SET( ch->in_room->room_flags, ROOM_ARENA )
magic.c:    ||   (ch->in_room->area != victim->in_room->area && !IS_NPC(victim))
magic.c:    char_to_room( victim, ch->in_room );
magic.c:    ||   strstr( ch->in_room->area->builders, "Unlinked" ) 
magic.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room )
magic.c:	if ( !is_name( speaker, vch->name ) )
magic.c:   to_room_vnum = hometown_table[ch->hometown].recall[IS_GOOD(ch)?0:IS_NEUTRAL(ch)?1:IS_EVIL(ch)?2:1];
magic.c:    if (ch->desc != NULL && current_time - ch->last_fight_time
magic.c:    ch->move /= 2;
magic.c:    hpch = UMAX(12,ch->hit);
magic.c:    hpch = UMAX( 10, ch->hit );
magic.c:	vch_next = vch->next_in_room;
magic.c:	&&   (ch->fighting != vch || vch->fighting != ch)))
magic.c:    hpch = UMAX(12,ch->hit);
magic.c:	vch_next = vch->next_in_room;
magic.c:	&&   (ch->fighting != vch || vch->fighting != ch)))
magic.c:    hpch = UMAX(16,ch->hit);
magic.c:    poison_effect(ch->in_room,level,dam,TARGET_ROOM);
magic.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
magic.c:	vch_next = vch->next_in_room;
magic.c:	&&   (ch->fighting == vch || vch->fighting == ch)))
magic.c:              ch->fighting != vch && vch->fighting != ch &&
magic.c:              (IS_SET(vch->affected_by,AFF_CHARM) || !IS_NPC(vch)))
magic.c:                     ch->doppel->name : ch->name);
magic.c:    hpch = UMAX(10,ch->hit);
magic.c:    if ( is_affected_room( ch->in_room, sn ))
magic.c:    af.level     = ch->level;
magic.c:    affect_to_room( ch->in_room, &af );
magic.c:    af2.level    = ch->level;
magic.c:    ch->in_room->owner = str_dup( ch->name );
magic.c:    if ( is_affected_room( ch->in_room, sn ))
magic.c:    af.level     = ch->level;
magic.c:    affect_to_room( ch->in_room, &af );
magic.c:    af2.duration  = ch->level / 10;
magic.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
magic.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
magic.c:    af.level     = ch->level;
magic.c:      af.level	= ch->level;
magic2.c:    ||   strstr( ch->in_room->area->builders, "Unlinked" ) 
magic2.c:    ||   IS_SET( ch->in_room->room_flags, ROOM_ARENA )
magic2.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_NOSUMMON)
magic2.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
magic2.c:    obj_to_room(portal,ch->in_room);
magic2.c:    from_room = ch->in_room;
magic2.c:    ||   strstr( ch->in_room->area->builders, "Unlinked" ) 
magic2.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_ARENA ) )      /* ARENA */
magic2.c:    if ((ch->level*1.2) < victim->level) 
magic2.c:    if (ch->level*1.15 < victim->level) 
magic2.c:	   ( number_percent() > (75-(2*(victim->level - ch->level))) )
magic2.c:    for (tmp_ch = char_list; tmp_ch != NULL; tmp_ch = tmp_ch->next)
magic2.c:      if (tmp_ch->last_fought == victim)
magic2.c:        tmp_ch->last_fought = NULL;
magic2.c:    tohit.level            = ch->level; 
magic2.c:    todam.level            = ch->level; 
magic2.c:        af.modifier = ch->max_mana*.5;
magic2.c:        af.modifier = ch->max_hit*.5;
magic2.c:  if (ch->kingdom != victim->kingdom)
magic2.c:  if (ch->hit < 50)
magic2.c:  for (gch = char_list; gch != NULL; gch = gch->next)
magic2.c:      if (IS_NPC(gch) && IS_AFFECTED(gch,AFF_CHARM) && gch->master == ch &&
magic2.c:	  gch->pIndexData->vnum == MOB_VNUM_SPIRIT)
magic2.c:      spirit->perm_stat[i] = ch->perm_stat[i];
magic2.c:  spirit->max_hit = IS_NPC(ch)? URANGE(ch->max_hit,1 * ch->max_hit,30000)
magic2.c:		: URANGE(ch->pcdata->perm_hit,1*ch->pcdata->perm_hit,30000);
magic2.c:  spirit->max_mana = IS_NPC(ch)? ch->max_mana : ch->pcdata->perm_mana;
magic2.c:  spirit->level = ch->level;
magic2.c:  char_to_room(spirit,ch->in_room);
magic2.c:      do_murder(spirit, ch->name);
magic2.c:  for (tmp_vict = ch->in_room->people;tmp_vict != NULL;
magic2.c:	      ch->fighting != tmp_vict && tmp_vict->fighting != ch &&
magic2.c:		     ch->doppel->name : ch->name);
magic2.c:      (is_affected(ch, sn) && (ch->doppel == victim)) )
magic2.c:  ch->doppel = victim;
magic2.c:  if(ch->in_room->sector_type != SECT_CITY)
magic2.c:  if (is_affected(ch, sn)  || ch->kingdom_rank < 5)
magic2.c:  for (gch = char_list; gch != NULL; gch = gch->next)
magic2.c:      if (IS_NPC(gch) && IS_AFFECTED(gch,AFF_CHARM) && gch->master == ch)
magic2.c:    guard->perm_stat[i] = ch->perm_stat[i]-1;
magic2.c:  guard->max_hit = ch->max_hit*1.3;
magic2.c:  guard->max_mana = ch->max_mana*1.2;
magic2.c:  guard->alignment = ch->alignment;
magic2.c:  guard->level = ch->level-7;
magic2.c:  guard->sex = ch->sex;
magic2.c:  char_to_room(guard,ch->in_room);
magic2.c:  char_to_room(guard2,ch->in_room);
magic2.c:  for (gch = char_list; gch != NULL; gch = gch->next)
magic2.c:      if (IS_NPC(gch) && IS_AFFECTED(gch,AFF_CHARM) && gch->master == ch &&
magic2.c:	  gch->pIndexData->vnum == MOB_VNUM_NIGHTWALKER)
magic2.c:      walker->perm_stat[i] = ch->perm_stat[i];
magic2.c:  walker->max_hit = IS_NPC(ch)? URANGE(ch->max_hit,1 * ch->max_hit,30000)
magic2.c:                : URANGE(ch->pcdata->perm_hit,1*ch->pcdata->perm_hit,30000);
magic2.c:  walker->max_mana = ch->max_mana;
magic2.c:  walker->level = ch->level;
magic2.c:  char_to_room(walker,ch->in_room);
magic2.c:  sprintf(buf, "A Nightwalker kneels before %s!", ch->name );
magic2.c:    if ( (victim->level > ch->level + 7) && saves_spell(level, victim, DAM_NONE) )
magic2.c:      ori_room = ch->in_room;
magic2.c:    if (ch->kingdom != victim->kingdom)
magic2.c:    if ( is_affected_room( ch->in_room, sn ))
magic2.c:    af.level     = ch->level;
magic2.c:    affect_to_room( ch->in_room, &af );
magic2.c:    af2.duration  = ch->level / 10;
magic2.c:  for (mirrors = 0, gch = char_list; gch != NULL; gch = gch->next)
magic2.c:	&& is_affected(gch,gsn_doppelganger) && gch->doppel == victim)
magic2.c:  for (mirrors = 0, gch = char_list; gch != NULL;gch = gch->next) {
magic2.c:	&& !str_cmp(gch->name,victim->name))
magic2.c:    free_string(gch->name);
magic2.c:    free_string(gch->short_descr);
magic2.c:    free_string(gch->long_descr);
magic2.c:    free_string(gch->description);
magic2.c:    gch->exp  = tmp_vict->exp;
magic2.c:    gch->practice = tmp_vict->level;	
magic2.c:    gch->name = str_dup(tmp_vict->name);
magic2.c:    gch->short_descr = str_dup(short_buf);
magic2.c:    gch->long_descr = str_dup(long_buf);
magic2.c:gch->description = (tmp_vict->description == NULL)? 
magic2.c:    gch->sex = tmp_vict->sex;
magic2.c:    gch->max_hit = gch->hit = 1;
magic2.c:    gch->level = 1;
magic2.c:    gch->doppel = victim;
magic2.c:    gch->master = victim;
magic2.c:      char_to_room(victim,gch->in_room);
magic2.c:  do_murder(victim,vch->name); 
magic2.c:    ch->hit = UMIN( ch->hit + 150, ch->max_hit );
magic2.c:      if (!str_cmp(ch->name, religion_table[i].leader))
magic2.c:  if (victim->hit > (ch->level * 8))
magic2.c:  if (IS_SET(ch->in_room->room_flags, ROOM_LAW))
magic2.c:  pRoomIndex = get_room_index(ch->in_room->vnum);
magic2.c:      if (ch->trust >= MAX_LEVEL-12)
magic2.c:  if (ch->trust >= MAX_LEVEL-12)
magic2.c:  ch->hit -= UMIN(200, ch->hit/2);
magic2.c:  sprintf(log_buf, "%s used randomizer in room %d", ch->name, ch->in_room->vnum);
magic2.c:  char_to_room(stalker,ch->in_room);
magic2.c:  sprintf(log_buf, "%s used stalker on %s", ch->name, victim->name);
magic2.c:	|| ch->in_room == NULL) {
magic2.c:      ||   IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
magic2.c:      ||   IS_SET(ch->in_room->room_flags, ROOM_NOSUMMON)
magic2.c:  if (ch->pet != NULL && ch->in_room == ch->pet->in_room)
magic2.c:  for (wch = ch->in_room->people; wch != NULL; wch = wch_next)
magic2.c:      wch_next = wch->next_in_room;
magic2.c:	  if (wch->in_room == NULL)
magic2.c:  if (ch->in_room == NULL)
magic2.c:      send_to_char("You feel time and space shift around you.\n\r",ch->pet);
magic2.c:      char_from_room(ch->pet);
magic2.c:      char_to_room(ch->pet,victim->in_room);
magic2.c:      act("$n arrives suddenly.",ch->pet,NULL,NULL,TO_ROOM);
magic2.c:      if (ch->pet->in_room == NULL)
magic2.c:         do_look(ch->pet,"auto");
magic2.c:    for( vial=ch->carrying; vial != NULL; vial=vial->next_content )
magic2.c:      shadow->perm_stat[i] = ch->perm_stat[i];
magic2.c:  shadow->max_hit = (3 * ch->max_hit) / 4;
magic2.c:  shadow->max_mana = (3 * ch->max_mana) / 4;
magic2.c:  shadow->alignment = ch->alignment;
magic2.c:  shadow->level = ch->level;
magic2.c:  char_to_room(shadow,ch->in_room);
magic2.c:  for (gch = char_list; gch != NULL; gch = gch->next)
magic2.c:      if (IS_AFFECTED(gch,AFF_CHARM) && gch->master == ch)
magic2.c:	  if (count >= ch->level/15 && ch->class != class_lookup("mage"))
magic2.c:	  else if (count >= ch->level/10)
magic2.c:      shade->perm_stat[i] = ch->perm_stat[i];
magic2.c:  shade->max_hit = (3 * ch->max_hit) / 4;
magic2.c:  shade->max_mana = (3 * ch->max_mana) / 4;
magic2.c:  shade->level = (3 * ch->level) / 4;
magic2.c:  char_to_room(shade,ch->in_room);
magic2.c:      obj_to_room(tmp_obj,ch->in_room);
magic2.c:  sprintf(buff, "kneel %s", ch->name);
magic2.c:  for ( badge = ch->carrying; badge != NULL;
magic2.c:  for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
magic2.c:if (ch->in_room->sector_type == SECT_CITY)
magic2.c:if (ch->in_room->sector_type == SECT_INSIDE)
magic2.c:  for (gch = char_list; gch != NULL; gch = gch->next)
magic2.c:      if (IS_NPC(gch) && IS_AFFECTED(gch,AFF_CHARM) && gch->master == ch &&
magic2.c:	  gch->pIndexData->vnum == MOB_VNUM_SQUIRE)
magic2.c:      squire->perm_stat[i] = ch->perm_stat[i];
magic2.c:  squire->max_hit = ch->max_hit;
magic2.c:  squire->max_mana = ch->max_mana;
magic2.c:  squire->level = ch->level;
magic2.c:  sprintf( buf, squire->short_descr, ch->name );
magic2.c:  sprintf( buf, squire->long_descr, ch->name );
magic2.c:  sprintf( buf, squire->description, ch->name );
magic2.c:  char_to_room(squire,ch->in_room);
magic2.c:  for (gch = char_list; gch != NULL; gch = gch->next)
magic2.c:      if (IS_NPC(gch) && IS_AFFECTED(gch,AFF_CHARM) && gch->master == ch &&
magic2.c:	  gch->pIndexData->vnum == MOB_VNUM_EARTH_ELEMENTAL)
magic2.c:      eelement->perm_stat[i] = ch->perm_stat[i];
magic2.c:  eelement->max_hit = ch->max_hit*2;
magic2.c:  eelement->max_mana = ch->max_mana*2;
magic2.c:  eelement->level = ch->level;
magic2.c:  sprintf( buf, eelement->short_descr, ch->name );
magic2.c:  sprintf( buf, eelement->long_descr, ch->name );
magic2.c:  sprintf( buf, eelement->description, ch->name );
magic2.c:  char_to_room(eelement,ch->in_room);
magic2.c:  for (gch = char_list; gch != NULL; gch = gch->next)
magic2.c:      if (IS_NPC(gch) && IS_AFFECTED(gch,AFF_CHARM) && gch->master == ch &&
magic2.c:	  gch->pIndexData->vnum == MOB_VNUM_FIRE_ELEMENTAL)
magic2.c:      eelement->perm_stat[i] = ch->perm_stat[i];
magic2.c:  eelement->max_hit = ch->max_hit*1.5;
magic2.c:  eelement->max_mana = ch->max_mana*1.5;
magic2.c:  eelement->level = ch->level;
magic2.c:  sprintf( buf, eelement->short_descr, ch->name );
magic2.c:  sprintf( buf, eelement->long_descr, ch->name );
magic2.c:  sprintf( buf, eelement->description, ch->name );
magic2.c:  char_to_room(eelement,ch->in_room);
magic2.c:  for (gch = char_list; gch != NULL; gch = gch->next)
magic2.c:      if (IS_NPC(gch) && IS_AFFECTED(gch,AFF_CHARM) && gch->master == ch &&
magic2.c:	  gch->pIndexData->vnum == MOB_VNUM_AIR_ELEMENTAL)
magic2.c:      eelement->perm_stat[i] = ch->perm_stat[i];
magic2.c:  eelement->max_hit = ch->max_hit;
magic2.c:  eelement->max_mana = ch->max_mana;
magic2.c:  eelement->level = ch->level;
magic2.c:  sprintf( buf, eelement->short_descr, ch->name );
magic2.c:  sprintf( buf, eelement->long_descr, ch->name );
magic2.c:  sprintf( buf, eelement->description, ch->name );
magic2.c:  char_to_room(eelement,ch->in_room);
magic2.c:  for (gch = char_list; gch != NULL; gch = gch->next)
magic2.c:      if (IS_NPC(gch) && IS_AFFECTED(gch,AFF_CHARM) && gch->master == ch &&
magic2.c:	  gch->pIndexData->vnum == MOB_VNUM_WATER_ELEMENTAL)
magic2.c:      eelement->perm_stat[i] = ch->perm_stat[i];
magic2.c:  eelement->max_hit = ch->max_hit/2;
magic2.c:  eelement->max_mana = ch->max_mana/2;
magic2.c:  eelement->level = ch->level;
magic2.c:  sprintf( buf, eelement->short_descr, ch->name );
magic2.c:  sprintf( buf, eelement->long_descr, ch->name );
magic2.c:  sprintf( buf, eelement->description, ch->name );
magic2.c:  char_to_room(eelement,ch->in_room);
magic2.c:if (ch->in_room->sector_type == SECT_CITY)
magic2.c:if (ch->in_room->sector_type == SECT_INSIDE)
magic2.c:  if (ch->in_room->sector_type == SECT_INSIDE || 
magic2.c:      ch->in_room->sector_type == SECT_CITY || 
magic2.c:      ch->in_room->sector_type == SECT_DESERT || 
magic2.c:      ch->in_room->sector_type == SECT_AIR)
magic2.c:  damage(ch,victim,ch->level,gsn_entangle,DAM_PIERCE, TRUE);
magic2.c:  for ( vch = ch->in_room->people; vch != NULL; vch = vch_next )
magic2.c:      vch_next = vch->next_in_room;
magic2.c:      if ( (vch->in_room != NULL)
magic2.c:      && ( !IS_SET(vch->in_room->room_flags, ROOM_NO_RECALL)
magic2.c:      && (IS_NPC(vch) && !IS_SET(vch->act, ACT_AGGRESSIVE)) 
magic2.c:      || ((!IS_NPC(vch) && (vch->exp > PK_MIN)) && (vch->level < level))  
magic2.c:      && !IS_SET(vch->imm_flags, IMM_SUMMON)) 
magic2.c:      || (IS_NPC(vch) && !IS_SET(vch->imm_flags, IMM_SUMMON)) 
magic2.c:      || (!IS_NPC(vch) && (level < vch->level+5) &&(vch != ch))
magic2.c:      || !strstr( ch->in_room->area->builders, "Unlinked" ) 
magic2.c:	  if((vch->pIndexData->vnum == 110) ||
magic2.c:	    (vch->pIndexData->vnum == 120) ||
magic2.c:	    (vch->pIndexData->vnum == 130) ||
magic2.c:	    (vch->pIndexData->vnum == 140) ||
magic2.c:	    (vch->pIndexData->vnum == 150) ||
magic2.c:	    (vch->pIndexData->vnum == 160)) 
magic2.c:    if (ch->alignment == 750)
magic2.c:    if (ch->alignment == 0)
magic2.c:  for (gch = char_list; gch != NULL; gch = gch->next)
magic2.c:      if (IS_NPC(gch) && IS_AFFECTED(gch,AFF_CHARM) && gch->master == ch &&
magic2.c:	  gch->pIndexData->vnum == MOB_VNUM_ZOMBIE)
magic2.c:    if( obj->level > (ch->level + 5) )
magic2.c:    if( ch->pet != NULL )
magic2.c:    char_to_room( mob, ch->in_room );
magic2.c:    ch->pet = mob;
magic2.c:    if (ch->in_room == location) /* Baxter */
magic2.c:  if (IS_RAFFECTED(ch->in_room,AFF_ROOM_CURSE))
magic2.c:         affect_strip_room(ch->in_room,gsn_cursed_lands);
magic2.c:  if (IS_RAFFECTED(ch->in_room,AFF_ROOM_POISON))
magic2.c:         affect_strip_room(ch->in_room,gsn_deadly_venom);
magic2.c:  if (IS_RAFFECTED(ch->in_room,AFF_ROOM_SLEEP))
magic2.c:         affect_strip_room(ch->in_room,gsn_mysterious_dream);
magic2.c:  if (IS_RAFFECTED(ch->in_room,AFF_ROOM_PLAGUE))
magic2.c:         affect_strip_room(ch->in_room,gsn_black_death);
magic2.c:  if (IS_RAFFECTED(ch->in_room,AFF_ROOM_SLOW))
magic2.c:         affect_strip_room(ch->in_room,gsn_lethargic_mist);
magic2.c:  if (IS_SET(ch->in_room->room_flags, ROOM_LAW))
magic2.c:    if ( is_affected_room( ch->in_room, sn ))
magic2.c:    af.level     = ch->level;
magic2.c:    affect_to_room( ch->in_room, &af );
magic2.c:  if (IS_SET(ch->in_room->room_flags, ROOM_LAW))
magic2.c:    if ( is_affected_room( ch->in_room, sn ))
magic2.c:    af.level     = ch->level;
magic2.c:    affect_to_room( ch->in_room, &af );
magic2.c:  if (IS_SET(ch->in_room->room_flags, ROOM_LAW))
magic2.c:    if ( is_affected_room( ch->in_room, sn ))
magic2.c:    af.level     = ch->level;
magic2.c:    affect_to_room( ch->in_room, &af );
magic2.c:  if (IS_SET(ch->in_room->room_flags, ROOM_LAW))
magic2.c:    if ( is_affected_room( ch->in_room, sn ))
magic2.c:    af.level     = ch->level;
magic2.c:    affect_to_room( ch->in_room, &af );
magic2.c:  if (IS_SET(ch->in_room->room_flags, ROOM_LAW))
magic2.c:    if ( is_affected_room( ch->in_room, sn ))
magic2.c:    af.level     = ch->level;
magic2.c:    affect_to_room( ch->in_room, &af );
magic2.c:        dam              = ch->hit + 1;
magic2.c:     ch->hit            += dam / 2;
magic2.c:    hpch = UMAX(16,ch->hit);
magic2.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
magic2.c:        vch_next = vch->next_in_room;
magic2.c:        &&   (ch->fighting == vch || vch->fighting == ch)))
magic2.c:              ch->fighting != vch && vch->fighting != ch &&
magic2.c:              (IS_SET(vch->affected_by,AFF_CHARM) || !IS_NPC(vch)))
magic2.c:                     ch->doppel->name : ch->name);
magic2.c:        if (vch->size == SIZE_TINY)  dam *= 1.5;
magic2.c:        else if (vch->size == SIZE_SMALL)  dam *= 1.3;
magic2.c:        else if (vch->size == SIZE_MEDIUM)  dam *= 1;
magic2.c:        else if (vch->size == SIZE_LARGE)  dam *= 0.9;
magic2.c:      else if (vch->size == SIZE_HUGE)  dam *= 0.7;
magic2.c:      af.level	= ch->level;
magic2.c:      af.level	= ch->level;
magic2.c:        for( gch=ch->in_room->people; gch != NULL; gch=gch->next_in_room)
magic2.c:        for( gch=ch->in_room->people; gch != NULL; gch=gch->next_in_room )
magic2.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room
magic2.c:         mana_add = UMIN( (victim->max_hit - victim->hit), ch->mana );
magic2.c:         ch->mana -= mana_add;
magic2.c:    hpch = UMAX( 10, ch->hit );
magic2.c:        vch_next = vch->next_in_room;
magic2.c:        &&   (ch->fighting != vch || vch->fighting != ch)))
magic2.c:        vch_next = vch->next_in_room;
magic2.c:        &&   (ch->fighting != vch || vch->fighting != ch)))
magic2.c:    poison_effect(ch->in_room,level,dam,TARGET_ROOM);
magic2.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
magic2.c:        vch_next = vch->next_in_room;
magic2.c:        &&   (ch->fighting == vch || vch->fighting == ch)))
magic2.c:              ch->fighting != vch && vch->fighting != ch &&
magic2.c:              (IS_SET(vch->affected_by,AFF_CHARM) || !IS_NPC(vch)))
magic2.c:                     ch->doppel->name : ch->name);
magic2.c:    if ( (ch->in_room->sector_type == SECT_AIR)
magic2.c:        || (ch->in_room->sector_type == SECT_WATER_SWIM)
magic2.c:     || (ch->in_room->sector_type == SECT_WATER_NOSWIM) )
magic2.c:         ch->wait = 0;
magic2.c:    hpch = UMAX( 10, ch->hit );
magic2.c:    sand_effect(ch->in_room,level,dam/2,TARGET_ROOM);
magic2.c:  for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
magic2.c:        vch_next = vch->next_in_room;
magic2.c:        &&   (ch->fighting != vch || vch->fighting != ch)))
magic2.c:    hpch = UMAX( 10, ch->hit );
magic2.c:    scream_effect(ch->in_room,level,dam/2,TARGET_ROOM);
magic2.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
magic2.c:        vch_next = vch->next_in_room;
magic2.c:        &&   (ch->fighting != vch || vch->fighting != ch)))
magic2.c:             if (vch->fighting)  stop_fighting( vch , TRUE );
magic2.c:             if (vch->fighting)  stop_fighting( vch , TRUE );
magic3.c:    if ( number_percent() <= ( 10 - ch->level + obj->level ) ) {
magic3.c:    obj->value[0] = ( obj->value[0] * ch->pcdata->learned[sn] / 100 );
magic3.c:    obj->value[1] = ( obj->value[1] * ch->pcdata->learned[sn] / 100 );
magic3.c:    obj->value[2] = ( obj->value[2] * ch->pcdata->learned[sn] / 100 );
magic3.c:    obj->value[0] = ( obj->value[0] * ch->pcdata->learned[sn] / 100 );
magic3.c:    obj->value[1] = ( obj->value[1] * ch->pcdata->learned[sn] / 100 );
magic3.c:    obj->value[2] = ( obj->value[2] * ch->pcdata->learned[sn] / 100 );
magic3.c:	for (tmp_vict = ch->in_room->people;
magic3.c:	for (tmp_vict = ch->in_room->people;
magic3.c:	for (tmp_vict = ch->in_room->people;
magic3.c:	for (tmp_vict = ch->in_room->people;
magic3.c:	for (tmp_vict = ch->in_room->people;
magic3.c:	for (tmp_vict = ch->in_room->people;
magic3.c:    original = ch->in_room;
magic3.c:    if ( number_percent( ) < ch->pcdata->learned[sn] *
magic3.c:	 ( 33 + ( 33 * ( ch->level - obj->level ) / 50 ) ) / 100 )
magic3.c:    for ( vch = ch->in_room->people; vch; vch = vch_next )
magic3.c:	vch_next = vch->next_in_room;
magic3.c:	    hpch = URANGE( 10, ch->hit, 999 );
magic3.c:		&& (   level <= vch->level + 5
magic3.c:		    && level >= vch->level - 5 ) )
magic3.c:		vch->hit = 1;
magic3.c:    for ( gch = ch->in_room->people; gch; gch = gch->next_in_room )
magic3.c:    if ( ch->hit-hpch < 50 )
magic3.c:    ch->hit     -= hpch;
magic3.c:       vch_next = vch->next_in_room;
magic3.c:    for ( vch = ch->in_room->people; vch; vch = vch_next )
magic3.c:vch_next = vch->next_in_room;
magic3.c:	    hpch = UMAX( 10, ch->hit );
magic3.c:        char_to_room( zombie, ch->in_room );
magic3.c:        zombie->level = ( ch->level - 5 );
magic3.c:        zombie->max_hit = ( ch->max_hit /2 );
magic3.c:        zombie->hit = ( ch->max_hit /2 );
magic3.c:        if ( ch->alignment >= -1000 )
magic3.c:            ch->alignment = UMAX( -1000, ch->alignment - 200 );
magic3.c:	char_to_room (zombie, ch->in_room);		/* get it here	*/
magic3.c:	zombie->max_hit = (ch->max_hit /3);	/* give it hp	*/
magic3.c:        afpaf->duration += dice(((ch->pcdata->learned[sn] * level ) / 100), 10);
map.c:	||(!IS_SET(ch->act,PLR_HOLYLIGHT))
map.c:MapArea(ch->in_room, ch, 80, 80, min, max); 
map.c:strcpy(desc,ch->in_room->description);
map.c:	sprintf(buf,"{x   {C%s{x",ch->in_room->name);
map.c:        if (  !IS_NPC(ch) && IS_SET(ch->act, PLR_AUTOEXIT)  ) { 
map.c:       		if (IS_IMMORTAL(ch) && (IS_NPC(ch) || IS_SET(ch->act,PLR_HOLYLIGHT)))
map.c:           	sprintf(buf," {c[Room %d]{x",ch->in_room->vnum);
map.c:MapArea(ch->in_room, ch, center, center, min-1, max-1); 
map.c:  if (  !IS_SET(ch->in_room->room_flags, ROOM_WILDERNESS)   )
map.c:  if ( room_is_dark( ch->in_room ,ch) ) 
map.c:MapArea(ch->in_room, ch, center, center, min-1, max-1); 
map.c:vnum=(ch->in_room->vnum);
map.c:SET_BIT( ch->in_room->area->area_flags, AREA_CHANGED );
mob_cmds.c:    if ( ch->desc != NULL && get_trust(ch) < MAX_LEVEL )
mob_cmds.c:	IS_NPC(ch) ? ch->pIndexData->vnum : 0, command );
mob_cmds.c:	    IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:	    IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:    if ( ch->in_room == NULL )
mob_cmds.c:	&&   d->character->in_room->area == ch->in_room->area )
mob_cmds.c:    was_in_room = ch->in_room;
mob_cmds.c:	    ch->in_room = pexit->u1.to_room;
mob_cmds.c:    ch->in_room = was_in_room;
mob_cmds.c:    if ( victim == ch || IS_NPC(victim) || ch->position == POS_FIGHTING )
mob_cmds.c:    if ( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
mob_cmds.c:	    IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:    if ( victim == ch || ch->fighting != NULL || victim->fighting == NULL )
mob_cmds.c:      	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
mob_cmds.c:    if ( ch->in_room == NULL || arg[0] == '\0' || !is_number(arg) )
mob_cmds.c:	    vnum, IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:    char_to_room( victim, ch->in_room );
mob_cmds.c:	    IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:	obj_to_room( obj, ch->in_room );
mob_cmds.c:	for ( victim = ch->in_room->people; victim != NULL; victim = vnext )
mob_cmds.c:	for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next )
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:    if ( ch->fighting != NULL )
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:    original = ch->in_room;
mob_cmds.c:    on = ch->on;
mob_cmds.c:    for ( wch = char_list; wch != NULL; wch = wch->next )
mob_cmds.c:	    ch->on = on;
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:	for ( victim = ch->in_room->people; victim != NULL; victim = victim_next )
mob_cmds.c:	location = ch->in_room;
mob_cmds.c:	        IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:    for ( victim = ch->in_room->people; victim; victim = victim_next )
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:	    vch_next = vch->next;
mob_cmds.c:	    if ( vch->in_room == ch->in_room
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:	vch_next = vch->next_in_room;
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:    (*skill_table[sn].spell_fun)( sn, ch->level, ch, victim,
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:	for( victim = ch->in_room->people; victim; victim = victim_next )
mob_cmds.c:	ch->mprog_target = get_char_world( ch, arg );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:    ch->mprog_target = NULL;
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:    ch->mprog_delay = atoi( arg );
mob_cmds.c:   ch->mprog_delay = -1;
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:    if ( ch->fighting != NULL )
mob_cmds.c:    if ( (was_in = ch->in_room) == NULL )
mob_cmds.c:        if ( ch->in_room != was_in )
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_prog.c:    for( vch = mob->in_room->people; vch; vch = vch->next_in_room )
mob_prog.c:    for ( count = 0, vch = mob->in_room->people; vch; vch = vch->next_in_room )
mob_prog.c:	     && mob->pIndexData->vnum == vch->pIndexData->vnum )
mob_prog.c:    for ( i = 0, vch = ch->in_room->people; vch; vch = vch->next_in_room )
mob_prog.c:	&&   vch->pIndexData->vnum == ch->pIndexData->vnum )
mob_prog.c:    for ( obj = ch->carrying; obj; obj = obj->next_content )
mob_prog.c:    for ( mob = ch->in_room->people; mob; mob = mob->next_in_room )
mob_prog.c:    for ( obj = ch->in_room->contents; obj; obj = obj->next_content )
mob_prog.c:            	    one_argument( ch->name, fname );
mob_prog.c:		? ( IS_NPC( ch ) ? ch->short_descr : ch->name )
mob_prog.c:            	     one_argument( vch->name, fname );
mob_prog.c:		? ( IS_NPC( vch ) ? vch->short_descr : vch->name )
mob_prog.c:                    one_argument( rch->name, fname );
mob_prog.c:		? ( IS_NPC( ch ) ? ch->short_descr : ch->name )
mob_prog.c:		? he_she  [URANGE(0, ch->sex, 2)]        
mob_prog.c:		? he_she  [URANGE(0, vch->sex, 2)]        
mob_prog.c:		? he_she  [URANGE(0, rch->sex, 2)]        
mob_prog.c:    for ( mob = ch->in_room->people; mob != NULL; mob = mob->next_in_room )
mob_prog.c:    for ( mob = ch->in_room->people; mob != NULL; mob = mob->next_in_room )
mprog.c:      sprintf(log_buf,"%s has tried to solve the weaponsmith quest.",ch->name);
mprog.c:      sprintf(log_buf,"%s has tried to solve the weaponsmith quest.",ch->name);
mprog.c:      if ( !IS_SET( ch->quest, QUEST_WEAPONSMITH ) )  {
mprog.c:         SET_BIT( ch->quest, QUEST_WEAPONSMITH );
mprog.c:	sprintf(log_buf,"%s has solved the weaponsmith quest.",ch->name);
mprog.c:	sprintf(buf,"{YAndor shouts: Thanks, %s for helping me!!\n",ch->name);
mprog.c:        sprintf( buf, weapon->pIndexData->extra_descr->description, ch->name );
mprog.c:	sprintf( buf, "thank %s", ch->name );
mprog.c:    if ( ch->pIndexData->vnum == 3307 )
mprog.c:          ch->status = MOB_STAT_SERV_GO;
mprog.c:    if (( ch->religion > 0) && (ch->religion < MAX_RELIGION) )
mprog.c:                religion_table[ch->religion].leader);
mprog.c:         if ( !IS_GOOD(ch) && ch->ethos != 1) correct = 0;
mprog.c:      if ( !IS_GOOD(ch) && ch->ethos != 2) correct = 0;
mprog.c:         if ( !IS_EVIL(ch) && ch->ethos != 3) correct = 0;
mprog.c:         if ( !IS_EVIL(ch) && ch->ethos != 2) correct = 0;
mprog.c:         if ( !IS_NEUTRAL(ch) && ch->ethos != 2) correct = 0;
mprog.c:    ch->religion = chosen;
mprog.c:                religion_table[ch->religion].leader);
mprog.c:  sprintf(arg,"smile %s",ch->name);
mprog.c:  for(ch=room->people; ch!=NULL; ch=ch->next_in_room)  {
mprog.c:    if ( ch->pIndexData->vnum == 3003 ) break;
mprog.c:  ch->status = MOB_STAT_SERVANT_LATE;
mprog.c:  if ( ch->pIndexData->vnum == MOB_VNUM_CITYGUARD )  {
mprog.c:	&& (ch->status!=6))  
mprog.c:      ch->status = 6;
mprog.c:	&& ch->status != 6)  
mprog.c:      ch->status = 6;
mprog.c:        if ( ch->sex == 1 )  {
mprog.c:        if ( ch->sex == 2 )  {
mprog.c:  if ( ch->pIndexData->vnum == MOB_VNUM_VAGABOND )
mprog.c:  if ( ch->pIndexData->vnum != 3164 )
mprog.c:      do_murder(mob, ch->name);
mprog.c:      (ch->pIndexData->vnum == 3165 || ch->pIndexData->vnum == 3011)
mprog.c:    ch->hit  = ch->max_hit;
mprog.c:      (ch->pIndexData->vnum == 3165 || ch->pIndexData->vnum == 3011)
mprog.c:    ch->hit  = ch->max_hit;
mprog.c:      sprintf(log_buf,"%s has tried to solve the dress quest.",ch->name);
mprog.c:      sprintf(buf, "papers %s", ch->name);
mprog.c:      sprintf(log_buf,"%s has tried to solve the dress quest.",ch->name);
mprog.c:      sprintf(buf, "xxx %s",ch->name);
mprog.c:      do_murder(mob, ch->name);
mprog.c:      sprintf(log_buf,"%s has tried to solve the dress quest.",ch->name);
mprog.c:      if ( !IS_SET( ch->quest, QUEST_GOLEM ) )  {
mprog.c:         SET_BIT( ch->quest, QUEST_GOLEM );
mprog.c:	sprintf(log_buf,"%s has solved the golem quest.",ch->name);
mprog.c:      sprintf(buf,"saangreal %s",ch->name);
mprog.c:      sprintf(buf,"{YAriana shouts: Thanks brave %s!!\n",ch->name);
mprog.c:	sprintf(buf,"I can bring you to one for %d gold.",ch->level*2);
mprog.c:	  ch->gold = UMAX(0, (ch->gold + (2*amount)));
mprog.c:      if (ch->gold < amount)
mprog.c:	      ch->gold -= amount;
mprog.c:	      ch->gold += amount;
mprog.c:  if ((ch->kingdom == KINGDOM_GEMMA) && (mob->kingdom == KINGDOM_GEMMA)){
mprog.c:  if ((ch->kingdom == KINGDOM_HORDE) && (mob->kingdom == KINGDOM_HORDE)) {
mprog.c:  if ((ch->kingdom == KINGDOM_GONDOR) && (mob->kingdom == KINGDOM_GONDOR)){
mprog.c:    sprintf(buf,"bow %s",ch->name);
mprog.c:  if ((ch->kingdom == KINGDOM_ALDON) && (mob->kingdom == KINGDOM_ALDON)){
mprog.c:    sprintf(buf,"Hail brother of magic, %s",ch->name);
mprog.c:  if ((ch->kingdom == KINGDOM_MORDUKHAN) && (mob->kingdom == KINGDOM_MORDUKHAN)) {
mprog.c:if ((ch->kingdom == KINGDOM_ARGUS) && (mob->kingdom == KINGDOM_ARGUS)) {
mprog.c:  if (ch->last_death_time != -1 && current_time - ch->last_death_time < 600)
mprog.c:      do_slay(mob, ch->name);
mprog.c:  do_murder(mob, ch->name);
mprog.c:    free_string( ch->pcdata->title );ch->pcdata->title = str_dup( buf );
mprog.c:    do_follow(mob, ch->name);
mprog.c:      sprintf(log_buf,"%s has tried to solve the dress quest.",ch->name);
mprog.c:    if ( ch->position != POS_FIGHTING )
mprog.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
mprog.c:spell_charm_person( skill_lookup( "charm" ), ch->level,ch,victim,TARGET_CHAR);
mprog.c:/* spell_charm_person(gsn_charm_person, ch->level, ch, victim );*/
objdump.c: ch->in_room is NULL (but when is it?)
objdump.c:			printarea (fp, ch->in_room->area);
olc.c:    switch (ch->desc->editor)
olc.c:    switch ( ch->desc->editor )
olc.c:	pArea = (AREA_DATA *)ch->desc->pEdit;
olc.c:	pRoom = ch->in_room;
olc.c:	pObj = (OBJ_INDEX_DATA *)ch->desc->pEdit;
olc.c:	pMob = (MOB_INDEX_DATA *)ch->desc->pEdit;
olc.c:        pMprog = (MPROG_CODE *)ch->desc->pEdit;
olc.c:    switch (ch->desc->editor)
olc.c:    ch->desc->pEdit = NULL;
olc.c:    ch->desc->editor = 0;
olc.c:    pArea      = ch->in_room->area;
olc.c:		if ( ch->pcdata->security < 9 )
olc.c:       ch->desc->editor = ED_AREA;
olc.c:    ch->desc->pEdit = (void *)pArea;
olc.c:    ch->desc->editor = ED_AREA;
olc.c:    pRoom = ch->in_room;
olc.c:	     ch->desc->editor = ED_ROOM;
olc.c:	    char_to_room( ch, ch->desc->pEdit );
olc.c:	SET_BIT( ((ROOM_INDEX_DATA *)ch->desc->pEdit)->area->area_flags,AREA_CHANGED );
olc.c:    ch->desc->pEdit    = (void *) pRoom;
olc.c:    ch->desc->editor   = ED_ROOM;
olc.c:	ch->desc->pEdit = (void *)pObj;
olc.c:	ch->desc->editor = ED_OBJECT;
olc.c:		ch->desc->editor = ED_OBJECT;
olc.c:	ch->desc->pEdit = (void *)pMob;
olc.c:	ch->desc->editor = ED_MOBILE;
olc.c:		ch->desc->editor = ED_MOBILE;
olc.c:if (ch->pcdata->security < 5 ) {
olc.c:	ch->desc->editor = ED_HELP;
olc.c:	ch->desc->editor = ED_HELP;
olc.c:	ch->desc->editor = ED_HELP;
olc.c:	ch->desc->editor = ED_HELP;
olc.c:                ch->desc->pEdit = (void *)pHelp;
olc.c:                ch->desc->editor = ED_HELP;
olc.c:	ch->desc->editor = ED_HELP;
olc.c:    if ( !IS_BUILDER( ch, ch->in_room->area ) )
olc.c:	if ( ch->in_room->reset_first )
olc.c:	ROOM_INDEX_DATA *pRoom = ch->in_room;
olc.c:	    if ( !ch->in_room->reset_first )
olc.c:SET_BIT( ch->in_room->area->area_flags, AREA_CHANGED );
olc.c:		pReset->arg3    = ch->in_room->vnum;
olc.c:		    pReset->arg3     = ch->in_room->vnum;
olc.c:	    add_reset( ch->in_room, pReset, atoi( arg1 ) );
olc.c:	    SET_BIT( ch->in_room->area->area_flags, AREA_CHANGED );
olc.c:		pReset->arg1 = ch->in_room->vnum;
olc.c:		add_reset( ch->in_room, pReset, atoi( arg1 ) );
olc.c:		SET_BIT( ch->in_room->area->area_flags, AREA_CHANGED );
olc_act.c:    pArea = ch->in_room->area;
olc_act.c:    pArea = ch->in_room->area;
olc_act.c:    pArea = ch->in_room->area;
olc_act.c:	ch->desc->pEdit = (void *)pMob;
olc_act.c:    ch->desc->pEdit = (void *)ch->in_room;
olc_act.c:	ch->desc->pEdit = (void *)pObj;
olc_act.c:    ch->desc->pEdit = (void *)ch->in_room;
olc_act.c:    if(ch->pcdata->security > 9) {
olc_act.c:    ch->desc->pEdit     =   (void *)pArea;
olc_act.c:    if ( value > ch->pcdata->security || value < 0 )
olc_act.c:	if ( ch->pcdata->security != 0 )
olc_act.c:	    sprintf( buf, "Security is 0-%d.{x\n\r", ch->pcdata->security );
olc_act.c:    if (ch->pcdata->security < 9) {
olc_act.c:    for ( rch = pRoom->people; rch; rch = rch->next_in_room )
olc_act.c:	one_argument( rch->name, buf );
olc_act.c:	pExit->u1.to_room       = ch->in_room;
olc_act.c:/*	pExit->vnum             = ch->in_room->vnum;    Can't set vnum in ROM */
olc_act.c:    ch->desc->pEdit		= (void *)pRoom;
olc_act.c:    ch->desc->pEdit		= (void *)pObj;
olc_act.c:    ch->desc->pEdit		= (void *)pMob;
olc_act.c:        if( ch->in_room->vnum == index )
olc_act.c:                if( ch->fighting != NULL )
olc_act.c:                ch->was_in_room = ch->in_room;
olc_act.c:                wnext = wch->next_in_room;
olc_act.c:                        if( wch->fighting != NULL )
olc_act.c:                        wch->was_in_room = wch->in_room;
olc_act.c:        ch->desc->pEdit         = (void *)tHelp;
olc_act.c: ch->desc->pEdit                = (void *)pHelp;
olc_mpcode.c:	ch->desc->pEdit		= (void *)pMcode;
olc_mpcode.c:	ch->desc->editor	= ED_MPCODE;
olc_mpcode.c:    ch->desc->pEdit		= (void *)pMcode;
olc_mpcode.c:    ch->desc->editor		= ED_MPCODE;
olc_mpcode.c:	if ( fAll || ENTRE(ch->in_room->area->min_vnum, mprg->vnum, ch->in_room->area->max_vnum) )
olc_save.c:    	sec = ch->pcdata->security;
olc_save.c:	if ( !ch || !ch->desc )
olc_save.c:	if ( ch->desc->editor == ED_NONE )
olc_save.c:	switch (ch->desc->editor)
olc_save.c:		pArea = (AREA_DATA *)ch->desc->pEdit;
olc_save.c:		pArea = ch->in_room->area;
olc_save.c:		pArea = ( (OBJ_INDEX_DATA *)ch->desc->pEdit )->area;
olc_save.c:		pArea = ( (MOB_INDEX_DATA *)ch->desc->pEdit )->area;
olc_save.c:		pArea = ch->in_room->area;
quest.c:  { "10,000 Gold Pieces",     "10000 gold",	500, FALSE, 10000,&ch->gold},
quest.c:  { "4 Practices",    	       "practices", 	500, FALSE, 4, &ch->practice},
quest.c:  { "Mark of your God",		"mark",	1000,TRUE,religion_table[ch->religion].vnum,0},
quest.c:	if (IS_SET(ch->act,PLR_QUESTOR))
quest.c:	    if (ch->questmob == -1 && 
quest.c:		ch->questgiver->short_descr != NULL) {
quest.c:	        sprintf(buf,"Your job is ALMOST complete!\n\rGet back to %s before your time runs out!\n\r",ch->questgiver->short_descr);
quest.c:	    else if (ch->questobj > 0)
quest.c:                questinfoobj = get_obj_index(ch->questobj);
quest.c:	    else if (ch->questmob > 0)
quest.c:                questinfo = get_mob_index(ch->questmob);
quest.c:	if (!IS_SET(ch->act,PLR_QUESTOR))
quest.c:	    if (ch->nextquest > 1) {
quest.c:	        sprintf(buf,"There are %d minutes remaining until you can go on another job.\n\r",ch->nextquest);
quest.c:	    else if (ch->nextquest == 1) {
quest.c:        else if (ch->countdown > 0)
quest.c:	    sprintf(buf, "Time left for current job: %d\n\r",ch->countdown);
quest.c:    for ( questman = ch->in_room->people; questman != NULL; questman = questman->next_in_room )
quest.c:    ch->questgiver = questman;
quest.c:	    if (ch->quest_curr >= reward_table[i].cost)
quest.c:		ch->quest_curr -= reward_table[i].cost;
quest.c:			(ch->religion < 1) && (ch->religion < MAX_RELIGION)) {
quest.c:	            obj = create_object(get_obj_index(reward_table[i].value),ch->level); }
quest.c:		sprintf(buf, "Sorry, %s, but you don't have enough glory for that.",ch->name);
quest.c:	    sprintf(buf, "I don't have that item, %s.",ch->name);
quest.c:	if (IS_SET(ch->act,PLR_QUESTOR))
quest.c:	if (ch->nextquest > 0)
quest.c:	    sprintf(buf, "There is nothing you can do for me right now, %s",ch->name);
quest.c:	sprintf(buf, "Thank you %s, you are truly wise in politics.",ch->name);
quest.c:	if (!IS_SET(ch->act,PLR_QUESTOR))
quest.c:        ch->questmob = 0;
quest.c:	ch->questobj = 0;
quest.c:        if (ch->questmob > 0 || ch->questobj > 0)
quest.c:            ch->countdown = number_range(10,30);
quest.c:	    SET_BIT(ch->act,PLR_QUESTOR);
quest.c:	    sprintf(buf, "You have %d minutes to complete this job.",ch->countdown);
quest.c:	if (ch->questgiver != questman)
quest.c:	if (IS_SET(ch->act,PLR_QUESTOR))
quest.c:	    if (ch->questobj > 0 && ch->countdown > 0)
quest.c:    		for (obj = ch->carrying; obj != NULL; obj= obj_next)
quest.c:		    if (obj != NULL && obj->pIndexData->vnum == ch->questobj)
quest.c:     if ((ch->questmob == -1 || (ch->questobj && obj_found)) 
quest.c:	&& ch->countdown > 0)
quest.c:		level = ch->level;
quest.c:	        REMOVE_BIT(ch->act,PLR_QUESTOR);
quest.c:	        ch->questgiver = NULL;
quest.c:	        ch->countdown = 0;
quest.c:	        ch->questmob = 0;
quest.c:		ch->questobj = 0;
quest.c:	        ch->nextquest = 10;
quest.c:		ch->gold += reward;
quest.c:		ch->quest_curr += pointreward;
quest.c:		ch->quest_accum += pointreward;
quest.c:     else if((ch->questmob > 0 || ch->questobj > 0)
quest.c:          && ch->countdown > 0)
quest.c:	if (ch->nextquest > 0)
quest.c:	else sprintf(buf, "You have to request a job first, %s.",ch->name);
quest.c:	if (ch->questgiver != questman)
quest.c:	if (IS_SET(ch->act,PLR_QUESTOR))
quest.c:            REMOVE_BIT(ch->act,PLR_QUESTOR);
quest.c:            ch->questgiver = NULL;
quest.c:            ch->countdown = 0;
quest.c:            ch->questmob = 0;
quest.c:	    ch->questobj = 0;
quest.c:            ch->nextquest = 30;
quest.c:            if (quest_level_diff(ch->level, vsearch->level) == TRUE
quest.c:                && vsearch->pShop == NULL
quest.c:    		&& !IS_SET(vsearch->act, ACT_TRAIN)
quest.c:    		&& !IS_SET(vsearch->act, ACT_PRACTICE)
quest.c:    		&& !IS_SET(vsearch->act, ACT_IS_HEALER)
quest.c:		&& !IS_SET(vsearch->act, ACT_PET)
quest.c:		&& !IS_SET(vsearch->affected_by, AFF_CHARM)
quest.c:		&& !IS_SET(vsearch->affected_by, AFF_INVISIBLE)
quest.c:    if (( vsearch == NULL || ( victim = get_char_world( ch, vsearch->player_name ) ) == NULL )
quest.c:	ch->nextquest = 2;
quest.c:	ch->nextquest = 2;
quest.c:        questitem = create_object( get_obj_index(QUEST_OBJ), ch->level ); 
quest.c:	ch->questobj = questitem->pIndexData->vnum;
quest.c:    ch->questmob = victim->pIndexData->vnum;
quest.c:        if (ch->nextquest > 0)
quest.c:            ch->nextquest--;
quest.c:            if (ch->nextquest == 0)
quest.c:        else if (IS_SET(ch->act,PLR_QUESTOR))
quest.c:            if (--ch->countdown <= 0)
quest.c:                ch->nextquest = 10;
quest.c:                sprintf(buf,"You have run out of time for your job!\n\rYou may try again in %d minutes.\n\r",ch->nextquest);
quest.c:                REMOVE_BIT(ch->act,PLR_QUESTOR);
quest.c:                ch->questgiver = NULL;
quest.c:                ch->countdown = 0;
quest.c:                ch->questmob = 0;
quest.c:                ch->questobj = 0;
quest.c:            if (ch->countdown > 0 && ch->countdown < 6)
quest.c:  if( ch->pcdata->quest == NULL )
quest.c:         ( ( !ch->pcdata->quest->closed &&
quest.c:             victim->level >= ch->pcdata->quest->min_level &&
quest.c:             victim->level <= ch->pcdata->quest->max_level ) ||
quest.c:  if( ch->pcdata->quest == NULL )
quest.c:  if ( ch->desc->original )
quest.c:      if( ch->pcdata->quest == NULL )
quest.c:        if( !ch->pcdata->quest->closed )
quest.c:    if( ch->pcdata->quest == NULL )
quest.c:      if( !ch->pcdata->quest->closed )
quest.c:  quest = ch->pcdata->quest = alloc_mem( sizeof( QUEST_DATA ) );
quest.c:    QUEST_DATA *quest = ch->pcdata->quest;
quest.c:    ch->pcdata->quest->closed = TRUE;
quest.c:    QUEST_DATA *quest = ch->pcdata->quest;
quest.c:    QUEST_DATA *quest = ch->pcdata->quest;
quest.c:    QUEST_DATA *quest = ch->pcdata->quest;
quest.c:    QUEST_DATA *quest = ch->pcdata->quest;
quest.c:    QUEST_DATA *quest = ch->pcdata->quest;
quest.c:    QUEST_DATA *quest = ch->pcdata->quest;
quest.c:    QUEST_DATA *quest = ch->pcdata->quest;
quest.c:    free_mem( ch->pcdata->quest, sizeof( QUEST_DATA ) );
quest.c:    ch->pcdata->quest = NULL;
quest.c:    QUEST_DATA *quest = ch->pcdata->quest;
quest.c:    if( ch->pcdata->quest == NULL )
quest.c:    if( victim->pcdata->quest_apply != ch->pcdata->quest )
quest.c:    victim->pcdata->quest = ch->pcdata->quest;
quest.c:    if( ch->pcdata->quest == NULL )
quest.c:    if( victim->pcdata->quest != ch->pcdata->quest )
quest.c:    if( ch->pcdata->quest != NULL )
quest.c:          if( ch->level > victim->pcdata->quest->max_level ||
quest.c:              ch->level < victim->pcdata->quest->min_level )
quest.c:          ch->pcdata->quest_apply = victim->pcdata->quest;
quest.c:       sprintf(buf, "You have applied to be in the {g%s{w quest.\r\n",ch->pcdata->quest_apply->name);
quest.c:       sprintf(buf, "%s has applied for your quest.\r\n", ch->name);
quest.c:       send_to_char(buf, ch->pcdata->quest_apply->quest_god);
quest.c:    if( ch->pcdata->quest == NULL )
quest.c:        do_font(ch,ch->pcdata->quest->name);
quest.c:        send_to_char(ch->pcdata->quest->long_name,ch);
quest.c:       sprintf(buf,"Other players in quest %s are{W:{w\r\n",ch->pcdata->quest->name);
quest.c:               victim->pcdata->quest == ch->pcdata->quest)
quest.c:    if( ch->pcdata->quest == NULL )
quest.c:    sprintf(buf, "%s has quit from the Quest.",ch->name);
quest.c:    send_to_quest(buf,ch->pcdata->quest->quest_god);
quest.c:    send_to_char(buf,ch->pcdata->quest->quest_god);
quest.c:    ch->pcdata->quest = NULL;
recycle.c:    ch->name                    = &str_empty[0];
recycle.c:    ch->short_descr             = &str_empty[0];
recycle.c:    ch->long_descr              = &str_empty[0];
recycle.c:    ch->description             = &str_empty[0];
recycle.c:    ch->prompt                  = &str_empty[0];
recycle.c:    ch->prefix			= &str_empty[0];
recycle.c:    ch->logon                   = current_time;
recycle.c:    ch->lines                   = PAGELEN;
recycle.c:        ch->armor[i]            = 100;
recycle.c:    ch->position                = POS_STANDING;
recycle.c:    ch->hit                     = 20;
recycle.c:    ch->max_hit                 = 20;
recycle.c:    ch->mana                    = 100;
recycle.c:    ch->max_mana                = 100;
recycle.c:    ch->move                    = 100;
recycle.c:    ch->max_move                = 100;
recycle.c:    ch->ethos			= 0;
recycle.c:    ch->kingdom			= 0;
recycle.c:    ch->kingdom_rank		= 0;
recycle.c:    ch->hometown		= 0;
recycle.c:    ch->guarded_by		= NULL;
recycle.c:    ch->guarding		= NULL;
recycle.c:    ch->doppel			= NULL;
recycle.c:        ch->perm_stat[i] = 13;
recycle.c:        ch->mod_stat[i] = 0;
recycle.c:    for (obj = ch->carrying; obj != NULL; obj = obj_next)
recycle.c:    for (paf = ch->affected; paf != NULL; paf = paf_next)
recycle.c:    free_string(ch->name);
recycle.c:    free_string(ch->short_descr);
recycle.c:    free_string(ch->long_descr);
recycle.c:    free_string(ch->description);
recycle.c:    free_string(ch->prompt);
recycle.c:    free_string(ch->prefix);
recycle.c:    if (ch->pcdata != NULL)
recycle.c:    	free_pcdata(ch->pcdata);
recycle.c:    ch->next = char_free;
save.c:if (ch->level < 2)
save.c:    if ( ch->desc != NULL && ch->desc->original != NULL )
save.c:	ch = ch->desc->original;
save.c:    if (IS_IMMORTAL(ch) || ch->level >= LEVEL_IMMORTAL)
save.c:	sprintf(strsave, "%s%s",GOD_DIR, capitalize(ch->name));
save.c:	    ch->level, get_trust(ch), 
save.c:	ch->pcdata->pretitle,ch->name, ch->pcdata->title);
save.c:    sprintf( strsave, "%s%s", PLAYER_DIR, capitalize( ch->name ) );
save.c:	if ( ch->carrying != NULL )
save.c:	    fwrite_obj( ch, ch->carrying, fp, 0 );
save.c:	if (ch->pet != NULL && ch->pet->in_room == ch->in_room)
save.c:	    fwrite_pet(ch->pet,fp);
save.c:    fprintf( fp, "Name %s~\n",	ch->name		);
save.c:    fprintf( fp, "Id   %ld\n", ch->id			);
save.c:    if(ch->pcdata->host != NULL)
save.c:    fprintf( fp, "Host %s~\n",	ch->pcdata->host	);
save.c:    fprintf( fp, "Etho %d\n",   ch->ethos		);
save.c:    fprintf( fp, "Home %d\n",   ch->hometown		);
save.c:    fprintf( fp, "Sign %s~\n",   ch->pcdata->sign	);
save.c:    fprintf( fp, "Pks  %d\n",  ch->pcdata->pkills	);
save.c:    fprintf( fp, "Bnty %d\n",  ch->pcdata->bounty	);
save.c:    fprintf( fp, "Owed %d\n",  ch->pcdata->owed 	);
save.c:    fprintf( fp, "Cab  %d\n",   ch->kingdom		);
save.c:    fprintf( fp, "Rank %d\n",   ch->kingdom_rank	);
save.c:    fprintf( fp, "Dead %d\n",   ch->pcdata->death	);
save.c:    fprintf( fp, "TD   %d\n",   ch->pcdata->total_death );
save.c:    fprintf( fp, "Ques %d\n", 	ch->quest		);
save.c: if (ch->kincom)
save.c:        fprintf( fp, "Kincom %s\n",   print_flags(ch->kincom));
save.c:    if (ch->short_descr[0] != '\0')
save.c:      	fprintf( fp, "ShD  %s~\n",	ch->short_descr	);
save.c:    if( ch->long_descr[0] != '\0')
save.c:	fprintf( fp, "LnD  %s~\n",	ch->long_descr	);
save.c:    if (ch->description[0] != '\0')
save.c:    	fprintf( fp, "Desc %s~\n",	ch->description	);
save.c:    if (ch->immtitle != NULL)
save.c:        fprintf( fp, "Immtitle %s~\n",  ch->immtitle);
save.c:    if (ch->pcdata->background[0] != '\0')
save.c:    	fprintf( fp, "Back %s~\n",	ch->pcdata->background	);
save.c:    if (ch->prompt != NULL || !str_cmp(ch->prompt,"%1 {Rhp %2 {Bm %3 {Gmv{w "))
save.c:        fprintf( fp, "Prom %s~\n",      ch->prompt  	);
save.c:    fprintf( fp, "Race %s~\n", pc_race_table[ch->race].name );
save.c:    fprintf( fp, "Sex  %d\n",	ch->sex			);
save.c:    fprintf( fp, "Cla  %d\n",	ch->class		);
save.c:    fprintf( fp, "Levl %d\n",	ch->level		);
save.c:    if (ch->trust != 0)
save.c:	fprintf( fp, "Tru  %d\n",	ch->trust	);
save.c:    fprintf( fp, "Sec  %d\n",    ch->pcdata->security	);	/* OLC */
save.c:	ch->played + (int) (current_time - ch->logon)	);
save.c:    fprintf( fp, "Scro %d\n", 	ch->lines		);
save.c:        (  ch->in_room == get_room_index( ROOM_VNUM_LIMBO )
save.c:        && ch->was_in_room != NULL )
save.c:            ? ch->was_in_room->vnum
save.c:            : ch->in_room == NULL ? 3001 : ch->in_room->vnum );
save.c:	ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move );
save.c:    if (ch->gold > 0)
save.c:      fprintf( fp, "Gold %ld\n",	ch->gold		);
save.c:    if (ch->silver > 0)
save.c:	fprintf( fp, "Silv %ld\n",ch->silver		);
save.c:    if (ch->pkban == 1)
save.c:    fprintf( fp, "Pkban %d\n", ch->pkban);
save.c:    fprintf( fp, "Banks %ld\n", ch->pcdata->bank_s );
save.c:    fprintf( fp, "Bankg %ld\n", ch->pcdata->bank_g );
save.c:    fprintf( fp, "Exp  %d\n",	ch->exp			);
save.c:    if (ch->act != 0)
save.c:	fprintf( fp, "Act  %s\n",   print_flags(ch->act));
save.c:    if (ch->affected_by != 0)
save.c:	fprintf( fp, "AfBy %s\n",   print_flags(ch->affected_by));
save.c:    if (ch->affected_by2 != 0)
save.c:	fprintf( fp, "AfBy2 %s\n", print_flags(ch->affected_by2));
save.c:    if (ch->detection != 0)
save.c:	fprintf( fp, "AfDetect %s\n", print_flags(ch->detection));
save.c:    fprintf( fp, "Comm %s\n",       print_flags(ch->comm));
save.c:    if (ch->wiznet)
save.c:    	fprintf( fp, "Wizn %s\n",   print_flags(ch->wiznet));
save.c:  if (ch->info)
save.c:        fprintf( fp, "Info %s\n",   print_flags(ch->info));
save.c:    if (ch->invis_level)
save.c:	fprintf( fp, "Invi %d\n", 	ch->invis_level	);
save.c:    if (ch->incog_level)
save.c:	fprintf(fp,"Inco %d\n",ch->incog_level);
save.c:    if (ch->lastpk)
save.c:	fprintf(fp,"LastPk %ld\n",ch->lastpk);
save.c:    if (ch->lastkingdom)
save.c:	fprintf(fp,"LastKi %ld\n",ch->lastkingdom);
save.c:    if (ch->pcdata->spouse)
save.c:    fprintf( fp, "Spouse %s~\n", ch->pcdata->spouse );	
save.c:	ch->position == POS_FIGHTING ? POS_STANDING : ch->position );
save.c:    if (ch->practice != 0)
save.c:    	fprintf( fp, "Prac %d\n",	ch->practice	);
save.c:    if (ch->train != 0)
save.c:	fprintf( fp, "Trai %d\n",	ch->train	);
save.c:    if (ch->saving_throw != 0)
save.c:	fprintf( fp, "Save  %d\n",	ch->saving_throw);
save.c:    fprintf( fp, "Alig  %d\n",	ch->alignment		);
save.c:    if (ch->hitroll != 0)
save.c:	fprintf( fp, "Hit   %d\n",	ch->hitroll	);
save.c:    if (ch->damroll != 0)
save.c:	fprintf( fp, "Dam   %d\n",	ch->damroll	);
save.c:	ch->armor[0],ch->armor[1],ch->armor[2],ch->armor[3]);
save.c:    if (ch->wimpy !=0 )
save.c:	fprintf( fp, "Wimp  %d\n",	ch->wimpy	);
save.c:    if (ch->msp != 0)
save.c:	fprintf( fp, "MSP  %d\n",	ch->msp		);
save.c:	ch->perm_stat[STAT_STR],
save.c:	ch->perm_stat[STAT_INT],
save.c:	ch->perm_stat[STAT_WIS],
save.c:	ch->perm_stat[STAT_DEX],
save.c:	ch->perm_stat[STAT_CON] );
save.c:	ch->mod_stat[STAT_STR],
save.c:	ch->mod_stat[STAT_INT],
save.c:	ch->mod_stat[STAT_WIS],
save.c:	ch->mod_stat[STAT_DEX],
save.c:	ch->mod_stat[STAT_CON] );
save.c:	fprintf( fp, "Vnum %d\n",	ch->pIndexData->vnum	);
save.c:	fprintf( fp, "Pass %s~\n",	ch->pcdata->pwd		);
save.c:	if(ch->pcdata->real_name != NULL)
save.c:	fprintf( fp, "Real %s~\n",	ch->pcdata->real_name	);
save.c:	if(ch->pcdata->email != NULL)
save.c:	fprintf( fp, "Email %s~\n",	ch->pcdata->email	);
save.c:	if (ch->pcdata->bamfin[0] != '\0')
save.c:	    fprintf( fp, "Bin  %s~\n",	ch->pcdata->bamfin);
save.c:	if (ch->pcdata->bamfout[0] != '\0')
save.c:		fprintf( fp, "Bout %s~\n",	ch->pcdata->bamfout);
save.c:	fprintf( fp, "Titl %s~\n",	ch->pcdata->title	);
save.c:	fprintf( fp, "Pretit %s~\n",	ch->pcdata->pretitle	);
save.c:    	fprintf( fp, "Pnts %d\n",   	ch->pcdata->points      );
save.c:	fprintf( fp, "TSex %d\n",	ch->pcdata->true_sex	);
save.c:	fprintf( fp, "LLev %d\n",	ch->pcdata->last_level	);
save.c:	if(ch->sitelock)
save.c:	fprintf( fp, "Sitelock %s~\n",  ch->sitelock		);
save.c:	fprintf( fp, "HMVP %d %d %d\n", ch->pcdata->perm_hit,
save.c:						   ch->pcdata->perm_mana,
save.c:						   ch->pcdata->perm_move);
save.c:	    ch->pcdata->condition[0],
save.c:	    ch->pcdata->condition[1],
save.c:	    ch->pcdata->condition[2],
save.c:	    ch->pcdata->condition[3] );
save.c:  fprintf( fp, "Auth %ld %ld %ld\n", ch->pcdata->authorized[0],
save.c:                                           ch->pcdata->authorized[1],
save.c:                                           ch->pcdata->authorized[2]);
save.c: 		fprintf (fp, "%s %ld ", boards[i].short_name, ch->pcdata->last_note[i]);
save.c:	    if (ch->pcdata->alias[pos] == NULL
save.c:	    ||  ch->pcdata->alias_sub[pos] == NULL)
save.c:	    fprintf(fp,"Alias %s %s~\n",ch->pcdata->alias[pos],
save.c:		    ch->pcdata->alias_sub[pos]);
save.c:	    if ( skill_table[sn].name != NULL && ch->pcdata->learned[sn] > 0 )
save.c:		    ch->pcdata->learned[sn], skill_table[sn].name );
save.c:    if (ch->questpoints != 0)
save.c:        fprintf( fp, "QuestPnts %d\n",  ch->questpoints );
save.c:    if(ch->quest_curr != 0)
save.c:	fprintf(fp, "QuestCurr %d\n", ch->quest_curr );
save.c:    if(ch->quest_accum != 0)
save.c:	fprintf(fp, "QuestAcc %d\n", ch->quest_accum );
save.c:    if (ch->nextquest != 0)
save.c:        fprintf( fp, "QuestNext %d\n",  ch->nextquest   );
save.c:    else if (ch->countdown != 0)
save.c:    for ( paf = ch->affected; paf != NULL; paf = paf->next )
save.c:   fprintf( fp ,"Relig %d\n",          ch->religion            );
save.c:    ch->pcdata = new_pcdata();
save.c:    ch->desc				= d;
save.c:    ch->name				= str_dup( name );
save.c:    ch->id				= get_pc_id();
save.c:    ch->race				= race_lookup("human");
save.c:    ch->kingdom                           = 0;
save.c:    ch->kingdom_rank                      = 0;
save.c:    ch->hometown                        = 0;
save.c:    ch->pcdata->sign                    = 0;
save.c:    ch->pcdata->pkills                  = 0;
save.c:    ch->prompt 				= str_dup("<{R%1 {M%2 {G%3>{w ");
save.c:    ch->pcdata->total_death             = 0;
save.c:    ch->pcdata->bounty			= 0;
save.c:    ch->pcdata->owed			= 0;
save.c:    ch->ethos                           = 0;
save.c:    ch->affected_by                     = 0;
save.c:    ch->affected_by2                    = 0;
save.c:    ch->act				= PLR_NOSUMMON
save.c: 	ch->pcdata->board		= &boards[DEFAULT_BOARD];
save.c:    ch->comm				= COMM_COMBINE
save.c:    ch->msp				= 0;
save.c:    ch->invis_level                     = 0;
save.c:    ch->practice                        = 0;
save.c:    ch->train                           = 0;
save.c:    ch->hitroll                         = 0;
save.c:    ch->damroll                         = 0;
save.c:    ch->trust                           = 0;
save.c:    ch->wimpy                           = 0;
save.c:    ch->lastpk				= 800000;
save.c:    ch->lastkingdom			= 800000;
save.c:    ch->saving_throw                    = 0;
save.c:    ch->progtypes                       = 0; /* PCs don't have programs */
save.c:    ch->extracted                       = FALSE; /* check for two extracts */
save.c:    ch->pcdata->points                  = 0;
save.c:    ch->pcdata->confirm_delete		= FALSE;
save.c:    ch->pcdata->pwd			= str_dup( "" );
save.c:    ch->pcdata->bamfin			= str_dup( "" );
save.c:    ch->pcdata->bamfout			= str_dup( "" );
save.c:    ch->pcdata->title			= str_dup( "" );
save.c:    ch->pcdata->pretitle		= str_dup( "" );
save.c:    ch->religion 			= RELIGION_NONE;
save.c:	ch->perm_stat[stat]		= 13;
save.c:    ch->pcdata->condition[COND_DRUNK]	= -6;
save.c:    ch->pcdata->condition[COND_THIRST]	= 48;
save.c:    ch->pcdata->condition[COND_FULL]	= 48;
save.c:    ch->pcdata->condition[COND_HUNGER]	= 48;
save.c:    ch->pcdata->condition[COND_BLOODLUST] = 48;
save.c:    ch->pcdata->security		= 0;	/* OLC */
save.c:    ch->pcdata->authorized[0]           = 0;
save.c:    ch->pcdata->authorized[1]           = 0;
save.c:    ch->pcdata->authorized[2]           = 0;
save.c:    ch->riding  = FALSE;
save.c:    ch->mount   = NULL;
save.c:    ch->hunting = NULL;
save.c:    ch->nextquest = 0;
save.c:    ch->questpoints = 0;
save.c:    ch->quest_curr = 0;
save.c:    ch->quest_accum = 0;
save.c:    ch->countdown = 0;
save.c:    ch->questobj = 0;
save.c:    ch->questmob = 0;
save.c:    ch->timer   = 0;
save.c:    ch->pking	= 0;
save.c:	if (ch->race == 0)
save.c:	    ch->race = race_lookup("human");
save.c:	ch->size = pc_race_table[ch->race].size;
save.c:	ch->dam_type = 17; /*punch */
save.c:	ch->affected_by = ch->affected_by|race_table[ch->race].aff;
save.c:	ch->affected_by2= ch->affected_by2|race_table[ch->race].aff2;
save.c:	ch->detection   = ch->detection|race_table[ch->race].detect;
save.c:	ch->imm_flags	= ch->imm_flags | race_table[ch->race].imm;
save.c:	ch->res_flags	= ch->res_flags | race_table[ch->race].res;
save.c:	ch->vuln_flags	= ch->vuln_flags | race_table[ch->race].vuln;
save.c:	ch->form	= race_table[ch->race].form;
save.c:	ch->parts	= race_table[ch->race].parts;
save.c:    if (found && ch->version < 3 && (ch->level > 35 || ch->trust > 35))
save.c:	switch (ch->level)
save.c:	    case(40) : ch->level = 60;	break;  /* imp -> imp */
save.c:	    case(39) : ch->level = 58; 	break;	/* god -> supreme */
save.c:	    case(38) : ch->level = 56;  break;	/* deity -> god */
save.c:	    case(37) : ch->level = 53;  break;	/* angel -> demigod */
save.c:        switch (ch->trust)
save.c:            case(40) : ch->trust = 60;  break;	/* imp -> imp */
save.c:            case(39) : ch->trust = 58;  break;	/* god -> supreme */
save.c:            case(38) : ch->trust = 56;  break;	/* deity -> god */
save.c:            case(37) : ch->trust = 53;  break;	/* angel -> demigod */
save.c:            case(36) : ch->trust = 51;  break;	/* hero -> hero */
save.c:    if (found && ch->version < 4)
save.c:	ch->gold   /= 100;
save.c:    if (found && ch->version < 6 )
save.c:	ch->pcdata->learned[gsn_spell_craft] = 1;
save.c:    sprintf(buf,"Loading %s.",ch->name);
save.c:    ch->pcdata->bank_s = 0;
save.c:    ch->pcdata->bank_g = 0;
save.c:    ch->pcdata->background =
save.c:	    KEY( "Act",		ch->act,		fread_flag( fp ) );
save.c:	    KEY( "AffectedBy",	ch->affected_by,	fread_flag( fp ) );
save.c:	    KEY( "AfBy",	ch->affected_by,	fread_flag( fp ) );
save.c:	    KEY( "AfBy2",	ch->affected_by2,	fread_flag( fp ) );
save.c:	    KEY( "AfDetect",	ch->detection,		fread_flag( fp ) );
save.c:	    KEY( "Alignment",	ch->alignment,		fread_number( fp ) );
save.c:	    KEY( "Alig",	ch->alignment,		fread_number( fp ) );
save.c:               ch->pcdata->authorized[0] = fread_number( fp );
save.c:               ch->pcdata->authorized[1] = fread_number( fp );
save.c:               ch->pcdata->authorized[2] = fread_number( fp );
save.c:		ch->pcdata->alias[count] 	= str_dup(fread_word(fp));
save.c:		ch->pcdata->alias_sub[count]	= str_dup(fread_word(fp));
save.c:                ch->pcdata->alias[count]        = str_dup(fread_word(fp));
save.c:                ch->pcdata->alias_sub[count]    = fread_string(fp);
save.c:		    ch->armor[i] = fread_number(fp);
save.c:		paf->next	= ch->affected;
save.c:		ch->affected	= paf;
save.c:                paf->next       = ch->affected;
save.c:                ch->affected    = paf;
save.c:		   ch->mod_stat[stat] = fread_number(fp);
save.c:		    ch->perm_stat[stat] = fread_number(fp);
save.c:	    KEY( "Back",	ch->pcdata->background,	fread_string( fp ) );  
save.c:	    KEY( "Bamfin",	ch->pcdata->bamfin,	fread_string( fp ) );
save.c:            KEY( "Banks",       ch->pcdata->bank_s,     fread_number( fp ) );
save.c:            KEY( "Bankg",       ch->pcdata->bank_g,     fread_number( fp ) );
save.c:	    KEY( "Bamfout",	ch->pcdata->bamfout,	fread_string( fp ) );
save.c:	    KEY( "Bin",		ch->pcdata->bamfin,	fread_string( fp ) );
save.c:	    KEY( "Bout",	ch->pcdata->bamfout,	fread_string( fp ) );
save.c:	    KEY( "Bnty",        ch->pcdata->bounty,	fread_number( fp ) );
save.c: 					sprintf (buf, "fread_char: %s had unknown board name: %s. Skipped.", ch->name, boardname);
save.c: 					ch->pcdata->last_note[i] = fread_number (fp);
save.c:	    KEY( "Class",	ch->class,		fread_number( fp ) );
save.c:	    KEY( "Cla",		ch->class,		fread_number( fp ) );
save.c:	    KEY( "Cab",		ch->kingdom,		fread_number( fp ) );
save.c:		ch->pcdata->condition[0] = fread_number( fp );
save.c:		ch->pcdata->condition[1] = fread_number( fp );
save.c:		ch->pcdata->condition[2] = fread_number( fp );
save.c:                ch->pcdata->condition[0] = fread_number( fp );
save.c:                ch->pcdata->condition[1] = fread_number( fp );
save.c:                ch->pcdata->condition[2] = fread_number( fp );
save.c:		ch->pcdata->condition[3] = fread_number( fp );
save.c:	    KEY("Comm",		ch->comm,		fread_flag( fp ) );
save.c:	    KEY( "Damroll",	ch->damroll,		fread_number( fp ) );
save.c:	    KEY( "Dam",		ch->damroll,		fread_number( fp ) );
save.c:	    KEY( "Description",	ch->description,	fread_string( fp ) );
save.c:	    KEY( "Desc",	ch->description,	fread_string( fp ) );
save.c:	    KEY( "Dead",	ch->pcdata->death,	fread_number( fp ) );
save.c:	    KEY( "Email",	ch->pcdata->email,	fread_string( fp ) );
save.c:        	    ch->hit	+= (ch->max_hit - ch->hit) * percent / 100;
save.c:        	    ch->mana    += (ch->max_mana - ch->mana) * percent / 100;
save.c:        	    ch->move    += (ch->max_move - ch->move)* percent / 100;
save.c:	    KEY( "Exp",		ch->exp,		fread_number( fp ) );
save.c:	    KEY( "Etho",	ch->ethos,		fread_number( fp ) );
save.c:	    KEY( "Gold",	ch->gold,		fread_number( fp ) );
save.c:	    KEY( "Hitroll",	ch->hitroll,		fread_number( fp ) );
save.c:	    KEY( "Hit",		ch->hitroll,		fread_number( fp ) );
save.c:	    KEY( "Home",	ch->hometown,		fread_number( fp ) );
save.c:	    KEY( "Host",	ch->pcdata->host,	fread_string( fp ) );
save.c:		ch->hit		= fread_number( fp );
save.c:		ch->max_hit	= fread_number( fp );
save.c:		ch->mana	= fread_number( fp );
save.c:		ch->max_mana	= fread_number( fp );
save.c:		ch->move	= fread_number( fp );
save.c:		ch->max_move	= fread_number( fp );
save.c:                ch->pcdata->perm_hit	= fread_number( fp );
save.c:                ch->pcdata->perm_mana   = fread_number( fp );
save.c:                ch->pcdata->perm_move   = fread_number( fp );
save.c:	    KEY( "Id",		ch->id,			fread_number( fp ) );
save.c:	    KEY( "InvisLevel",	ch->invis_level,	fread_number( fp ) );
save.c:	    KEY( "Inco",	ch->incog_level,	fread_number( fp ) );
save.c:  	    KEY( "Info",        ch->info,               fread_flag( fp ));   
save.c:	    KEY( "Invi",	ch->invis_level,	fread_number( fp ) );
save.c:	    KEY( "Immtitle",    ch->immtitle,           fread_string( fp ) );
save.c:	    KEY( "Kincom",	ch->kincom,  fread_flag( fp ));
save.c:	    KEY( "LastLevel",	ch->pcdata->last_level, fread_number( fp ) );
save.c:	    KEY( "LastKi",	ch->lastkingdom,	fread_number( fp ) );		
save.c:	    KEY( "LastPk",	ch->lastpk, 		fread_number( fp ) );		
save.c:	    KEY( "LLev",	ch->pcdata->last_level, fread_number( fp ) );
save.c:	    KEY( "Level",	ch->level,		fread_number( fp ) );
save.c:	    KEY( "Lev",		ch->level,		fread_number( fp ) );
save.c:	    KEY( "Levl",	ch->level,		fread_number( fp ) );
save.c:	    KEY( "LongDescr",	ch->long_descr,		fread_string( fp ) );
save.c:	    KEY( "LnD",		ch->long_descr,		fread_string( fp ) );
save.c:	    KEY( "MSP",		ch->msp,		fread_number(fp ) );
save.c:	    KEY( "Name",	ch->name,		fread_string( fp ) );
save.c:	    KEY( "Owed",	ch->pcdata->owed,	fread_number(fp));
save.c:	    KEY( "Password",	ch->pcdata->pwd,	fread_string( fp ) );
save.c:	    KEY( "Pass",	ch->pcdata->pwd,	fread_string( fp ) );
save.c:	    KEY( "Played",	ch->played,		fread_number( fp ) );
save.c:	    KEY( "Plyd",	ch->played,		fread_number( fp ) );
save.c:	    KEY( "Points",	ch->pcdata->points,	fread_number( fp ) );
save.c:	    KEY( "Pnts",	ch->pcdata->points,	fread_number( fp ) );
save.c:	    KEY( "Position",	ch->position,		fread_number( fp ) );
save.c:	    KEY( "Pos",		ch->position,		fread_number( fp ) );
save.c:	    KEY( "Practice",	ch->practice,		fread_number( fp ) );
save.c:	    KEY( "Prac",	ch->practice,		fread_number( fp ) );
save.c:            KEY( "Prompt",      ch->prompt,             fread_string( fp ) );
save.c: 	    KEY( "Prom",	ch->prompt,		fread_string( fp ) );
save.c:	    KEY( "Pkban",	ch->pkban,		fread_number( fp ) );
save.c:	    KEY( "Pks",        ch->pcdata->pkills,	fread_number( fp ) );
save.c:                ch->pcdata->pretitle = fread_string( fp );
save.c:      if (ch->pcdata->pretitle[0] != '.' && ch->pcdata->pretitle[0] != ','
save.c:      &&  ch->pcdata->pretitle[0] != '!' && ch->pcdata->pretitle[0] != '?')
save.c:                    sprintf( buf, "%s", ch->pcdata->pretitle );
save.c:                    free_string( ch->pcdata->pretitle );
save.c:                    ch->pcdata->pretitle = str_dup( buf );
save.c:	    KEY( "Ques",	ch->quest, fread_number( fp ) );
save.c:            KEY( "QuestPnts",   ch->questpoints, fread_number( fp) );
save.c:            KEY( "QuestNext",   ch->nextquest,fread_number( fp ) );
save.c:            KEY( "QuestCurr",   ch->quest_curr,fread_number( fp ) );
save.c:            KEY( "QuestAcc",   ch->quest_accum,fread_number( fp ) );
save.c:	    KEY( "Relig",       ch->religion,           fread_number( fp) );
save.c:	    KEY( "Race",        ch->race,
save.c:	    KEY( "Rank",	ch->kingdom_rank,fread_number( fp ) );
save.c:	    KEY( "Real",	ch->pcdata->real_name,	fread_string( fp ) );
save.c:		ch->in_room = get_room_index( fread_number( fp ) );
save.c:		if ( ch->in_room == NULL )
save.c:		    ch->in_room = get_room_index( ROOM_VNUM_LIMBO );
save.c:	    KEY( "SavingThrow",	ch->saving_throw,	fread_number( fp ) );
save.c:	    KEY( "Save",	ch->saving_throw,	fread_number( fp ) );
save.c:	    KEY( "Scro",	ch->lines,		fread_number( fp ) );
save.c:	    KEY( "Sec",         ch->pcdata->security,	fread_number( fp ) );	/* OLC */
save.c:	    KEY( "Sex",		ch->sex,		fread_number( fp ) );
save.c:	    KEY( "ShortDescr",	ch->short_descr,	fread_string( fp ) );
save.c:	    KEY( "ShD",		ch->short_descr,	fread_string( fp ) );
save.c: 	    KEY( "Sign",        ch->pcdata->sign,	fread_string( fp ) );
save.c:            KEY( "Silv",        ch->silver,             fread_number( fp ) );
save.c:	    KEY( "Sitelock",	ch->sitelock,		fread_string( fp ) );
save.c:	    KEY( "Spouse",	ch->pcdata->spouse,	fread_string( fp ) );
save.c:		    ch->pcdata->learned[sn] = value;
save.c:            KEY( "TrueSex",     ch->pcdata->true_sex,  	fread_number( fp ) );
save.c:	    KEY( "TSex",	ch->pcdata->true_sex,   fread_number( fp ) );
save.c:	    KEY( "Trai",	ch->train,		fread_number( fp ) );
save.c:	    KEY( "Trust",	ch->trust,		fread_number( fp ) );
save.c:	    KEY( "Tru",		ch->trust,		fread_number( fp ) );
save.c:	    KEY( "TD",	ch->pcdata->total_death,	fread_number(fp));
save.c:		  ch->pcdata->title = fread_string( fp );
save.c:    		if (ch->pcdata->title[0] != '.' && ch->pcdata->title[0] != ','
save.c:		&&  ch->pcdata->title[0] != '!' && ch->pcdata->title[0] != '?')
save.c:		    sprintf( buf, " %s", ch->pcdata->title );
save.c:		    free_string( ch->pcdata->title );
save.c:		    ch->pcdata->title = str_dup( buf );
save.c:	    KEY( "Version",     ch->version,		fread_number ( fp ) );
save.c:	    KEY( "Vers",	ch->version,		fread_number ( fp ) );
save.c:		ch->pIndexData = get_mob_index( fread_number( fp ) );
save.c:	    KEY( "Wimpy",	ch->wimpy,		fread_number( fp ) );
save.c:	    KEY( "Wimp",	ch->wimpy,		fread_number( fp ) );
save.c:	    KEY( "Wizn",	ch->wiznet,		fread_flag( fp ) );
save.c:	    KEY( "AfBy2",       ch->affected_by2,       fread_flag( fp ) );
save.c:            KEY( "AfDetect",    ch->detection,          fread_flag( fp ) );
save.c:		ch->pet = pet;
skills.c:    for ( trainer = ch->in_room->people;
skills.c:        if (ch->train < 1)
skills.c:        ch->practice += 10;
skills.c:        ch->train -=1 ;
skills.c:        if (ch->practice < 10)
skills.c:        ch->practice -= 10;
skills.c:        ch->train +=1 ;
skills.c:      if (skill_table[sn].skill_level[ch->class] < LEVEL_HERO &&
skills.c:(skill_table[sn].kingdom == ch->kingdom || skill_table[sn].kingdom ==
skills.c:        lev = skill_table[sn].skill_level[ch->class];
skills.c:        if (ch->level < lev)
skills.c:                      100/(2 + ch->level - lev));
skills.c:      if (skill_table[sn].skill_level[ch->class] < LEVEL_HERO &&
skills.c:(skill_table[sn].kingdom == ch->kingdom || skill_table[sn].kingdom ==
skills.c:        lev = skill_table[sn].skill_level[ch->class];
skills.c:        if (ch->level < lev)
skills.c:                                         ch->pcdata->learned[sn]);
skills.c:  expl = 1500 + pc_race_table[ch->race].points +
skills.c:                        class_table[ch->class].points + ch->level*100;
skills.c:  return (expl * pc_race_table[ch->race].class_mult[ch->class]/100);
skills.c:  return ( base - exp_this_level(ch,ch->level,points) );
skills.c:  return (ch->exp - (ch->level * base ) );
skills.c: expl = 1500 + pc_race_table[ch->race].points +
skills.c:                        class_table[ch->class].points + ch->level*100;
skills.c:   return expl * pc_race_table[ch->race].class_mult[ch->class]/100;
skills.c:    if (ch->level < skill_table[sn].skill_level[ch->class]
skills.c:    ||  skill_table[sn].rating[ch->class] == 0
skills.c:    ||  ch->pcdata->learned[sn] == 0
skills.c:    ||  ch->pcdata->learned[sn] == 100)
skills.c:   if(!IS_SET(ch->quest, QUEST_WEAPONSMITH ) && ch->level >= 40) 
skills.c:   if(!IS_SET(ch->quest, QUEST_GOLEM ) && ch->level >= 60) 
skills.c:                *       ((skill_table[sn].rating[ch->class]))
skills.c:    chance += ch->level;
skills.c:        chance = URANGE(5,100 - ch->pcdata->learned[sn], 95);
skills.c:            ch->pcdata->learned[sn]++;
skills.c:            gain_exp(ch,2 * skill_table[sn].rating[ch->class]);
skills.c:        chance = URANGE(5,ch->pcdata->learned[sn]/2,30);
skills.c:            ch->pcdata->learned[sn] += number_range(1,3);
skills.c:            ch->pcdata->learned[sn] = UMIN(ch->pcdata->learned[sn],100);
skills.c:            gain_exp(ch,2 * skill_table[sn].rating[ch->class]);
skills.c:                && ch->pcdata->learned[sn] < 1
skills.c:              && skill_table[sn].skill_level[ch->class] < LEVEL_IMMORTAL)
skills.c:            ch->pcdata->learned[sn] = 1;
special.c:    if (ch->fighting != NULL) return spec_cast_mage( ch );
special.c:    if (!IS_AWAKE(ch) || IS_AFFECTED(ch,AFF_CALM) || ch->in_room == NULL 
special.c:    ||  IS_AFFECTED(ch,AFF_CHARM) || ch->fighting != NULL)
special.c:    for (vch = ch->in_room->people;  vch != NULL;  vch = vch->next_in_room)
special.c:	if (vch->pIndexData->vnum == MOB_VNUM_PATROLMAN)
special.c:	if (vch->pIndexData->group == GROUP_VNUM_OGRES
special.c:	&&  ch->level > vch->level - 2 && !is_safe(ch,vch))
special.c:    if (!IS_AWAKE(ch) || IS_AFFECTED(ch,AFF_CALM) || ch->in_room == NULL
special.c:    ||  IS_AFFECTED(ch,AFF_CHARM) || ch->fighting != NULL)
special.c:    for (vch = ch->in_room->people;  vch != NULL;  vch = vch->next_in_room)
special.c:        if (vch->pIndexData->vnum == MOB_VNUM_PATROLMAN)
special.c:        if (vch->pIndexData->group == GROUP_VNUM_TROLLS
special.c:        &&  ch->level > vch->level - 2 && !is_safe(ch,vch))
special.c:    if (!IS_AWAKE(ch) || IS_AFFECTED(ch,AFF_CALM) || ch->in_room == NULL
special.c:    ||  IS_AFFECTED(ch,AFF_CHARM) || ch->fighting != NULL)
special.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
special.c:	if (vch->fighting != NULL)  /* break it up! */
special.c:	        victim = (vch->level > vch->fighting->level) 
special.c:		    ? vch : vch->fighting;
special.c:    if (victim == NULL || (IS_NPC(victim) && victim->spec_fun == ch->spec_fun))
special.c:    	for ( vch = char_list; vch != NULL; vch = vch->next )
special.c:            if ( vch->in_room == NULL )
special.c:            if (vch->in_room != ch->in_room 
special.c:	    &&  vch->in_room->area == ch->in_room->area)
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim, TARGET_CHAR);
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, NULL,TARGET_CHAR);
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	spell_armor( skill_lookup( "armor" ), ch->level,ch,victim,TARGET_CHAR);
special.c:	spell_bless( skill_lookup( "bless" ), ch->level,ch,victim,TARGET_CHAR);
special.c:	    ch->level, ch, victim,TARGET_CHAR);
special.c:	    ch->level, ch, victim,TARGET_CHAR);
special.c:	    ch->level, ch, victim,TARGET_CHAR);
special.c:	spell_refresh( skill_lookup("refresh"),ch->level,ch,victim,TARGET_CHAR);
special.c:	    ch->level,ch,victim,TARGET_CHAR);
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	if ( ch->level >= min_level )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim,TARGET_CHAR);
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim,TARGET_CHAR);
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	if ( ch->level >= min_level )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim,TARGET_CHAR);
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim,TARGET_CHAR);
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	if ( ch->level >= min_level )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim,TARGET_CHAR);
special.c:    if ( !IS_AWAKE(ch) || ch->fighting != NULL )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	if((victim->kingdom > 0) && victim->kingdom != ch->kingdom) {
special.c:    REMOVE_BIT(ch->comm,COMM_NOSHOUT);
special.c:    for ( corpse = ch->in_room->contents; corpse != NULL; corpse = c_next )
special.c:	    obj_to_room( obj, ch->in_room );
special.c:    for ( trash = ch->in_room->contents; trash != NULL; trash = trash_next )
special.c:    if ( !move || ch->position < POS_SLEEPING )
special.c:	ch->position = POS_STANDING;
special.c:	ch->position = POS_SLEEPING;
special.c:	for( key=ch->in_room->contents; key!=NULL; key=key->next_content )
special.c:	for( key=ch->in_room->contents; key!=NULL; key=key->next_content )
special.c:    if ( ch->position != POS_FIGHTING
special.c:    || ( victim = ch->fighting ) == NULL
special.c:    ||   number_percent( ) > 2 * ch->level )
special.c:    spell_poison( gsn_poison, ch->level, ch, victim,TARGET_CHAR);
special.c:    if ( ch->position != POS_FIGHTING
special.c:    || ( victim = ch->fighting ) == NULL
special.c:    ||   number_percent( ) > 2 * ch->level )
special.c:    spell_poison( gsn_poison, ch->level, ch, victim,TARGET_CHAR);
special.c:    if ( ch->position != POS_STANDING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	if ( IS_AWAKE(victim) && number_range( 0, ch->level ) == 0 )
special.c:	    gold = victim->gold * UMIN(number_range(1,20),ch->level / 2) / 100;
special.c:	    gold = UMIN(gold, ch->level * ch->level * 10 );
special.c:	    ch->gold     += gold;
special.c:	    silver = victim->silver * UMIN(number_range(1,20),ch->level/2)/100;
special.c:	    silver = UMIN(silver,ch->level*ch->level * 25);
special.c:	    ch->silver	+= silver;
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	spell_armor( skill_lookup( "armor" ), ch->level, ch, victim, TARGET_CHAR );
special.c:	spell_bless( skill_lookup( "bless" ), ch->level, ch, victim, TARGET_CHAR );
special.c:	    ch->level, ch, victim, TARGET_CHAR );
special.c:	    ch->level, ch, victim, TARGET_CHAR );
special.c:	    ch->level, ch, victim, TARGET_CHAR );
special.c:	spell_refresh( skill_lookup( "refresh" ), ch->level, ch, victim, 
special.c:    if ( !IS_AWAKE(ch) || ch->fighting != NULL )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:    if ( !IS_AWAKE(ch) || ch->fighting != NULL )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	if((victim->kingdom > 0) && victim->kingdom != ch->kingdom) {
special.c:    if ( !IS_AWAKE(ch) || ch->fighting != NULL )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	if((victim->kingdom > 0) && victim->kingdom != ch->kingdom) {
special.c:  victim = ch->last_fought;
special.c:  if (ch->fighting != NULL)
special.c:      ch->kingdom = KINGDOM_TRISTAN;
special.c:  for (wch = ch->in_room->people; wch != NULL; wch = wch_next)
special.c:    wch_next = wch->next_in_room;
special.c:  if (ch->status == 5)
special.c:      if (ch->in_room != 
special.c:      	  ch->kingdom = KINGDOM_TRISTAN;
special.c:  if (ch->fighting != NULL)
special.c:  if (ch->position < POS_SLEEPING)
special.c:  if (time_info.hour == 18 && ch->status != 1)
special.c:      ch->position = POS_SLEEPING;
special.c:      ch->status = 1;
special.c:  else if (time_info.hour == 0 && ch->status != 0)
special.c:      ch->position = POS_STANDING;
special.c:      ch->status = 0;
special.c:  if (ch->fighting != NULL)
special.c:  if (ch->position < POS_SLEEPING)
special.c:  if (time_info.hour == 23 && ch->status != 1)
special.c:      ch->position = POS_SLEEPING;
special.c:      ch->status = 1;
special.c:  else if (time_info.hour == 5 && ch->status != 0)
special.c:      ch->position = POS_STANDING;
special.c:      ch->status = 0;
special.c:  if (ch->fighting != NULL)
special.c:  if (ch->position < POS_SLEEPING)
special.c:  if (time_info.hour == 19 && ch->status != 1)
special.c:      ch->position = POS_SLEEPING;
special.c:      ch->status = 1;
special.c:  else if (time_info.hour == 4 && ch->status != 0)
special.c:      ch->position = POS_STANDING;
special.c:      ch->status = 0;
special.c:    if (ch->position != POS_FIGHTING) {
special.c:       for ( victim = ch->in_room->people; victim != NULL; victim = v_next)
special.c:             && (victim->level > ch->level)
special.c:             && (victim->level < ch->level + 10))
special.c:             if (ch->position != POS_FIGHTING)
special.c:    if ( (victim = ch->fighting) == NULL)
special.c:                 ch->gold     += gold;
special.c:      for(ch=mob->in_room->people; ch!=NULL; ch=ch->next_in_room)  {
special.c:        if (ch->pIndexData->vnum == 3306) FAULT_D = FALSE;
special.c:      for(ch=mob->in_room->people; ch!=NULL; ch=ch->next_in_room)  {
special.c:        if (ch->pIndexData->vnum == 3003) FAULT_W = FALSE;
string.c:    ch->desc->pString = pString;
string.c:    ch->desc->pString = pString;
string.c:	    free_string(*ch->desc->pString);
string.c:           *ch->desc->pString = str_dup( "" );
string.c:	    send_to_char( numlineas(*ch->desc->pString), ch );
string.c:            *ch->desc->pString =
string.c:                string_replace( *ch->desc->pString, arg2, arg3 );
string.c:                        *ch->desc->pString =
string.c:               string_replace2 (ch, *ch->desc->pString, atoi(arg2), arg3);
string.c:                        *ch->desc->pString =
string.c:   string_insertline (ch, *ch->desc->pString, atoi (arg2), arg3);
string.c:                        *ch->desc->pString =
string.c:                           string_deleteline (*ch->desc->pString, atoi (arg2));
string.c:	    *ch->desc->pString = del_last_line(*ch->desc->pString );
string.c:            *ch->desc->pString = format_string( *ch->desc->pString );
string.c:      if ( ch->desc->editor == ED_MPCODE ) /* para los mobprogs */
string.c:        ch->desc->pString = NULL;
string.c:    strcpy( buf, *ch->desc->pString );
string.c:        ch->desc->pString = NULL;
string.c:    free_string( *ch->desc->pString );
string.c:    *ch->desc->pString = str_dup( buf );
trap.c:    for (obj = ch->in_room->contents; obj != NULL; obj = obj_next)
trap.c:        ch->position = POS_SLEEPING;
trap.c:      for (wch = ch->in_room->people; wch != NULL; wch = wch->next_in_room)
trap.c:        wch->position = POS_SLEEPING;
trap.c:     if ( ch->in_room == NULL
trap.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
trap.c:    || ( !IS_NPC(ch) && ch->fighting != NULL ) )
trap.c:        for (wch = ch->in_room->people; wch != NULL; wch = wch->next_in_room)
trap.c:        if ( wch->in_room == NULL
trap.c:       ||   IS_SET(wch->in_room->room_flags, ROOM_NO_RECALL)
trap.c:       || ( !IS_NPC(wch) && wch->fighting != NULL ) )
trap.c:    if ( ch->position == POS_DEAD )
trap.c:            REMOVE_BIT( ch->affected_by, AFF_INVISIBLE );
trap.c:    ch->hit -= dam;
trap.c:    &&   ch->level >= LEVEL_IMMORTAL
trap.c:    &&   ch->hit < 1 )
trap.c:      ch->hit = 1;
trap.c:    switch( ch->position )
trap.c:        if ( dam > ch->max_hit / 4 )
trap.c:        if ( ch->hit < ch->max_hit / 4 )
trap.c:   if (ch->position == POS_DEAD)
trap.c:                ch->name,
trap.c:                ch->in_room->vnum );
trap.c:     if ( ch->exp > exp_per_level(ch,ch->pcdata->points)
trap.c:                                * ch->level )
trap.c:     gain_exp( ch, -(UMIN(1000,ch->exp * 0.08))
trap.c:                       *(0.025*ch->pcdata->pkills) );
trap.c:      for (wch = ch->in_room->people; wch != NULL; wch = wch->next_in_room)
trap.c:         if ( wch->position == POS_DEAD )
trap.c:  REMOVE_BIT( wch->affected_by, AFF_INVISIBLE );
trap.c:    wch->hit -= dam;
trap.c:    &&   wch->level >= LEVEL_IMMORTAL
trap.c:    &&   wch->hit < 1 )
trap.c:      wch->hit = 1;
trap.c:    switch( wch->position )
trap.c:        if ( dam > wch->max_hit / 4 )
trap.c:        if ( wch->hit < wch->max_hit / 4 )
trap.c:   if (wch->position == POS_DEAD)
trap.c:                wch->name,
trap.c:                wch->in_room->vnum );
trap.c:         if ( !IS_SET ( wch->in_room->room_flags, ROOM_ARENA ) )
trap.c:          gain_exp( wch, - UMIN(1000,wch->exp * 0.08));
trap.c:            wch->pcdata->total_death += 1;
update.c:    ch->pcdata->last_level = 
update.c:	( ch->played + (int) (current_time - ch->logon) ) / 3600;
update.c:if(ch->level <= 50) {
update.c:     if (!IS_SET(ch->comm, COMM_BLOCKTITLE)) {
update.c:	title_table [ch->class] [ch->level] [ch->sex == SEX_FEMALE ? 1 : 0] );
update.c:if ((strlen(ch->description) < 250 ) && (ch->level > 8)) {
update.c:if ((strlen(ch->pcdata->background) < 500 ) && (ch->level > 18)) {
update.c:if ((strlen(ch->description) < 250 ) && (ch->level > 10)) {
update.c:if ((strlen(ch->pcdata->background) < 500 ) && (ch->level > 20)) {
update.c:		    class_table[ch->class].hp_min,
update.c:		    class_table[ch->class].hp_max );
update.c:    //if (!class_table[ch->class].fMana)
update.c:    ch->max_hit 	+= add_hp;
update.c:    ch->max_mana	+= add_mana;
update.c:    ch->max_move	+= add_move;
update.c:    ch->practice	+= add_prac;
update.c:    ch->train		+= ch->level%5==0?1:0;
update.c:    ch->pcdata->perm_hit	+= add_hp;
update.c:    ch->pcdata->perm_mana	+= add_mana;
update.c:    ch->pcdata->perm_move	+= add_move;
update.c:	add_hp,		ch->max_hit,
update.c:	add_mana,	ch->max_mana,
update.c:	add_move,	ch->max_move,
update.c:	add_prac,	ch->practice
update.c:    if (!(ch->level%10))
update.c:    if ( IS_NPC(ch) || ch->level >= LEVEL_HERO )
update.c:    ch->exp = UMAX( exp_per_level(ch,ch->pcdata->points), ch->exp + gain );
update.c:    while ( ch->level < LEVEL_HERO && ch->exp >= 
update.c:	exp_per_level(ch,ch->pcdata->points) * (ch->level+1) )
update.c:    ch->exp = UMAX( base_exp(ch,ch->pcdata->points), ch->exp + gain );
update.c:    while ( ch->level < LEVEL_HERO &&
update.c:           exp_to_level(ch,ch->pcdata->points) <= 0)
update.c:	ch->level += 1;
update.c:        if (ch->level > 5)
update.c:        if (ch->level == 80)
update.c:            sprintf(log_buf, "%s made level 80.", ch->name);
update.c:        sprintf(log_buf, "%s attained level %d.",ch->name,ch->level);
update.c:	sprintf(buf,"[$N has attained level %d]",ch->level);
update.c:    if (ch->in_room == NULL)
update.c:	gain =  5 + ch->level;
update.c:	switch(ch->position)
update.c:	gain = UMAX(3,get_curr_stat(ch,STAT_CON) - 3 + ch->level/2); 
update.c:	gain += class_table[ch->class].hp_max - 10;
update.c:	    if (ch->hit < ch->max_hit)
update.c:	switch ( ch->position )
update.c:	if ( ch->pcdata->condition[COND_HUNGER]   < 0 )
update.c:	if ( ch->pcdata->condition[COND_THIRST] < 0 )
update.c:    gain = gain * ch->in_room->heal_rate / 100;
update.c:    if (ch->on != NULL && ch->on->item_type == ITEM_FURNITURE)
update.c:	gain = gain * ch->on->value[3] / 100;
update.c:    if(ch->in_room == get_room_index(ROOM_VNUM_SHADOWPLANE))
update.c:    return UMIN(gain, ch->max_hit - ch->hit);
update.c:    if (ch->in_room == NULL)
update.c:	gain = 5 + ch->level;
update.c:	switch (ch->position)
update.c:	      + get_curr_stat(ch,STAT_INT) + ch->level) / 2;
update.c:	    if (ch->mana < ch->max_mana)
update.c:	    if (ch->mana < ch->max_mana)
update.c:	if (!class_table[ch->class].fMana)
update.c:	switch ( ch->position )
update.c:	if ( ch->pcdata->condition[COND_HUNGER]   < 0 )
update.c:	if ( ch->pcdata->condition[COND_THIRST] < 0 )
update.c:    gain = gain * ch->in_room->mana_rate / 100;
update.c:    if (ch->on != NULL && ch->on->item_type == ITEM_FURNITURE)
update.c:	gain = gain * ch->on->value[4] / 100;
update.c:    if(ch->in_room == get_room_index(ROOM_VNUM_SHADOWPLANE))
update.c:    return UMIN(gain, ch->max_mana - ch->mana);
update.c:    if (ch->in_room == NULL)
update.c:	gain = ch->level;
update.c:	gain = UMAX( 15, ch->level );
update.c:	switch ( ch->position )
update.c:	if ( ch->pcdata->condition[COND_HUNGER]   < 0 )
update.c:	if ( ch->pcdata->condition[COND_THIRST] < 0 )
update.c:    gain = gain * ch->in_room->heal_rate/100;
update.c:    if (ch->on != NULL && ch->on->item_type == ITEM_FURNITURE)
update.c:	gain = gain * ch->on->value[3] / 100;
update.c:    if(ch->in_room == get_room_index(ROOM_VNUM_SHADOWPLANE))
update.c:    return UMIN(gain, ch->max_move - ch->move);
update.c:    if (IS_SET(ch->in_room->room_flags,ROOM_ARENA)) {
update.c:	ch->pcdata->condition[iCond] = 20;
update.c:    if ( value == 0 || IS_NPC(ch) || ch->level >= LEVEL_IMMORTAL ||
update.c:	IS_SET(ch->comm,COMM_BUSY) || !ch->desc ||
update.c:	IS_SET(ch->in_room->room_flags,ROOM_ARENA))
update.c:    condition				= ch->pcdata->condition[iCond];
update.c:    ch->pcdata->condition[iCond]	= URANGE( -6, condition + value, 96 );
update.c:    if ( iCond == COND_FULL && (ch->pcdata->condition[COND_FULL] < 0) )
update.c:       ch->pcdata->condition[COND_FULL] = 0;
update.c:      ch->pcdata->condition[COND_DRUNK] = 0; */
update.c:    if ( ch->pcdata->condition[iCond] < 1 && ch->pcdata->condition[iCond] > -6 )
update.c:    if ( ch->pcdata->condition[iCond] == -6 && ch->exp >= PK_MIN)
update.c:	    ch->hit -= ch->max_hit * number_range(2, 4) / 100;
update.c:	    if ( ch->position == POS_SLEEPING ) 
update.c:	    ch->hit -= ch->max_hit * number_range(2, 4) / 100;
update.c:            if (ch->in_room && ch->in_room->people && !ch->fighting)
update.c:                 for ( vch = ch->in_room->people;
update.c:                        vch != NULL && ch->fighting == NULL; vch =vch_next)
update.c:                  vch_next = vch->next_in_room;
update.c:			do_murder(ch,vch->name);
update.c:            damage_hunger = ch->max_hit * number_range(2, 4) / 100;
update.c:            if ( ch->position == POS_SLEEPING )
update.c:	ch_next = ch->next;
update.c:  if ( IS_AFFECTED(ch, AFF_REGENERATION ) && ch->in_room != NULL )
update.c:         ch->hit = UMIN( ch->hit + ch->level / 10, ch->max_hit );
update.c:        if ( IS_AFFECTED(ch, AFF_CORRUPTION ) && ch->in_room != NULL )
update.c:         ch->hit = UMAX( ch->hit - ch->level / 10, 3 );
update.c:	if ( !IS_NPC(ch) || ch->in_room == NULL || 
update.c:	(IS_AFFECTED(ch,AFF_CHARM) && ch->pIndexData->vnum!=11))
update.c:	if (ch->in_room->area->empty && !IS_SET(ch->act,ACT_UPDATE_ALWAYS))
update.c:	if ( ch->spec_fun != 0 )
update.c:	    if ( (*ch->spec_fun) ( ch ) )
update.c:	if (ch->pIndexData->pShop != NULL) /* give him some gold */
update.c:	    if ((ch->gold * 100 + ch->silver) < ch->pIndexData->wealth)
update.c:		ch->gold += ch->pIndexData->wealth * number_range(1,20)/5000000;
update.c:		ch->silver += ch->pIndexData->wealth * number_range(1,20)/50000;
update.c:       if ( ch->position == ch->pIndexData->default_pos )
update.c:           &&   ch->mprog_delay > 0 )
update.c:               if ( --ch->mprog_delay <= 0 )
update.c:	if ( ch->position == POS_STANDING ||
update.c:	     ch->position == POS_RESTING ||
update.c:	     ch->position == POS_FIGHTING )
update.c:		(ch->hit<ch->max_hit*0.9 || 
update.c:		 IS_AFFECTED(ch,AFF_PLAGUE) || ch->fighting!=NULL) )  
update.c:	      for(obj=ch->carrying;obj!=NULL;obj=obj->next_content)
update.c:		   if ( ch->hit < ch->max_hit*0.9 )  /* hp curies */
update.c:			if ( ch->hit<ch->max_hit*0.5 && cl > 3 )  {
update.c:			else if ( ch->hit<ch->max_hit*0.7 )  {
update.c:	     	   if ( ch->fighting != NULL )
update.c:		     if ( ch->level-ch->fighting->level < 7 && al>3)
update.c:		     if ( ch->level-ch->fighting->level < 8 && al>2 )
update.c:		     if ( ch->level-ch->fighting->level < 9 && al>1 )
update.c:		     if ( ch->level-ch->fighting->level < 10 && al>0 )
update.c:	if ( ch->position != POS_STANDING )
update.c:        if ( IS_SET(ch->progtypes,MPROG_AREA) &&
update.c:            (ch->in_room->area->nplayer > 0))
update.c:          (ch->pIndexData->moprogs->area_prog) (ch);
update.c:        if (ch->position < POS_STANDING)
update.c:	if ( IS_SET(ch->act, ACT_SCAVENGER)
update.c:	&&   ch->in_room->contents != NULL
update.c:	    for ( obj = ch->in_room->contents; obj; obj = obj->next_content )
update.c:	if ( !IS_SET(ch->act, ACT_SENTINEL) 
update.c:	&& ( pexit = ch->in_room->exit[door] ) != NULL
update.c:	&& ( !IS_SET(ch->act, ACT_STAY_AREA)
update.c:	||   pexit->u1.to_room->area == ch->in_room->area ) 
update.c:	&& ( !IS_SET(ch->act, ACT_OUTDOORS)
update.c:	&& ( !IS_SET(ch->act, ACT_INDOORS)
update.c:	ch_next = ch->next;
update.c:        if (is_affected(ch,gsn_caltraps) && !ch->fighting)
update.c:        if ( !(ch->fighting) && !IS_AFFECTED(ch,AFF_SNEAK) &&
update.c:            (race_table[ch->race].aff & AFF_SNEAK))
update.c:        if ( !(ch->fighting) && !IS_AFFECTED(ch,AFF_HIDE) &&
update.c:            (race_table[ch->race].aff & AFF_HIDE))
update.c:        SET_BIT(ch->affected_by, race_table[ch->race].aff );
update.c:        if ( ch->timer > 20 && !IS_NPC(ch) )
update.c:            && ch->fighting == NULL
update.c:            && IS_AWAKE(ch) && ch->last_fought != NULL
update.c:            && !IS_SET(ch->act,ACT_NOTRACK)
update.c:            && ch->in_room != ch->last_fought->in_room 
update.c:	    && ch->level > 11) {
update.c:          do_track(ch,ch->last_fought->name);
update.c:          if ((ch->in_room != ch->last_fought->in_room && ch->status!=2)
update.c:	     && ch->level > 11)
update.c:            do_track(ch,ch->last_fought->name);
update.c:	if ( ch->position >= POS_STUNNED )
update.c:            if (IS_NPC(ch) && ch->zone != NULL && ch->zone != ch->in_room->area
update.c:            && ch->desc == NULL &&  ch->fighting == NULL && ch->progtypes==0
update.c:	    if ( ch->hit  < ch->max_hit )
update.c:		ch->hit  += hit_gain(ch);
update.c:		ch->hit = ch->max_hit;
update.c:	    if ( ch->mana < ch->max_mana )
update.c:		ch->mana += mana_gain(ch);
update.c:		ch->mana = ch->max_mana;
update.c:	    if ( ch->move < ch->max_move )
update.c:		ch->move += move_gain(ch);
update.c:		ch->move = ch->max_move;
update.c:	if ( ch->position == POS_STUNNED )
update.c:         if ( !IS_NPC(ch) && ch->pking > 0 )
update.c:            ch->pking--;
update.c:	if ( !IS_NPC(ch) && ch->level < LEVEL_IMMORTAL )
update.c:		if ( --obj->value[2] == 0 && ch->in_room != NULL )
update.c:		    --ch->in_room->light;
update.c:	 	else if ( obj->value[2] <= 5 && ch->in_room != NULL) {
update.c:/*           sprintf(buf2, "*** BUG*** %s - %s.", ch->name,obj->name); */
update.c:		ch->timer = 0;
update.c:	    if ( ++ch->timer >= 12 )
update.c:		if ( ch->was_in_room == NULL && ch->in_room != NULL )
update.c:		    ch->was_in_room = ch->in_room;
update.c:		    if ( ch->fighting != NULL )
update.c:		    if (ch->level > 1  )
update.c:		 if ( !IS_SET ( ch->in_room->room_flags, ROOM_ARENA ) )
update.c:		    if ( ch->level < 10 )  {
update.c: if ( !IS_SET ( ch->in_room->room_flags, ROOM_ARENA ) ) {
update.c:	    gain_condition( ch, COND_FULL, ch->size > SIZE_MEDIUM ? -4 : -2 );
update.c:	    if ( ch->in_room->sector_type == SECT_DESERT )
update.c:	    gain_condition( ch, COND_HUNGER, ch->size > SIZE_MEDIUM ? -2 : -1);
update.c:	for ( paf = ch->affected; paf != NULL; paf = paf_next )
update.c:	    if (ch->in_room == NULL)
update.c:            for ( af = ch->affected; af != NULL; af = af->next )
update.c:            	REMOVE_BIT(ch->affected_by,AFF_PLAGUE);
update.c:            for ( vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
update.c:	    dam = UMIN(ch->level,af->level/5+1);
update.c:	    ch->mana -= dam;
update.c:	    ch->move -= dam;
update.c:  	      damage( ch, ch, UMAX(ch->max_hit/20, 50), gsn_plague,DAM_DISEASE,TRUE);
update.c:	    poison = affect_find(ch->affected,gsn_poison);
update.c:	else if ( ch->position == POS_INCAP && number_range(0,1) == 0)
update.c:	else if ( ch->position == POS_MORTAL )
update.c:            ch_next = ch->next;
update.c:            if ( ch == ch_quit || ch->timer > 20 )
update.c:	wch_next = wch->next;
update.c:  IS_AFFECTED(wch,AFF_BLOODTHIRST) && wch->fighting == NULL)    
update.c:          for ( vch = wch->in_room->people;
update.c:               vch != NULL && wch->fighting == NULL; vch = vch_next)
update.c:              vch_next = vch->next_in_room;
update.c:                  do_murder(wch,vch->name);
update.c:	||   wch->level >= LEVEL_IMMORTAL
update.c:	||   wch->in_room == NULL 
update.c:	||   wch->in_room->area->empty)
update.c:	for ( ch = wch->in_room->people; ch != NULL; ch = ch_next )
update.c:	    ch_next	= ch->next_in_room;
update.c:	    ||	 (!IS_SET(ch->act, ACT_AGGRESSIVE) && (ch->last_fought == NULL))
update.c:	    ||   IS_SET(ch->in_room->room_flags,ROOM_SAFE)
update.c:	    ||   ch->fighting != NULL
update.c:	    ||   ( IS_SET(ch->act, ACT_WIMPY) && IS_AWAKE(wch) )
update.c:          if (ch->last_fought == wch ) {
update.c:                     !IS_SET(ch->act,PLR_HOLYLIGHT))?
update.c:                    PERS(wch->doppel,ch) : PERS(wch,ch));
update.c:          if (ch->last_fought != NULL)
update.c:	    for ( vch = wch->in_room->people; vch != NULL; vch = vch_next )
update.c:		vch_next = vch->next_in_room;
update.c:		&&   vch->level < LEVEL_IMMORTAL
update.c:		&&   ch->level >= vch->level - 5 
update.c:		&&   ( !IS_SET(ch->act, ACT_WIMPY) || !IS_AWAKE(vch) )
update.c:        for (ch = char_list; ch != NULL; ch = ch->next)
update.c:            if (!IS_NPC(ch) && ch->in_room != NULL)
update.c:                    ch->in_room->area->count =
update.c:                      UMIN(ch->in_room->area->count+1,5000000);
update.c:            for ( vch = room->people; vch != NULL; vch = vch->next_in_room)
update.c:            for ( vch = room->people; vch != NULL; vch = vch->next_in_room)
update.c:            for ( vch = room->people; vch != NULL; vch = vch->next_in_room)
update.c:            for ( vch = room->people; vch != NULL; vch = vch->next_in_room)
update.c:                &&  !(IS_NPC(vch) && IS_SET(vch->act,ACT_UNDEAD) )
update.c:                    vch->position = POS_SLEEPING;
update.c:            for ( vch = room->people; vch != NULL; vch = vch->next_in_room)
update.c:    ch_next = ch->next;
update.c:    && ch->in_room->sector_type == SECT_WATER_NOSWIM
update.c:    && ch->in_room->sector_type == SECT_WATER_SWIM
update.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
update.c:     if ( ch->hit > 20)
update.c:      ch->position = POS_RESTING;
update.c:       ch->hit /= 2;
update.c:      ch->hit = 1;
who_list.c:    if (!(wch->invis_level > LEVEL_HERO) && 
who_list.c:      sprintf(buf2, "%6s", pc_race_table[wch->race].who_name);
who_list.c:      sprintf(buf2, "%s", wch->pcdata->pretitle);
who_list.c:      sprintf(buf, "%s", wch->name);
who_list.c:      sprintf(buf2, "%s", wch->pcdata->title);
wizutil.c:	pArea = ch->in_room->area; /* this is the area we want info on */
wizutil.c:		return ch->name;
wizutil.c:	one_argument (ch->name, name); /* copy the first word into name */
wizutil.c:	for (rch = ch->in_room->people; rch && (rch != ch);rch = rch->next_in_room)
wizutil.c:		if (is_name (name, rch->name))
wizutil.c:				old_room = ch->in_room;
wizutil.c:					old_room = ch->in_room;
